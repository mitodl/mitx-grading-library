{
    "docs": [
        {
            "location": "/", 
            "text": "MITx Grading Library: An Overview\n # \n\n\nThe \nmitxgraders\n Python library provides a number of configurable Python classes that can be used as graders in edX custom response problems.\n\n\nRelevant Links\n # \n\n\n\n\nA \ncomplete example course\n that demonstrates most of the features of this library is available on edX edge\n\n\nComplete source code\n for the library and the aforementioned example course is available on github\n\n\n\n\nWhy use MITxGraders\n # \n\n\nUse MITxGraders because it:\n\n\n\n\nhas many capabilities beyond the standard edX options\n\n\nis highly configurable but with \nsensible defaults\n\n\nprovides useful error messages\n\n\nto students (when submitting answers \n for example, formula parsing errors)\n\n\nto problem authors (when configuring a grader)\n\n\n\n\n\n\nis reliable (extensively tested)\n\n\nis open source (BSD-3 license, \nour Github repo\n)\n\n\nhas an \nexcellent example edX course\n\n\nis ready for the future of edX by being compatible with python 2 and 3\n\n\nis actively maintained\n\n\n\n\nTwo Typical Examples\n # \n\n\nTypical usage in an edX course looks like:\n\n\nproblem\n\n\nscript type=\nloncapa/python\n\nfrom mitxgraders import *\ngrader = FormulaGrader(\n    variables=[\nx\n],\n    # allows students to use generic functions f and f' in their input\n    user_functions={\nf\n: RandomFunction(), \nf'\n: RandomFunction()}\n)\n\n/script\n\n\n  \np\nEnter the derivative of \\(g(x) = e^{f(x^2)} \\).\n/p\n\n  \n!-- answer is provided to the grader when using single inputs --\n\n  \ncustomresponse cfn=\ngrader\n answer=\ne^(f(x)) * f'(x^2) * 2*x\n\n    \ntextline math=\ntrue\n /\n\n  \n/customresponse\n\n\n\n/problem\n\n\n\n\nThe resulting problem would be similar to an edX \nformularesponse /\n problem, but allows students to use additional generic functions \nf(x)\n and \nf'(x)\n in their submissions.\n\n\nThe next example grader would grade an unordered list of mathematical expressions.\n\n\nproblem\n\n\nscript type=\nloncapa/python\n\nfrom mitxgraders import *\ngrader = ListGrader(\n    answers=['x-2', 'x+2'],\n    subgraders=FormulaGrader(variables=['x'])\n)\n\n/script\n\n\n  \np\nWhat are the linear factors of \\((x^2 - 4)\\)? Enter your answers in any order.\n/p\n\n  \ncustomresponse cfn=\ngrader\n\n    \n!-- correct_answer is shown to student when they press [Show Answer].\n         Its value is not used for grading purposes --\n\n    \ntextline math=\ntrue\n correct_answer=\nx - 2\n /\n\n    \ntextline math=\ntrue\n correct_answer=\nx + 2\n /\n\n  \n/customresponse\n\n\n\n/problem\n\n\n\n\nLoading in edX\n # \n\n\nDownload \npython_lib.zip\n and place it in your static folder (XML workflow) or upload it as a file asset (Studio workflow). If you already have a python_lib.zip, you'll need to merge ours with yours and re-zip. If you want to use our AsciiMath renderer definitions (if you have math problems, you'll really want this!), place the \nMJxPrep.js\n file in your static folder (XML) or upload the file to your course assets (Studio).\n\n\nThe basic idea of this library is that it contains a number of classes that can be used as the check function for an edX custom response problem. Different classes of grader are used for different inputs. We begin by presenting a brief overview on how the grading classes are used in general.\n\n\nGrading Classes\n # \n\n\nGrading classes generally fall into two categories: single-input graders and multi-input graders.\n\n\nSingle-input graders\n grade a single input. All single-input graders are built on a framework we call an \nItemGrader\n. We recommend understanding how \nItemGrader\ns work before diving into more specifics.\n\n\n\n\nItemGrader\n\n\nStringGrader\n for grading text input (includes pattern matching)\n\n\nFormulaGrader\n for grading general formulas\n\n\nNumericalGrader\n for grading numbers\n\n\nMatrixGrader\n for grading formulas with vectors and matrices\n\n\nSingleListGrader\n for grading a delimited (default: comma-separated) list of inputs in a single response box\n\n\n\n\n\n\n\n\nMulti-input graders\n are for grading multiple input boxes at once. They are composed of single-input graders working in concert, handled by the general \nListGrader\n class. \nListGrader\n is the only multi-input grader included in the library, but is incredibly general.\n\n\n\n\nListGrader\n for grading a list of inputs. Examples:\n\n\ngrade an ordered list of text inputs\n\n\ngrade an unordered list of mathematical expressions\n\n\ngrade a list of eigenvalue-eigenvector pairs\n\n\n\n\n\n\n\n\nSpecialized graders\n are used to grade very specific situations. The only specialized grader we presently have is \nIntegralGrader\n, although plugins can be used to construct further examples.\n\n\n\n\nIntegralGrader\n for grading the construction of integrals.\n\n\n\n\nQuestions? Bugs? Issues? Suggestions?\n # \n\n\nPlease contact us by making an issue on \ngithub\n.\n\n\nWhat should I read next?\n # \n\n\n\n\nIf you haven't already done so, we recommend looking at our \nexample course\n to get an idea of the type of things that the library is capable of.\n\n\nIt's probably a good idea to start by looking at how to \ninvoke the grading library in edX\n.\n\n\nNext, we recommend looking at the \nIntroduction to Graders\n and the overview of \nItemGraders\n.\n\n\nAfter that, choose a grader that you're interested in, look at \nsource code for examples for that grader\n, and read up on the relevant documentation.\n\n\n\n\nEnjoy!", 
            "title": "Overview"
        }, 
        {
            "location": "/#mitx-grading-library-an-overview", 
            "text": "The  mitxgraders  Python library provides a number of configurable Python classes that can be used as graders in edX custom response problems.", 
            "title": "MITx Grading Library: An Overview"
        }, 
        {
            "location": "/#relevant-links", 
            "text": "A  complete example course  that demonstrates most of the features of this library is available on edX edge  Complete source code  for the library and the aforementioned example course is available on github", 
            "title": "Relevant Links"
        }, 
        {
            "location": "/#why-use-mitxgraders", 
            "text": "Use MITxGraders because it:   has many capabilities beyond the standard edX options  is highly configurable but with  sensible defaults  provides useful error messages  to students (when submitting answers   for example, formula parsing errors)  to problem authors (when configuring a grader)    is reliable (extensively tested)  is open source (BSD-3 license,  our Github repo )  has an  excellent example edX course  is ready for the future of edX by being compatible with python 2 and 3  is actively maintained", 
            "title": "Why use MITxGraders"
        }, 
        {
            "location": "/#two-typical-examples", 
            "text": "Typical usage in an edX course looks like:  problem  script type= loncapa/python \nfrom mitxgraders import *\ngrader = FormulaGrader(\n    variables=[ x ],\n    # allows students to use generic functions f and f' in their input\n    user_functions={ f : RandomFunction(),  f' : RandomFunction()}\n) /script \n\n   p Enter the derivative of \\(g(x) = e^{f(x^2)} \\). /p \n   !-- answer is provided to the grader when using single inputs -- \n   customresponse cfn= grader  answer= e^(f(x)) * f'(x^2) * 2*x \n     textline math= true  / \n   /customresponse  /problem  The resulting problem would be similar to an edX  formularesponse /  problem, but allows students to use additional generic functions  f(x)  and  f'(x)  in their submissions.  The next example grader would grade an unordered list of mathematical expressions.  problem  script type= loncapa/python \nfrom mitxgraders import *\ngrader = ListGrader(\n    answers=['x-2', 'x+2'],\n    subgraders=FormulaGrader(variables=['x'])\n) /script \n\n   p What are the linear factors of \\((x^2 - 4)\\)? Enter your answers in any order. /p \n   customresponse cfn= grader \n     !-- correct_answer is shown to student when they press [Show Answer].\n         Its value is not used for grading purposes -- \n     textline math= true  correct_answer= x - 2  / \n     textline math= true  correct_answer= x + 2  / \n   /customresponse  /problem", 
            "title": "Two Typical Examples"
        }, 
        {
            "location": "/#loading-in-edx", 
            "text": "Download  python_lib.zip  and place it in your static folder (XML workflow) or upload it as a file asset (Studio workflow). If you already have a python_lib.zip, you'll need to merge ours with yours and re-zip. If you want to use our AsciiMath renderer definitions (if you have math problems, you'll really want this!), place the  MJxPrep.js  file in your static folder (XML) or upload the file to your course assets (Studio).  The basic idea of this library is that it contains a number of classes that can be used as the check function for an edX custom response problem. Different classes of grader are used for different inputs. We begin by presenting a brief overview on how the grading classes are used in general.", 
            "title": "Loading in edX"
        }, 
        {
            "location": "/#grading-classes", 
            "text": "Grading classes generally fall into two categories: single-input graders and multi-input graders.  Single-input graders  grade a single input. All single-input graders are built on a framework we call an  ItemGrader . We recommend understanding how  ItemGrader s work before diving into more specifics.   ItemGrader  StringGrader  for grading text input (includes pattern matching)  FormulaGrader  for grading general formulas  NumericalGrader  for grading numbers  MatrixGrader  for grading formulas with vectors and matrices  SingleListGrader  for grading a delimited (default: comma-separated) list of inputs in a single response box     Multi-input graders  are for grading multiple input boxes at once. They are composed of single-input graders working in concert, handled by the general  ListGrader  class.  ListGrader  is the only multi-input grader included in the library, but is incredibly general.   ListGrader  for grading a list of inputs. Examples:  grade an ordered list of text inputs  grade an unordered list of mathematical expressions  grade a list of eigenvalue-eigenvector pairs     Specialized graders  are used to grade very specific situations. The only specialized grader we presently have is  IntegralGrader , although plugins can be used to construct further examples.   IntegralGrader  for grading the construction of integrals.", 
            "title": "Grading Classes"
        }, 
        {
            "location": "/#questions-bugs-issues-suggestions", 
            "text": "Please contact us by making an issue on  github .", 
            "title": "Questions? Bugs? Issues? Suggestions?"
        }, 
        {
            "location": "/#what-should-i-read-next", 
            "text": "If you haven't already done so, we recommend looking at our  example course  to get an idea of the type of things that the library is capable of.  It's probably a good idea to start by looking at how to  invoke the grading library in edX .  Next, we recommend looking at the  Introduction to Graders  and the overview of  ItemGraders .  After that, choose a grader that you're interested in, look at  source code for examples for that grader , and read up on the relevant documentation.   Enjoy!", 
            "title": "What should I read next?"
        }, 
        {
            "location": "/edx/", 
            "text": "edX Syntax\n # \n\n\nTo create an edX problem using the MITx Grading Library, you need to create a \"Blank Advanced Problem\", which allows you to construct the problem description via XML. The library is used in \ncustomresponse\n problems, which means that there are two parts to setting up the problem: defining the input that the student sees, and defining the grader that will grade the result. Here is an example.\n\n\nproblem\n\n\n\n!-- Define the grader --\n\n\nscript type=\nloncapa/python\n\nfrom mitxgraders import *\ngrader = FormulaGrader(variables=[\nx\n])\n\n/script\n\n\n  \n!-- Ask the question --\n\n  \np\nEnter the derivative of \\(x^2\\).\n/p\n\n\n  \n!-- Define the problem --\n\n  \ncustomresponse cfn=\ngrader\n answer=\n2*x\n\n    \ntextline math=\ntrue\n /\n\n  \n/customresponse\n\n\n  \n!-- Ask another question --\n\n  \np\nEnter the derivative of \\(5x^2\\).\n/p\n\n\n  \n!-- Define the problem. Note that the grader is reused --\n\n  \ncustomresponse cfn=\ngrader\n answer=\n10*x\n\n    \ntextline math=\ntrue\n /\n\n  \n/customresponse\n\n\n\n/problem\n\n\n\n\nNote that the \ncustomresponse\n tag contains the answer that is passed to the grader. You can also use \nexpect=\"2*x\"\n instead of \nanswer=\"2*x\"\n; edX treats these parameters indistinguishably (although we strongly suggest not using both!). Also note that a grader can be used multiple times if desired.\n\n\nUsing an answers key to a grader\n # \n\n\nIf you provide an \nanswers\n key to the grader, it will ignore whatever is specified in the \ncustomresponse\n tag. Here is an example.\n\n\nproblem\n\n\n\nscript type=\nloncapa/python\n\nfrom mitxgraders import *\nmygrader = FormulaGrader(\n    answers={'expect': '2*x', 'msg': 'Good job!'},\n    variables=['x']\n)\n\n/script\n\n\n  \np\nEnter the derivative of \\(x^2\\).\n/p\n\n\n  \ncustomresponse cfn=\nmygrader\n answer=\n2*x\n\n    \ntextline math=\ntrue\n /\n\n  \n/customresponse\n\n\n\n/problem\n\n\n\n\nThe \nanswers\n key is provided to the grader explicitly, and so it ignores whatever is in the \ncustomresponse\n tag. However, the \nanswer\n key in the \ncustomresponse\n tag is still important, because it is what the students see when they click on \"Show Answer\".\n\n\nAlso worth noting is that the grader is stored in a python variable, which in this example, we've called \nmygrader\n (the previous example just called it \ngrader\n). The \ncfn\n key in the \ncustomresponse\n tag needs to tell edX which variable stores the grader you want to use for that problem. If you have multiple \ncustomresponse\n tags, you can provide a different grader to each one.\n\n\nUsing \ncorrect_answer\n for multiple inputs\n # \n\n\nIf you are using multiple inputs (such as when using a \nListGrader\n) or a \nSingleListGrader\n, you must provide the \nanswers\n key to the grader explicitly, as the \nexpect\n or \nanswer\n parameters in the \ncustomresponse\n tag are ignored by both edX and the grader. When using multiple inputs, it's recommended to provide a \ncorrect_answer\n parameter on the \ntextline\n tags, which is what is used to show students the correct answer. Here is an example.\n\n\nproblem\n\n\nscript type=\nloncapa/python\n\nfrom mitxgraders import *\ngrader = ListGrader(\n    answers=['x-2', 'x+2'],\n    subgraders=FormulaGrader(variables=['x'])\n)\n\n/script\n\n\n  \np\nWhat are the linear factors of \\((x^2 - 4)\\)? Enter your answers in any order.\n/p\n\n\n  \n!-- Note there is no 'expect' or 'answer' parameter in the customresponse tag --\n\n  \ncustomresponse cfn=\ngrader\n\n    \n!-- correct_answer is shown to student when they press [Show Answer].\n         Its value is not used for grading purposes --\n\n    \ntextline math=\ntrue\n correct_answer=\nx - 2\n /\n\n    \ntextline math=\ntrue\n correct_answer=\nx + 2\n /\n\n  \n/customresponse\n\n\n\n/problem\n\n\n\n\nNote that the \ncorrect_answer\n parameters are never sent to the grader, which is why you must provide them independently.\n\n\nWhen using lists, such as with a \nListGrader\n or a \nSingleListGrader\n, you only need to provide an \nanswers\n key to the top-level grader (the one that is specified in the \ncfn\n key).\n\n\nPassing a grader directly\n # \n\n\nBecause the \ncfn\n parameter of the \ncustomresponse\n tag is executed as python code, it is possible to provide the definition of the grader in-line, as the following example shows.\n\n\nproblem\n\n\n\n!-- Make sure to remember to import the library! --\n\n\nscript type=\nloncapa/python\n\nfrom mitxgraders import *\n\n/script\n\n\n  \np\nEnter the derivative of \\(x^2\\).\n/p\n\n\n  \ncustomresponse cfn=\nFormulaGrader(variables=['x'])\n answer=\n2*x\n\n    \ntextline math=\ntrue\n /\n\n  \n/customresponse\n\n\n\n/problem\n\n\n\n\nWe want to stress the simplicity of this example compared to implementing the same problem using standard edX problem types! This method of defining a grader is very handy for simple grader constructions such as this one. For more complex graders, we recommend the previous style. One must be careful to make sure that quotation marks \n'\n and \n\"\n do not conflict if using the in-line method.", 
            "title": "edX Syntax"
        }, 
        {
            "location": "/edx/#edx-syntax", 
            "text": "To create an edX problem using the MITx Grading Library, you need to create a \"Blank Advanced Problem\", which allows you to construct the problem description via XML. The library is used in  customresponse  problems, which means that there are two parts to setting up the problem: defining the input that the student sees, and defining the grader that will grade the result. Here is an example.  problem  !-- Define the grader --  script type= loncapa/python \nfrom mitxgraders import *\ngrader = FormulaGrader(variables=[ x ]) /script \n\n   !-- Ask the question -- \n   p Enter the derivative of \\(x^2\\). /p \n\n   !-- Define the problem -- \n   customresponse cfn= grader  answer= 2*x \n     textline math= true  / \n   /customresponse \n\n   !-- Ask another question -- \n   p Enter the derivative of \\(5x^2\\). /p \n\n   !-- Define the problem. Note that the grader is reused -- \n   customresponse cfn= grader  answer= 10*x \n     textline math= true  / \n   /customresponse  /problem  Note that the  customresponse  tag contains the answer that is passed to the grader. You can also use  expect=\"2*x\"  instead of  answer=\"2*x\" ; edX treats these parameters indistinguishably (although we strongly suggest not using both!). Also note that a grader can be used multiple times if desired.", 
            "title": "edX Syntax"
        }, 
        {
            "location": "/edx/#using-an-answers-key-to-a-grader", 
            "text": "If you provide an  answers  key to the grader, it will ignore whatever is specified in the  customresponse  tag. Here is an example.  problem  script type= loncapa/python \nfrom mitxgraders import *\nmygrader = FormulaGrader(\n    answers={'expect': '2*x', 'msg': 'Good job!'},\n    variables=['x']\n) /script \n\n   p Enter the derivative of \\(x^2\\). /p \n\n   customresponse cfn= mygrader  answer= 2*x \n     textline math= true  / \n   /customresponse  /problem  The  answers  key is provided to the grader explicitly, and so it ignores whatever is in the  customresponse  tag. However, the  answer  key in the  customresponse  tag is still important, because it is what the students see when they click on \"Show Answer\".  Also worth noting is that the grader is stored in a python variable, which in this example, we've called  mygrader  (the previous example just called it  grader ). The  cfn  key in the  customresponse  tag needs to tell edX which variable stores the grader you want to use for that problem. If you have multiple  customresponse  tags, you can provide a different grader to each one.", 
            "title": "Using an answers key to a grader"
        }, 
        {
            "location": "/edx/#using-correct_answer-for-multiple-inputs", 
            "text": "If you are using multiple inputs (such as when using a  ListGrader ) or a  SingleListGrader , you must provide the  answers  key to the grader explicitly, as the  expect  or  answer  parameters in the  customresponse  tag are ignored by both edX and the grader. When using multiple inputs, it's recommended to provide a  correct_answer  parameter on the  textline  tags, which is what is used to show students the correct answer. Here is an example.  problem  script type= loncapa/python \nfrom mitxgraders import *\ngrader = ListGrader(\n    answers=['x-2', 'x+2'],\n    subgraders=FormulaGrader(variables=['x'])\n) /script \n\n   p What are the linear factors of \\((x^2 - 4)\\)? Enter your answers in any order. /p \n\n   !-- Note there is no 'expect' or 'answer' parameter in the customresponse tag -- \n   customresponse cfn= grader \n     !-- correct_answer is shown to student when they press [Show Answer].\n         Its value is not used for grading purposes -- \n     textline math= true  correct_answer= x - 2  / \n     textline math= true  correct_answer= x + 2  / \n   /customresponse  /problem  Note that the  correct_answer  parameters are never sent to the grader, which is why you must provide them independently.  When using lists, such as with a  ListGrader  or a  SingleListGrader , you only need to provide an  answers  key to the top-level grader (the one that is specified in the  cfn  key).", 
            "title": "Using correct_answer for multiple inputs"
        }, 
        {
            "location": "/edx/#passing-a-grader-directly", 
            "text": "Because the  cfn  parameter of the  customresponse  tag is executed as python code, it is possible to provide the definition of the grader in-line, as the following example shows.  problem  !-- Make sure to remember to import the library! --  script type= loncapa/python \nfrom mitxgraders import * /script \n\n   p Enter the derivative of \\(x^2\\). /p \n\n   customresponse cfn= FormulaGrader(variables=['x'])  answer= 2*x \n     textline math= true  / \n   /customresponse  /problem  We want to stress the simplicity of this example compared to implementing the same problem using standard edX problem types! This method of defining a grader is very handy for simple grader constructions such as this one. For more complex graders, we recommend the previous style. One must be careful to make sure that quotation marks  '  and  \"  do not conflict if using the in-line method.", 
            "title": "Passing a grader directly"
        }, 
        {
            "location": "/graders/", 
            "text": "Introduction to Graders\n # \n\n\nGraders are implemented as python classes. All grading classes are instantiated by calling them. Options can be provided using keyword arguments as\n\n\ngrader = FakeGradingClass(option_1=value_1, option_2=value2)\n# FakeGradingClass is not real! It's just a placeholder.\n\n\n\n\nor with a configuration dictionary:\n\n\nconfig = {'option_1': value_1, 'option_2': value_2}\ngrader = FakeGradingClass(config)\n\n\n\n\nPassing the configuration as a dictionary can be useful if you are using the same configuration for multiple problems. However, you cannot 'mix and match' these two options: if a configuration dictionary is supplied, any keyword arguments are ignored.\n\n\nMost configuration options are specific to their grading classes. For example, \nFormulaGrader\n has a \nvariables\n configuration key, but \nNumericalGrader\n does not.\n\n\nA few configuration options are available to all grading classes.\n\n\nDebugging\n # \n\n\nEvery grading class has a debug option. By default, \ndebug=False\n. To receive debug information from a given grader, specify \ndebug=True\n. Some graders will provide more debug information than others. Debug information can be used by authors to check to make sure that the graders are behaving as expected, but shouldn't be made available to students.\n\n\ngrader = FakeGradingClass(debug=True)\n\n\n\n\nValidation\n # \n\n\nEvery grading class has a \nsuppress_warnings\n key.\n\n\nThe options passed to a grading class undergo extensive validation and graders will giver error messages if instantiated with invalid options.\n\n\nA few error messages serve only as warnings. For example, if you attempt to configure a \nFormulaGrader\n with \npi\n as a variable, you will receive a warning:\n\n\n from mitxgraders import *\n\n try:\n...     grader = FormulaGrader(variables=['pi'])\n... except ConfigError as error:\n...     print(error)\nWarning: 'variables' contains entries 'pi' which will override default values. If you intend to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.\n\n\n\n\nAs the warning message says, if you really want to override the default value of \npi\n (not recommended!) then you can suppress this warning by setting \nsuppress_warnings=True\n.\n\n\n from mitxgraders import *\n\n grader = FormulaGrader(variables=['pi'], suppress_warnings=True)\n\n\n\n\nAttempt-Based Partial Credit\n # \n\n\nIt is possible to pass a student's attempt number to a grader by explicitly requesting that edX do so in a \ncustomresponse\n tag as follows.\n\n\ncustomresponse cfn=\ngrader\n expect=\nanswer\n cfn_extra_args=\nattempt\n\n\n\n\nOnce this is done, you can enable attempt-based partial credit for your graders. The syntax is as follows.\n\n\ngrader = FakeGradingClass(\n    attempt_based_credit=True,     # default False\n    decrease_credit_after=1,       # default 1\n    minimum_credit=0.2,            # default 0.2\n    decrease_credit_steps=4,       # default 4\n    attempt_based_credit_msg=True  # default True\n)\n\n\n\n\nAttempt-based partial credit is turned on by setting \nattempt_based_credit=True\n. When it is turned on, the first attempt a student makes will be eligible for full credit, while subsequent attempts may have a decreasing maximum score.\n\n\n\n\n\n\nThe maximum score begins to decrease after the attempt specified in \ndecrease_credit_after\n. By default, all attempts after the first will have decreasing credit.\n\n\n\n\n\n\nThe credit decreases linearly to \nminimum_credit\n.\n\n\n\n\n\n\nThe number of attempts the credit decreases for is specified in \ndecrease_credit_steps\n. So, using the defaults, attempts 1, 2, 3, 4, 5, and 6 are eligible for maximum credits of 1, 0.8, 0.6, 0.4, 0.2 and 0.2, respectively.\n\n\n\n\n\n\nIf a student's credit has been decreased from the maximum by attempt-based partial credit, the student can be provided with a message informing them of the maximum possible credit at that attempt number. This is controlled by the \nattempt_based_credit_msg\n setting. We recommend that this setting be left on, as it will likely lead to confusion otherwise.\n\n\n\n\n\n\nWhen using nested graders, these settings need only be applied to the grader that is provided to edX in the \ncfn\n key. These settings can be set on a course-wide basis through the use of \nplugins\n.\n\n\nNote that if attempt-based partial credit is turned on but the \ncfn_extra_args=\"attempt\"\n entry is missing from the \ncustomresponse\n tag, an error message results.\n\n\nOption Listing\n # \n\n\nHere is the full list of options specific to all graders.\n\n\ngrader = AbstractGrader(\n    debug=bool,  # default False\n    wrong_msg=str,  # default ''\n    attempt_based_credit=bool,  # default False\n    decrease_credit_after=int,  # default 1\n    minimum_credit=float,  # default 0.2\n    decrease_credit_steps=int,  # default 4\n    attempt_based_credit_msg=bool,  # default True\n)", 
            "title": "Introduction to Graders"
        }, 
        {
            "location": "/graders/#introduction-to-graders", 
            "text": "Graders are implemented as python classes. All grading classes are instantiated by calling them. Options can be provided using keyword arguments as  grader = FakeGradingClass(option_1=value_1, option_2=value2)\n# FakeGradingClass is not real! It's just a placeholder.  or with a configuration dictionary:  config = {'option_1': value_1, 'option_2': value_2}\ngrader = FakeGradingClass(config)  Passing the configuration as a dictionary can be useful if you are using the same configuration for multiple problems. However, you cannot 'mix and match' these two options: if a configuration dictionary is supplied, any keyword arguments are ignored.  Most configuration options are specific to their grading classes. For example,  FormulaGrader  has a  variables  configuration key, but  NumericalGrader  does not.  A few configuration options are available to all grading classes.", 
            "title": "Introduction to Graders"
        }, 
        {
            "location": "/graders/#debugging", 
            "text": "Every grading class has a debug option. By default,  debug=False . To receive debug information from a given grader, specify  debug=True . Some graders will provide more debug information than others. Debug information can be used by authors to check to make sure that the graders are behaving as expected, but shouldn't be made available to students.  grader = FakeGradingClass(debug=True)", 
            "title": "Debugging"
        }, 
        {
            "location": "/graders/#validation", 
            "text": "Every grading class has a  suppress_warnings  key.  The options passed to a grading class undergo extensive validation and graders will giver error messages if instantiated with invalid options.  A few error messages serve only as warnings. For example, if you attempt to configure a  FormulaGrader  with  pi  as a variable, you will receive a warning:   from mitxgraders import *  try:\n...     grader = FormulaGrader(variables=['pi'])\n... except ConfigError as error:\n...     print(error)\nWarning: 'variables' contains entries 'pi' which will override default values. If you intend to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.  As the warning message says, if you really want to override the default value of  pi  (not recommended!) then you can suppress this warning by setting  suppress_warnings=True .   from mitxgraders import *  grader = FormulaGrader(variables=['pi'], suppress_warnings=True)", 
            "title": "Validation"
        }, 
        {
            "location": "/graders/#attempt-based-partial-credit", 
            "text": "It is possible to pass a student's attempt number to a grader by explicitly requesting that edX do so in a  customresponse  tag as follows.  customresponse cfn= grader  expect= answer  cfn_extra_args= attempt  Once this is done, you can enable attempt-based partial credit for your graders. The syntax is as follows.  grader = FakeGradingClass(\n    attempt_based_credit=True,     # default False\n    decrease_credit_after=1,       # default 1\n    minimum_credit=0.2,            # default 0.2\n    decrease_credit_steps=4,       # default 4\n    attempt_based_credit_msg=True  # default True\n)  Attempt-based partial credit is turned on by setting  attempt_based_credit=True . When it is turned on, the first attempt a student makes will be eligible for full credit, while subsequent attempts may have a decreasing maximum score.    The maximum score begins to decrease after the attempt specified in  decrease_credit_after . By default, all attempts after the first will have decreasing credit.    The credit decreases linearly to  minimum_credit .    The number of attempts the credit decreases for is specified in  decrease_credit_steps . So, using the defaults, attempts 1, 2, 3, 4, 5, and 6 are eligible for maximum credits of 1, 0.8, 0.6, 0.4, 0.2 and 0.2, respectively.    If a student's credit has been decreased from the maximum by attempt-based partial credit, the student can be provided with a message informing them of the maximum possible credit at that attempt number. This is controlled by the  attempt_based_credit_msg  setting. We recommend that this setting be left on, as it will likely lead to confusion otherwise.    When using nested graders, these settings need only be applied to the grader that is provided to edX in the  cfn  key. These settings can be set on a course-wide basis through the use of  plugins .  Note that if attempt-based partial credit is turned on but the  cfn_extra_args=\"attempt\"  entry is missing from the  customresponse  tag, an error message results.", 
            "title": "Attempt-Based Partial Credit"
        }, 
        {
            "location": "/graders/#option-listing", 
            "text": "Here is the full list of options specific to all graders.  grader = AbstractGrader(\n    debug=bool,  # default False\n    wrong_msg=str,  # default ''\n    attempt_based_credit=bool,  # default False\n    decrease_credit_after=int,  # default 1\n    minimum_credit=float,  # default 0.2\n    decrease_credit_steps=int,  # default 4\n    attempt_based_credit_msg=bool,  # default True\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/item_grader/", 
            "text": "ItemGrader\n # \n\n\nWhen an individual input needs to be graded, it is graded by an \nItemGrader\n. All \nItemGrader\ns work by specifying answers and their corresponding points/messages, as well as an optional message for wrong answers. In these examples, we use \nStringGrader\n as an example of how to use a generic \nItemGrader\n. You cannot use a generic \nItemGrader\n by itself.\n\n\n from mitxgraders import *\n\n grader = StringGrader(\n...     answers='cat',\n...     wrong_msg='Try again!'\n... )\n\n\n\n\nThe grader is set up to grade an answer of \ncat\n as correct, and includes a message that is presented to students if they get the answer wrong. One could pass \ngrader\n in as the \ncfn\n key for a \ncustomresponse\n tag. The following code demonstrates what happens when the grader is called using python (for example, inside a python console). Note that this is only for demonstrating the behavior of the grader, and is not required in order to use the library in edX.\n\n\n grader(None, 'cat') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'dog') == {'grade_decimal': 0, 'msg': 'Try again!', 'ok': False}\nTrue\n\n\n\n\nYou will often see this type of demonstration in this documentation. It serves both to demonstrate how the grader works and to ensure that our examples are always syntactically correct, as these code blocks form part of our documentation testing.\n\n\nNote that \ngrader\n accepts two arguments. This is because edX passes two arguments to all graders. The first argument is the \nexpect\n or \nanswer\n value associated with the \ncustomresponse\n tag. Here, we supply \nNone\n, as the grader already has its answer specified. The second argument is the student input. If the \ncustomresponse\n problem has multiple inputs, the second argument is a list of the student inputs.\n\n\nSpecifying Answers\n # \n\n\nFor all \nItemGrader\ns, the \nanswers\n key can be used to specify correct answers, specific feedback messages, and to assign partial credit. It accepts a few formats:\n\n\n\n\n\n\nA single dictionary can be used to specify an answer, feedback, correctness, and partial credit. The dictionary keys are:\n\n\n\n\n'expect'\n (required): compared against student answer. Most \nItemGrader\ns use strings to specify the \n'expect'\n value.\n\n\n'grade_decimal'\n (optional, a number between \n0\n and \n1\n inclusive): The credit associated with this answer (default \n1\n).\n\n\n'msg'\n (optional, string): An optional feedback message associated with this answer (default \n''\n).\n\n\n\n\n\n\n\n\n grader = StringGrader(\n...     answers={'expect': 'zebra', 'grade_decimal': 1, 'msg': 'Yay!'},\n...     wrong_msg='Try again!'\n... )\n\n grader(None, 'zebra') == {'grade_decimal': 1, 'msg': 'Yay!', 'ok': True}\nTrue\n\n grader(None, 'cat') == {'grade_decimal': 0, 'msg': 'Try again!', 'ok': False}\nTrue\n\n\n\n\n\n\nA single \n'expect'\n value: can be used to specify the correct answer. For example,\n\n\n\n\n grader = StringGrader(\n...     answers='zebra',\n...     # Equivalent to:\n...     # answers={'expect': 'zebra', 'msg': '', 'grade_decimal': 1}\n...     wrong_msg='Try again!'\n... )\n\n grader(None, 'zebra') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'cat') == {'grade_decimal': 0, 'msg': 'Try again!', 'ok': False}\nTrue\n\n\n\n\nAgain, most \nItemGrader\ns use strings to store \n'expect'\n values.\n\n\n\n\nA tuple of the afore-mentioned dictionaries/strings, which specifies multiple possible answers:\n\n\n\n\n grader = StringGrader(\n...     answers=(\n...         # the correct answer\n...         'wolf',\n...         # an alternative correct answer\n...         'canis lupus',\n...         # a partially correct answer\n...         {'expect': 'dog', 'grade_decimal': 0.5, 'msg': 'No, not dog!'},\n...         # a wrong answer with specific feedback\n...         {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'No, not unicorn!'}\n...     ),\n...     wrong_msg='Try again!'\n... )\n\n grader(None, 'wolf') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'canis lupus') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'dog') == {'grade_decimal': 0.5, 'msg': 'No, not dog!', 'ok': 'partial'}\nTrue\n\n grader(None, 'unicorn') == {'grade_decimal': 0, 'msg': 'No, not unicorn!', 'ok': False}\nTrue\n\n grader(None, 'cat') == {'grade_decimal': 0, 'msg': 'Try again!', 'ok': False}\nTrue\n\n\n\n\nInternally, the \nItemGrader\n converts the answers entry into a tuple of dictionaries. When grading, it asks the specific grading class to grade the response against each possible answer, and selects the best outcome for the student.\n\n\nThe \nwrong_msg\n is only displayed if the score is zero and there are no other messages.\n\n\nIf no \nanswers\n key is provided, the grader reads from the \nexpect\n or \nanswer\n parameter of the \ncustomresponse\n tag (see \nedX Syntax\n). Note that when using a \nListGrader\n, the \nanswers\n key is required.\n\n\nOption Listing\n # \n\n\nHere is the full list of options specific to \nItemGrader\ns.\n\n\ngrader = ItemGrader(\n    answers=(str, dict, (str, dict)),\n    wrong_msg=str,  # default ''\n)", 
            "title": "ItemGrader"
        }, 
        {
            "location": "/item_grader/#itemgrader", 
            "text": "When an individual input needs to be graded, it is graded by an  ItemGrader . All  ItemGrader s work by specifying answers and their corresponding points/messages, as well as an optional message for wrong answers. In these examples, we use  StringGrader  as an example of how to use a generic  ItemGrader . You cannot use a generic  ItemGrader  by itself.   from mitxgraders import *  grader = StringGrader(\n...     answers='cat',\n...     wrong_msg='Try again!'\n... )  The grader is set up to grade an answer of  cat  as correct, and includes a message that is presented to students if they get the answer wrong. One could pass  grader  in as the  cfn  key for a  customresponse  tag. The following code demonstrates what happens when the grader is called using python (for example, inside a python console). Note that this is only for demonstrating the behavior of the grader, and is not required in order to use the library in edX.   grader(None, 'cat') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  grader(None, 'dog') == {'grade_decimal': 0, 'msg': 'Try again!', 'ok': False}\nTrue  You will often see this type of demonstration in this documentation. It serves both to demonstrate how the grader works and to ensure that our examples are always syntactically correct, as these code blocks form part of our documentation testing.  Note that  grader  accepts two arguments. This is because edX passes two arguments to all graders. The first argument is the  expect  or  answer  value associated with the  customresponse  tag. Here, we supply  None , as the grader already has its answer specified. The second argument is the student input. If the  customresponse  problem has multiple inputs, the second argument is a list of the student inputs.", 
            "title": "ItemGrader"
        }, 
        {
            "location": "/item_grader/#specifying-answers", 
            "text": "For all  ItemGrader s, the  answers  key can be used to specify correct answers, specific feedback messages, and to assign partial credit. It accepts a few formats:    A single dictionary can be used to specify an answer, feedback, correctness, and partial credit. The dictionary keys are:   'expect'  (required): compared against student answer. Most  ItemGrader s use strings to specify the  'expect'  value.  'grade_decimal'  (optional, a number between  0  and  1  inclusive): The credit associated with this answer (default  1 ).  'msg'  (optional, string): An optional feedback message associated with this answer (default  '' ).      grader = StringGrader(\n...     answers={'expect': 'zebra', 'grade_decimal': 1, 'msg': 'Yay!'},\n...     wrong_msg='Try again!'\n... )  grader(None, 'zebra') == {'grade_decimal': 1, 'msg': 'Yay!', 'ok': True}\nTrue  grader(None, 'cat') == {'grade_decimal': 0, 'msg': 'Try again!', 'ok': False}\nTrue   A single  'expect'  value: can be used to specify the correct answer. For example,    grader = StringGrader(\n...     answers='zebra',\n...     # Equivalent to:\n...     # answers={'expect': 'zebra', 'msg': '', 'grade_decimal': 1}\n...     wrong_msg='Try again!'\n... )  grader(None, 'zebra') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  grader(None, 'cat') == {'grade_decimal': 0, 'msg': 'Try again!', 'ok': False}\nTrue  Again, most  ItemGrader s use strings to store  'expect'  values.   A tuple of the afore-mentioned dictionaries/strings, which specifies multiple possible answers:    grader = StringGrader(\n...     answers=(\n...         # the correct answer\n...         'wolf',\n...         # an alternative correct answer\n...         'canis lupus',\n...         # a partially correct answer\n...         {'expect': 'dog', 'grade_decimal': 0.5, 'msg': 'No, not dog!'},\n...         # a wrong answer with specific feedback\n...         {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'No, not unicorn!'}\n...     ),\n...     wrong_msg='Try again!'\n... )  grader(None, 'wolf') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  grader(None, 'canis lupus') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  grader(None, 'dog') == {'grade_decimal': 0.5, 'msg': 'No, not dog!', 'ok': 'partial'}\nTrue  grader(None, 'unicorn') == {'grade_decimal': 0, 'msg': 'No, not unicorn!', 'ok': False}\nTrue  grader(None, 'cat') == {'grade_decimal': 0, 'msg': 'Try again!', 'ok': False}\nTrue  Internally, the  ItemGrader  converts the answers entry into a tuple of dictionaries. When grading, it asks the specific grading class to grade the response against each possible answer, and selects the best outcome for the student.  The  wrong_msg  is only displayed if the score is zero and there are no other messages.  If no  answers  key is provided, the grader reads from the  expect  or  answer  parameter of the  customresponse  tag (see  edX Syntax ). Note that when using a  ListGrader , the  answers  key is required.", 
            "title": "Specifying Answers"
        }, 
        {
            "location": "/item_grader/#option-listing", 
            "text": "Here is the full list of options specific to  ItemGrader s.  grader = ItemGrader(\n    answers=(str, dict, (str, dict)),\n    wrong_msg=str,  # default ''\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/string_grader/", 
            "text": "StringGrader\n # \n\n\nThe \nStringGrader\n class is an \nItemGrader\n that grades text inputs. It can perform comparisons to expected answers or patterns, and can also accept arbitrary input. It is the simplest grading class, both in code and in usage.\n\n\nTo use a \nStringGrader\n in its simplest form, simply pass in the set of answers you want to grade, as described in the \nItemGrader documentation\n.\n\n\n from mitxgraders import *\n\n grader = StringGrader(\n...     answers='cat'\n... )\n\n grader(None, 'cat') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'CAT') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue\n\n grader(None, 'Cat') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue\n\n\n\n\nThis example will accept the answer of \ncat\n, but not \nCAT\n or \nCat\n, as grading is case-sensitive by default.\n\n\nCleaning Input\n # \n\n\nLeading or trailing spaces in an answer rarely change the meaning of the answer. Hence, by default, we strip all leading and trailing spaces from the student input and author-specified answers before comparison. If you want to keep those spaces around for the comparison, you need to disable strip.\n\n\n grader = StringGrader(\n...     answers='cat',\n...     strip=False\n... )\n\n grader(None, 'cat') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n grader(None, ' cat') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue\n\n\n\n\nThis will accept \ncat\n, but will reject answers with leading or trailing spaces. By default, \nstrip=True\n.\n\n\nSimilarly, if a student uses two (or more) spaces instead of one, that rarely changes the meaning. By default, we convert consecutive spaces into a single space before comparison (this applies to both the instructor-provided answer and the student-provided response). If you want to disable this behavior, you can set \nclean_spaces=False\n as follows.\n\n\n grader = StringGrader(\n...     answers='two  spaces',\n...     clean_spaces=False\n... )\n\n grader(None, 'two  spaces') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'two spaces') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue\n\n\n\n\nHere, the answer is \ntwo  spaces\n, complete with two spaces (which may not render on a webpage). A student's answer of \ntwo spaces\n (with a single space) would be graded incorrect.\n\n\nFinally, you may have a situation where spaces are completely irrelevant (e.g., when grading a mathematical expression). To instruct the grader to completely ignore all spaces, set \nstrip_all=True\n.\n\n\n grader = StringGrader(\n...     answers='(12)(34)',\n...     strip_all=True\n... )\n\n grader(None, '(1 2) (3 4)') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n\n\n\nThis grader will accept \n(1 2) (3 4)\n, ignoring all spaces in the provided answer.\n\n\nCase Sensitive\n # \n\n\nTo perform case-insensitive grading, pass in the appropriate flag as follows.\n\n\n grader = StringGrader(\n...     answers='Cat',\n...     case_sensitive=False\n... )\n\n grader(None, 'Cat') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'cat') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'CAT') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n\n\n\nThis will accept \nCat\n, \ncat\n and \nCAT\n. By default, \ncase_sensitive=True\n.\n\n\nAccepting Anything\n # \n\n\nSometimes you may just want to accept anything that a student provides (possibly subject to conditions). This can be useful, for example, when asking for a free response to a prompt, and can be used in conjunction with validation (see below) to accept a variety of answers that satisfy a given pattern. To do this, set the \naccept_any\n flag, which will cause the grader to literally accept anything that is entered into the textbox.\n\n\n grader = StringGrader(\n...     answers={'expect': '', 'grade_decimal': 1, 'msg': 'Your answer has been recorded.'},\n...     accept_any=True\n... )\n\n grader(None, 'cat') == {'grade_decimal': 1, 'msg': 'Your answer has been recorded.', 'ok': True}\nTrue\n\n grader(None, 'dog') == {'grade_decimal': 1, 'msg': 'Your answer has been recorded.', 'ok': True}\nTrue\n\n grader(None, '') == {'grade_decimal': 1, 'msg': 'Your answer has been recorded.', 'ok': True}\nTrue\n\n\n\n\nNote that this will even accept a blank (empty) response. To reject empty responses, you can instead use the \naccept_nonempty\n flag, which requires at least one character to be submitted (after input cleaning).\n\n\n grader = StringGrader(\n...     answers={'expect': '', 'grade_decimal': 1, 'msg': 'Your answer has been recorded.'},\n...     accept_nonempty=True,\n...     explain_minimums=None\n... )\n\n grader(None, 'dog') == {'grade_decimal': 1,\n...                         'msg': 'Your answer has been recorded.',\n...                         'ok': True}\nTrue\n\n grader(None, '') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue\n\n\n\n\nNote that when either \naccept_any\n or \naccept_nonempty\n are set to True, you do not need to provide any answer to check against.\n\n\nYou may want students to have to write a certain amount of characters or words in order to get credit. Two flags are available to facilitate this: \nmin_length\n and \nmin_words\n, which set a minimum number of characters and words to be awarded credit, respectively (both default to zero). You can use both of these options together if desired.\n\n\n grader = StringGrader(\n...     answers={'expect': '', 'grade_decimal': 1, 'msg': 'Your answer has been recorded.'},\n...     accept_any=True,\n...     min_length=10,  # Require at least 10 characters (after cleaning input)\n...     min_words=3,    # Require at least 3 words\n...     explain_minimums='msg'\n... )\n\n grader(None, 'This is a long answer') == {'grade_decimal': 1,\n...                                           'msg': 'Your answer has been recorded.',\n...                                           'ok': True}\nTrue\n\n grader(None, 'too short') == {'grade_decimal': 0,\n...                               'msg': 'Your response is too short (2/3 words)',\n...                               'ok': False}\nTrue\n\n grader(None, '  a  b  c  d  ') == {'grade_decimal': 0,\n...                                    'msg': 'Your response is too short (7/10 characters)',\n...                                    'ok': False}\nTrue\n\n\n\n\nNote that punctuation doesn't break a word for the purpose of word counting, so \nisn't word-counting fun?\n will only count as three words. If \naccept_nonempty\n and \nmin_length\n are both used, the longer requirement is the one that is used.\n\n\nWhen a student's answer is rejected because it doesn't meet the minimum requirements, there are three types of feedback that you can provide, controlled by the \nexplain_minimums\n flag:\n\n\n\n\nThe student receives an error message describing how many words/characters they have, compared to how many are required. This does not consume an attempt (\nexplain_minimums='err'\n, default).\n\n\nThe student is graded incorrect, but a message is provided describing how many words/characters they have, compared to how many are required. This consumes an attempt (\nexplain_minimums='msg'\n).\n\n\nThe student is graded incorrect, and no explanation is given. This consumes an attempt (\nexplain_minimums=None\n).\n\n\n\n\nThe settings \nmin_length\n, \nmin_words\n and \nexplain_minimums\n are all ignored if not using \naccept_any\n or \naccept_nonempty\n.\n\n\nValidating Input\n # \n\n\nSometimes, you may want to validate student input against a pattern. This can be useful if the student response simply needs to follow a given pattern, or if you want to reject student responses that don't conform to the required format. Validation can be used both when comparing against an expected response, or when using \naccept_any\n (and variants).\n\n\nValidation is performed by constructing a python regular expressions (regex) pattern, stored in the \nvalidation_pattern\n flag (if you are unfamiliar with regular expressions, there are many excellent tutorials available online to get you started!). After input cleaning, the student input is checked against the pattern for a match. If no match is found, the desired response is returned. Expected answers are also checked against the pattern; if a possible answer does not conform to the pattern, then a configuration error results.\n\n\nWhen a response doesn't satisfy the given pattern, there are three types of feedback that you can provide, controlled by the \nexplain_validation\n flag:\n\n\n\n\nThe student receives an error message. This does not consume an attempt (\nexplain_validation='err'\n, default).\n\n\nThe student is graded incorrect, but receives a message. This consumes an attempt (\nexplain_validation='msg'\n).\n\n\nThe student is graded incorrect, and no explanation is given. This consumes an attempt (\nexplain_validation=None\n).\n\n\n\n\nIn the first two cases, the message provided is given by the \ninvalid_msg\n setting, which defaults to \nYour input is not in the expected format\n.\n\n\nHere is an example of using a validation pattern to accept inputs that look like chemical formulae for organic molecules. Note that anything that matches the pattern will be graded correct.\n\n\n grader = StringGrader(\n...     validation_pattern=r'([CNOH](_[0-9])?)+',\n...     explain_validation='msg',\n...     invalid_msg='Write a chemical formula containing hydrogen, oxygen, carbon and/or nitrogen',\n...     strip_all=True,   # Removes all spaces from the input\n...     accept_any=True\n... )\n\n grader(None, 'NH_3') == {'grade_decimal': 1,\n...                          'msg': '',\n...                          'ok': True}\nTrue\n\n grader(None, 'KCl') == {'grade_decimal': 0,\n...                          'msg': 'Write a chemical formula containing hydrogen, oxygen, carbon and/or nitrogen',\n...                          'ok': False}\nTrue\n\n\n\n\nBelow, we use validation to ensure that the student input matches the desired format before comparing to the answer, and give the student an error message if their input doesn't match the specification.\n\n\n grader = StringGrader(\n...     answers='(1)(2)',\n...     validation_pattern=r'\\([0-9]\\)\\([0-9]\\)',\n...     explain_validation='err',\n...     strip_all=True   # Removes all spaces from the input\n... )\n\n grader(None, '(1)(2)') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n grader(None, '(2)(1)') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue\n\n try:\n...     grader(None, '(a)(2)')\n... except InvalidInput as error:\n...     print(error)\nYour input is not in the expected format\n\n try:\n...     grader(None, '[1)(2)')\n... except InvalidInput as error:\n...     print(error)\nYour input is not in the expected format\n\n\n\n\nOption Listing\n # \n\n\nHere is the full list of options specific to a \nStringGrader\n.\n\n\ngrader = StringGrader(\n    case_sensitive=bool,  # default True\n    strip=bool,  # default True\n    clean_spaces=bool,  # default True\n    strip_all=bool,  # default False\n    accept_any=bool,  # default False\n    accept_nonempty=bool,  # default False\n    min_words=int \n= 0,  # default 0\n    min_length=int \n= 0,  # default 0\n    explain_minimums=('err', 'msg', None),  # default 'err'\n    validation_pattern=str,  # default None\n    explain_validation=('err', 'msg', None),  # default 'err'\n    invalid_msg=str,  # default 'Your input is not in the expected format'\n)", 
            "title": "StringGrader"
        }, 
        {
            "location": "/string_grader/#stringgrader", 
            "text": "The  StringGrader  class is an  ItemGrader  that grades text inputs. It can perform comparisons to expected answers or patterns, and can also accept arbitrary input. It is the simplest grading class, both in code and in usage.  To use a  StringGrader  in its simplest form, simply pass in the set of answers you want to grade, as described in the  ItemGrader documentation .   from mitxgraders import *  grader = StringGrader(\n...     answers='cat'\n... )  grader(None, 'cat') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  grader(None, 'CAT') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue  grader(None, 'Cat') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue  This example will accept the answer of  cat , but not  CAT  or  Cat , as grading is case-sensitive by default.", 
            "title": "StringGrader"
        }, 
        {
            "location": "/string_grader/#cleaning-input", 
            "text": "Leading or trailing spaces in an answer rarely change the meaning of the answer. Hence, by default, we strip all leading and trailing spaces from the student input and author-specified answers before comparison. If you want to keep those spaces around for the comparison, you need to disable strip.   grader = StringGrader(\n...     answers='cat',\n...     strip=False\n... )  grader(None, 'cat') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  grader(None, ' cat') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue  This will accept  cat , but will reject answers with leading or trailing spaces. By default,  strip=True .  Similarly, if a student uses two (or more) spaces instead of one, that rarely changes the meaning. By default, we convert consecutive spaces into a single space before comparison (this applies to both the instructor-provided answer and the student-provided response). If you want to disable this behavior, you can set  clean_spaces=False  as follows.   grader = StringGrader(\n...     answers='two  spaces',\n...     clean_spaces=False\n... )  grader(None, 'two  spaces') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  grader(None, 'two spaces') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue  Here, the answer is  two  spaces , complete with two spaces (which may not render on a webpage). A student's answer of  two spaces  (with a single space) would be graded incorrect.  Finally, you may have a situation where spaces are completely irrelevant (e.g., when grading a mathematical expression). To instruct the grader to completely ignore all spaces, set  strip_all=True .   grader = StringGrader(\n...     answers='(12)(34)',\n...     strip_all=True\n... )  grader(None, '(1 2) (3 4)') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  This grader will accept  (1 2) (3 4) , ignoring all spaces in the provided answer.", 
            "title": "Cleaning Input"
        }, 
        {
            "location": "/string_grader/#case-sensitive", 
            "text": "To perform case-insensitive grading, pass in the appropriate flag as follows.   grader = StringGrader(\n...     answers='Cat',\n...     case_sensitive=False\n... )  grader(None, 'Cat') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  grader(None, 'cat') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  grader(None, 'CAT') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  This will accept  Cat ,  cat  and  CAT . By default,  case_sensitive=True .", 
            "title": "Case Sensitive"
        }, 
        {
            "location": "/string_grader/#accepting-anything", 
            "text": "Sometimes you may just want to accept anything that a student provides (possibly subject to conditions). This can be useful, for example, when asking for a free response to a prompt, and can be used in conjunction with validation (see below) to accept a variety of answers that satisfy a given pattern. To do this, set the  accept_any  flag, which will cause the grader to literally accept anything that is entered into the textbox.   grader = StringGrader(\n...     answers={'expect': '', 'grade_decimal': 1, 'msg': 'Your answer has been recorded.'},\n...     accept_any=True\n... )  grader(None, 'cat') == {'grade_decimal': 1, 'msg': 'Your answer has been recorded.', 'ok': True}\nTrue  grader(None, 'dog') == {'grade_decimal': 1, 'msg': 'Your answer has been recorded.', 'ok': True}\nTrue  grader(None, '') == {'grade_decimal': 1, 'msg': 'Your answer has been recorded.', 'ok': True}\nTrue  Note that this will even accept a blank (empty) response. To reject empty responses, you can instead use the  accept_nonempty  flag, which requires at least one character to be submitted (after input cleaning).   grader = StringGrader(\n...     answers={'expect': '', 'grade_decimal': 1, 'msg': 'Your answer has been recorded.'},\n...     accept_nonempty=True,\n...     explain_minimums=None\n... )  grader(None, 'dog') == {'grade_decimal': 1,\n...                         'msg': 'Your answer has been recorded.',\n...                         'ok': True}\nTrue  grader(None, '') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue  Note that when either  accept_any  or  accept_nonempty  are set to True, you do not need to provide any answer to check against.  You may want students to have to write a certain amount of characters or words in order to get credit. Two flags are available to facilitate this:  min_length  and  min_words , which set a minimum number of characters and words to be awarded credit, respectively (both default to zero). You can use both of these options together if desired.   grader = StringGrader(\n...     answers={'expect': '', 'grade_decimal': 1, 'msg': 'Your answer has been recorded.'},\n...     accept_any=True,\n...     min_length=10,  # Require at least 10 characters (after cleaning input)\n...     min_words=3,    # Require at least 3 words\n...     explain_minimums='msg'\n... )  grader(None, 'This is a long answer') == {'grade_decimal': 1,\n...                                           'msg': 'Your answer has been recorded.',\n...                                           'ok': True}\nTrue  grader(None, 'too short') == {'grade_decimal': 0,\n...                               'msg': 'Your response is too short (2/3 words)',\n...                               'ok': False}\nTrue  grader(None, '  a  b  c  d  ') == {'grade_decimal': 0,\n...                                    'msg': 'Your response is too short (7/10 characters)',\n...                                    'ok': False}\nTrue  Note that punctuation doesn't break a word for the purpose of word counting, so  isn't word-counting fun?  will only count as three words. If  accept_nonempty  and  min_length  are both used, the longer requirement is the one that is used.  When a student's answer is rejected because it doesn't meet the minimum requirements, there are three types of feedback that you can provide, controlled by the  explain_minimums  flag:   The student receives an error message describing how many words/characters they have, compared to how many are required. This does not consume an attempt ( explain_minimums='err' , default).  The student is graded incorrect, but a message is provided describing how many words/characters they have, compared to how many are required. This consumes an attempt ( explain_minimums='msg' ).  The student is graded incorrect, and no explanation is given. This consumes an attempt ( explain_minimums=None ).   The settings  min_length ,  min_words  and  explain_minimums  are all ignored if not using  accept_any  or  accept_nonempty .", 
            "title": "Accepting Anything"
        }, 
        {
            "location": "/string_grader/#validating-input", 
            "text": "Sometimes, you may want to validate student input against a pattern. This can be useful if the student response simply needs to follow a given pattern, or if you want to reject student responses that don't conform to the required format. Validation can be used both when comparing against an expected response, or when using  accept_any  (and variants).  Validation is performed by constructing a python regular expressions (regex) pattern, stored in the  validation_pattern  flag (if you are unfamiliar with regular expressions, there are many excellent tutorials available online to get you started!). After input cleaning, the student input is checked against the pattern for a match. If no match is found, the desired response is returned. Expected answers are also checked against the pattern; if a possible answer does not conform to the pattern, then a configuration error results.  When a response doesn't satisfy the given pattern, there are three types of feedback that you can provide, controlled by the  explain_validation  flag:   The student receives an error message. This does not consume an attempt ( explain_validation='err' , default).  The student is graded incorrect, but receives a message. This consumes an attempt ( explain_validation='msg' ).  The student is graded incorrect, and no explanation is given. This consumes an attempt ( explain_validation=None ).   In the first two cases, the message provided is given by the  invalid_msg  setting, which defaults to  Your input is not in the expected format .  Here is an example of using a validation pattern to accept inputs that look like chemical formulae for organic molecules. Note that anything that matches the pattern will be graded correct.   grader = StringGrader(\n...     validation_pattern=r'([CNOH](_[0-9])?)+',\n...     explain_validation='msg',\n...     invalid_msg='Write a chemical formula containing hydrogen, oxygen, carbon and/or nitrogen',\n...     strip_all=True,   # Removes all spaces from the input\n...     accept_any=True\n... )  grader(None, 'NH_3') == {'grade_decimal': 1,\n...                          'msg': '',\n...                          'ok': True}\nTrue  grader(None, 'KCl') == {'grade_decimal': 0,\n...                          'msg': 'Write a chemical formula containing hydrogen, oxygen, carbon and/or nitrogen',\n...                          'ok': False}\nTrue  Below, we use validation to ensure that the student input matches the desired format before comparing to the answer, and give the student an error message if their input doesn't match the specification.   grader = StringGrader(\n...     answers='(1)(2)',\n...     validation_pattern=r'\\([0-9]\\)\\([0-9]\\)',\n...     explain_validation='err',\n...     strip_all=True   # Removes all spaces from the input\n... )  grader(None, '(1)(2)') == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  grader(None, '(2)(1)') == {'grade_decimal': 0, 'msg': '', 'ok': False}\nTrue  try:\n...     grader(None, '(a)(2)')\n... except InvalidInput as error:\n...     print(error)\nYour input is not in the expected format  try:\n...     grader(None, '[1)(2)')\n... except InvalidInput as error:\n...     print(error)\nYour input is not in the expected format", 
            "title": "Validating Input"
        }, 
        {
            "location": "/string_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  StringGrader .  grader = StringGrader(\n    case_sensitive=bool,  # default True\n    strip=bool,  # default True\n    clean_spaces=bool,  # default True\n    strip_all=bool,  # default False\n    accept_any=bool,  # default False\n    accept_nonempty=bool,  # default False\n    min_words=int  = 0,  # default 0\n    min_length=int  = 0,  # default 0\n    explain_minimums=('err', 'msg', None),  # default 'err'\n    validation_pattern=str,  # default None\n    explain_validation=('err', 'msg', None),  # default 'err'\n    invalid_msg=str,  # default 'Your input is not in the expected format'\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/grading_math/formula_grader/", 
            "text": "FormulaGrader\n # \n\n\nFormulaGrader\n is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's \nformularesponse /\n tag, but with much more versatility.\n\n\n\n\nNote\n\n\n\n\nAll expressions are treated in a case sensitive manner. This means that variables \nm\n and \nM\n are distinct. Case-insensitive \nFormulaGrader\ns were deprecated in \nVersion 1.1.0\n\n\nAll whitespace is stripped from formulas that are entered. So, \n1 + x ^ 2\n is equivalent to \n1+x^2\n.\n\n\n\n\n\n\nVariables and Sampling\n # \n\n\nFormulaGrader\n grades a formula by numerical sampling. That is, random values are assigned to each of the unknown variables and unknown functions, and the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct.\n\n\nVariables are configured by including a list of strings of each variable name as follows.\n\n\n from mitxgraders import *\n\n grader = FormulaGrader(\n...     answers='1+x^2+y',\n...     variables=['x', 'y']\n... )\n\n\n\n\nNote that the \nanswers\n parameter follows all of the usual allowances from \nItemGrader\n.\n\n\nThe variables need to have numbers randomly assigned to them. Each is sampled from a \nsampling set\n, which is \nRealInterval()\n by default (random numbers between 1 and 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the \nsample_from\n key.\n\n\n grader = FormulaGrader(\n...     answers='1+x^2+y+z/2',\n...     variables=['x', 'y', 'z'],\n...     sample_from={\n...         'x': ComplexRectangle(),\n...         'y': [2, 6],\n...         'z': (1, 3, 4, 8)\n...     }\n... )\n\n\n\n\nThe \nsample_from\n key must be a dictionary of \n'variable_name': sampling_set\n pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.\n\n\nVariable Names\n # \n\n\nVariable names are case-sensitive. They must start with a letter, and can be proceded by any combination of letters and numbers. There are two ways to write subscripts and superscripts:\n\n\n\n\nOld edX style: \nvar_123\n (we also allow the use of multiple underscores for backwards compatability with edX, although it is not recommended that this be used)\n\n\nTensor style: \nvar_{123}\n, \nvar_{123}^{456}\n (subscript first), or \nvar^{456}\n\n\n\n\nSub/superscripts can contain any combination of letters and numbers. Tensor style sub/superscripts are allowed to start with a \n-\n sign.\n\n\nAll types of variable names are allowed to end with an arbitrary number of primes \n'\n (apostrophes, useful to indicate differentiation or different reference frames). Students on tablets may need to disable \"smart quotes\" to enter this character.\n\n\nThe AsciiMath renderer used in \ntextline\n entries in edX has a number of special symbols that can help make variable names look like particular mathematical entries. A handful of these are \nhatx\n, \nvecx\n, \ntildex\n, \nbarx\n, \ndotx\n and \nddotx\n. There are also a handful of other reserved names in AsciiMath; we recommend testing your variables to ensure that they render as expected.\n\n\nNumbered Variables\n # \n\n\nYou can also specify special variables that are numbered. For example, if you specify that \na\n is a numbered variable, students can include \na_{0}\n, \na_{5}\n, \na_{-2}\n, etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name.\n\n\n grader = FormulaGrader(\n...     answers='a_{0} + a_{1}*x + 1/2*a_{2}*x^2',\n...     variables=['x'],\n...     numbered_vars=['a'],\n...     sample_from={\n...         'x': [-5, 5],\n...         'a': [-10, 10]\n...     }\n... )\n\n\n\n\nIf you have a variable name that would clash with a numbered variable (say, you defined \na_{0}\n and also a numbered variable \na\n), then the specific variable has precedence.\n\n\nSamples and Failable Evaluations\n # \n\n\nTo control the number of samples that are checked to ensure correctness, you can modify the \nsamples\n key.\n\n\n grader = FormulaGrader(\n...     answers='1+x^2',\n...     variables=['x'],\n...     samples=10\n... )\n\n\n\n\nThe default for \nsamples\n is 5.\n\n\nYou may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set \nfailable_evals\n. This should be used very sparingly!\n\n\n grader = FormulaGrader(\n...     answers='1+x^2',\n...     variables=['x'],\n...     samples=10,\n...     failable_evals=1\n... )\n\n\n\n\nConstants\n # \n\n\nBy default, four constants are defined: \ne\n, \npi\n, and \ni=j=sqrt(-1)\n. You can define new constants by passing in a dictionary to \nuser_constants\n as follows.\n\n\n grader = FormulaGrader(\n...     answers='1/sqrt(1-v^2/c^2)',\n...     variables=['v'],\n...     user_constants={\n...         'c': 3e8\n...     }\n... )\n\n\n\n\nConstants are treated as variables that only ever have one value.\n\n\nFunctions\n # \n\n\nBy default, a large array of mathematical functions are available for use. See the full list \nhere\n. Note that all functions are capable of handling complex expressions unless otherwise stated. In the following example, \nz*z\n is recognized to be different from \nabs(z)^2\n.\n\n\n grader = FormulaGrader(\n...     answers='abs(z)^2',\n...     variables=['z'],\n...     sample_from={\n...         'z': ComplexRectangle()\n...     }\n... )\n\n grader(None, 'z*z')['ok']\nFalse\n\n grader(None, 'z*conj(z)')['ok']\nTrue\n\n\n\n\nUser Functions\n # \n\n\nYou can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the \nuser_functions\n key as follows.\n\n\n grader = FormulaGrader(\n...     answers='x*x',\n...     variables=['x'],\n...     user_functions={'f': lambda x: x*x}\n... )\n\n\n\n\nThis defines a function \nf(x) = x^2\n that students may use. User-defined function names must start with a letter, and can use numbers and underscores, such as \nmy_func2\n. They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg, \nf''\n. Be careful about using quotation marks appropriately when using primes in function names, as in the following example.\n\n\n grader = FormulaGrader(\n...     answers=\nf''(x)\n,\n...     variables=['x'],\n...     user_functions={\nf''\n: lambda x: x*x}\n... )\n\n\n\n\nChoosing a Function Randomly\n # \n\n\nYou can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows.\n\n\n import numpy as np\n\n grader = FormulaGrader(\n...     answers=\nf(x)\n,\n...     variables=['x'],\n...     user_functions={\nf\n: [np.sin, np.cos]}\n... )\n\n\n\n\nEach time this formula is checked, the function \nf\n will be sampled from the list of available functions.\n\n\nYou can also specify a random well-behaved function by using the \nRandomFunction()\n sampling set.\n\n\n grader = FormulaGrader(\n...     answers=\nf''(x) + omega^2*f(x)\n,\n...     variables=['x', 'omega'],\n...     user_functions={\n...         \nf\n: RandomFunction(),\n...         \nf''\n: RandomFunction()\n...     }\n... )\n\n\n\n\nThis allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example. See \nSampling\n for further options associated with \nRandomFunction\n.\n\n\nOverriding Default Functions and Constants\n # \n\n\nYou can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with \nsuppress_warnings=True\n. The following grader raises this warning when constructed:\n\n\n try:\n...     grader = FormulaGrader(\n...         answers='x^2',\n...         variables=['x'],\n...         user_functions={'sin': lambda x: x*x},\n...     )\n... except ConfigError as error:\n...     print(error)\nWarning: 'user_functions' contains entries 'sin' which will override default values. If you intend to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.\n\n\n\n\nThe error can be suppressed by setting \nsuppress_warnings=True\n.\n\n\n grader = FormulaGrader(\n...     answers='x^2',\n...     variables=['x'],\n...     user_functions={'sin': lambda x: x*x},\n...     suppress_warnings=True\n... )\n\n\n\n\nRestricting Student Input\n # \n\n\nFor some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand \nsin(2*theta)\n, then you don't want students to be able to just write \nsin(2*theta)\n and be graded correct.\n\n\nFormulaGrader\n offers a number of ways to restrict what sort of answers will be marked correct.\n\n\nInstructor Variables\n # \n\n\nIn some situations, you need an extra variable to help define the problem in some way, particularly when using \nDependentSampler\n. Alternatively, you may want to remove a default constant such as \ne\n, \ni\n, \nj\n or \npi\n from the problem. Both of these situations can be addressed by specifying particular variables to be instructor variables, as in the following.\n\n\n grader = FormulaGrader(\n...     answers='s/c',\n...     variables=['s', 'c', 'phi'],\n...     sample_from={\n...         's': DependentSampler(depends=['phi'], formula='sin(phi)'),\n...         'c': DependentSampler(depends=['phi'], formula='cos(phi)')\n...     },\n...     instructor_vars=['phi']\n... )\n\n\n\n\nHere, students can use \ns\n and \nc\n, but not \nphi\n in their answer. The \ninstructor_vars\n key accepts a list of the variables/constants you wish to make unavailable to students.\n\n\nForbidden Strings\n # \n\n\nYou can forbid students from entering certain strings using the \nforbidden_strings\n key:\n\n\n grader = FormulaGrader(\n...     answers='2*sin(theta)*cos(theta)',\n...     variables=['theta'],\n...     forbidden_strings=['*theta', 'theta*', 'theta/', '+theta', 'theta+', '-theta', 'theta-'],\n...     forbidden_message=\nYour answer should only use trigonometric functions acting on theta, not multiples of theta\n\n... )\n\n\n\n\nIf a student tries to use one of these strings, then they receive the \nforbidden_message\n, without giving away what the forbidden string is. We recommend using this sparingly, as students may find it confusing. The default \nforbidden_message\n is \"Invalid Input: This particular answer is forbidden\".\n\n\nForbidden strings and student answers are stripped of whitespace before being compared. Thus, if \nx + y\n is forbidden, then answers containing \nx+y\n or \nx   +   y\n will be rejected.\n\n\nBlacklists and Whitelists\n # \n\n\nYou can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example, \nsin\n is disallowed in correct answers.\n\n\n grader = FormulaGrader(\n...     answers='sqrt(1 - cos(x)^2)',\n...     variables=['x'],\n...     sample_from={'x': [0, np.pi]},\n...     blacklist=['sin']\n... )\n\n\n\n\nIf you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are \nsin\n and \ncos\n.\n\n\n grader = FormulaGrader(\n...     answers='sin(x)/cos(x)',\n...     variables=['x'],\n...     whitelist=['sin', 'cos']\n... )\n\n\n\n\nIf you want to exclude all functions, use \nwhitelist=[None]\n:\n\n\n grader = FormulaGrader(\n...     answers='pi/2-x',\n...     variables=['x'],\n...     whitelist=[None]  # no functions are allowed\n... )\n\n\n\n\nYou cannot use a whitelist and a blacklist at the same time.\n\n\nRequired Functions\n # \n\n\nYou can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required.\n\n\n grader = FormulaGrader(\n...     answers='2*sin(theta)*cos(theta)',\n...     variables=['theta'],\n...     required_functions=['sin', 'cos']\n... )\n\n\n\n\nTolerance\n # \n\n\nStudent inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg, \n0.1\n) or a percentage (eg, \n'0.01%'\n, which is the default tolerance). Tolerances must be nonnegative numbers or percentages.\n\n\n grader = FormulaGrader(\n...     answers='2*sin(theta)*cos(theta)',\n...     variables=['theta'],\n...     tolerance=0.00001\n... )\n\n\n\n\nTolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers.\n\n\nNote that if the answer is exactly \n0\n (or can be sampled to be exactly \n0\n, such as when using integer sampling), percentage tolerances don't work (as any percentage of zero is still zero). This means that the student-supplied answer must also evaluate to exactly zero to be graded correctly. Note that answers like \ncos(pi/2)\n evaluate to approximately \n10^(-16)\n due to numerical roundoff error. If you want such answers to be graded correctly, make sure to use an absolute tolerance instead of a relative tolerance on such questions.\n\n\nSuffixes\n # \n\n\nNumbers with a \n%\n at the end will be treated as percentages, and converted to the appropriate decimals. If you desire, you can also enable the use of metric suffixes by setting the appropriate setting as follows.\n\n\n grader = FormulaGrader(\n...     answers='2m*a',  # Equivalent to '0.002*a'\n...     variables=['a'],\n...     metric_suffixes=True\n... )\n\n\n\n\nThe included suffixes are:\n\n\n\n\nk\n: 1e3\n\n\nM\n: 1e6\n\n\nG\n: 1e9\n\n\nT\n: 1e12\n\n\nm\n: 1e-3\n\n\nu\n: 1e-6\n\n\nn\n: 1e-9\n\n\np\n: 1e-12\n\n\n\n\nWe strongly recommend \nnot\n combining these suffixes with the variables names \nk\n, \nM\n, \nG\n, \nT\n, \nm\n, \nu\n, \nn\n or \np\n, as \n2m\n and \n2*m\n will then represent two very different things, which can lead to much student confusion.\n\n\nSibling Variables\n # \n\n\nWhen a student submits several mathematical expressions as part of one problem, it is sometimes useful to grade these inputs in comparison to each other. This can be done using \nsibling variables\n, which are available when \nFormulaGrader\n is used as a subgrader in \nordered\n \nListGrader\n problems.\n\n\nFor example:\n\n\n grader = ListGrader(\n...     answers=[\n...         ('x', '2*x','3*x'),     # first input can be any of these 3 answers\n...         'sibling_1^2',          # second input must be first input squared\n...         'sibling_2^2'           # third input must be second input squared\n...     ],\n...     ordered=True,\n...     subgraders=FormulaGrader(variables=['x'])\n... )\n\n\n\n\nNote that in this example, the sequence of inputs \n['2*x', 4*x^2, 16*x^4]\n is correct, and so is \n['3*x', 9*x^2, 81*x^4]\n, but \n['3*x', 4*x^2, 16*x^4]\n receives only two-thirds credit (from the first entry matching a given answer, and the last entry being the square of the second entry).\n\n\n student_inputs = ['2*x','4*x^2', '16*x^4']\n\n result1, result2, result3 = grader(None, student_inputs)['input_list']\n\n result1['ok'], result2['ok'], result3['ok']\n(True, True, True)\n\n\n student_inputs = ['3*x','9*x^2', '81*x^4']\n\n result1, result2, result3 = grader(None, student_inputs)['input_list']\n\n result1['ok'], result2['ok'], result3['ok']\n(True, True, True)\n\n\n student_inputs = ['3*x','4*x^2', '16*x^4']\n\n result1, result2, result3 = grader(None, student_inputs)['input_list']\n\n result1['ok'], result2['ok'], result3['ok']\n(True, False, True)\n\n\n\n\nNotes:\n\n\n\n\nSibling variables are available to \nFormulaGrader\n, \nNumericalGrader\n, and \nMatrixGrader\n, but only in \nordered\n \nListGrader\n problems.\n\n\nThe jth student input is referenced as \nsibling_j\n. (Exception: If nesting \nListGraders\n with grouping, \nsibling_j\n refers to the jth member of any particular group.)\n\n\nStudents are not able to use \nsibling_j\n in any of their answers.\n\n\n\n\nComparer Functions\n # \n\n\nComparer functions allow you to compare the student input to the author's expectation using aspects other than equality, or to use a given scheme to assign partial credit. See \nComparer Functions\n for details.\n\n\nOther Improvements\n # \n\n\nWe have made a number of other improvements over the edX formula graders, including:\n\n\n\n\nSquare roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like \nsqrt(x-1)\n or \n(x-1)^0.5\n always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases.\n\n\nOur parser uses a parsing cache, and hence runs much more efficiently than the edX graders.\n\n\nIf a student inputs an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue.\n\n\nWhen students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable.\n\n\nSimilarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing.\n\n\nIf an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the \ndebug\n flag to \nTrue\n, and a more technical message will usually be displayed.\n\n\nFull sampling details are included when the \ndebug\n flag is set to \nTrue\n.\n\n\nEnhancements to the AsciiMath renderer (the preview that students see when using \ntextline /\n inputs) are available using our highly recommended \nAsciiMath renderer definitions\n.\n\n\n\n\nNote that a few of these improvements have been merged into edX by the authors of this library.\n\n\nOptions Listing\n # \n\n\nHere is the full list of options specific to a \nFormulaGrader\n.\n\n\ngrader = FormulaGrader(\n    variables=list,  # default []\n    numbered_vars=list,  # default []\n    sample_from=dict,  # default {}\n    samples=int,  # default 5\n    user_functions=dict,  # default {}\n    user_constants=dict,  # default {}\n    failable_evals=int,  # default 0\n    instructor_vars=list,  # default []\n    blacklist=list,  # default []\n    whitelist=list,  # default []\n    forbidden_strings=list,  # default []\n    forbidden_message=str,  # default 'Invalid Input: This particular answer is forbidden'\n    required_functions=list,  # default []\n    metric_suffixes=bool,  # default False\n    tolerance=(float | percentage),  # default '0.01%'\n)", 
            "title": "FormulaGrader"
        }, 
        {
            "location": "/grading_math/formula_grader/#formulagrader", 
            "text": "FormulaGrader  is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's  formularesponse /  tag, but with much more versatility.   Note   All expressions are treated in a case sensitive manner. This means that variables  m  and  M  are distinct. Case-insensitive  FormulaGrader s were deprecated in  Version 1.1.0  All whitespace is stripped from formulas that are entered. So,  1 + x ^ 2  is equivalent to  1+x^2 .", 
            "title": "FormulaGrader"
        }, 
        {
            "location": "/grading_math/formula_grader/#variables-and-sampling", 
            "text": "FormulaGrader  grades a formula by numerical sampling. That is, random values are assigned to each of the unknown variables and unknown functions, and the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct.  Variables are configured by including a list of strings of each variable name as follows.   from mitxgraders import *  grader = FormulaGrader(\n...     answers='1+x^2+y',\n...     variables=['x', 'y']\n... )  Note that the  answers  parameter follows all of the usual allowances from  ItemGrader .  The variables need to have numbers randomly assigned to them. Each is sampled from a  sampling set , which is  RealInterval()  by default (random numbers between 1 and 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the  sample_from  key.   grader = FormulaGrader(\n...     answers='1+x^2+y+z/2',\n...     variables=['x', 'y', 'z'],\n...     sample_from={\n...         'x': ComplexRectangle(),\n...         'y': [2, 6],\n...         'z': (1, 3, 4, 8)\n...     }\n... )  The  sample_from  key must be a dictionary of  'variable_name': sampling_set  pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.", 
            "title": "Variables and Sampling"
        }, 
        {
            "location": "/grading_math/formula_grader/#variable-names", 
            "text": "Variable names are case-sensitive. They must start with a letter, and can be proceded by any combination of letters and numbers. There are two ways to write subscripts and superscripts:   Old edX style:  var_123  (we also allow the use of multiple underscores for backwards compatability with edX, although it is not recommended that this be used)  Tensor style:  var_{123} ,  var_{123}^{456}  (subscript first), or  var^{456}   Sub/superscripts can contain any combination of letters and numbers. Tensor style sub/superscripts are allowed to start with a  -  sign.  All types of variable names are allowed to end with an arbitrary number of primes  '  (apostrophes, useful to indicate differentiation or different reference frames). Students on tablets may need to disable \"smart quotes\" to enter this character.  The AsciiMath renderer used in  textline  entries in edX has a number of special symbols that can help make variable names look like particular mathematical entries. A handful of these are  hatx ,  vecx ,  tildex ,  barx ,  dotx  and  ddotx . There are also a handful of other reserved names in AsciiMath; we recommend testing your variables to ensure that they render as expected.", 
            "title": "Variable Names"
        }, 
        {
            "location": "/grading_math/formula_grader/#numbered-variables", 
            "text": "You can also specify special variables that are numbered. For example, if you specify that  a  is a numbered variable, students can include  a_{0} ,  a_{5} ,  a_{-2} , etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name.   grader = FormulaGrader(\n...     answers='a_{0} + a_{1}*x + 1/2*a_{2}*x^2',\n...     variables=['x'],\n...     numbered_vars=['a'],\n...     sample_from={\n...         'x': [-5, 5],\n...         'a': [-10, 10]\n...     }\n... )  If you have a variable name that would clash with a numbered variable (say, you defined  a_{0}  and also a numbered variable  a ), then the specific variable has precedence.", 
            "title": "Numbered Variables"
        }, 
        {
            "location": "/grading_math/formula_grader/#samples-and-failable-evaluations", 
            "text": "To control the number of samples that are checked to ensure correctness, you can modify the  samples  key.   grader = FormulaGrader(\n...     answers='1+x^2',\n...     variables=['x'],\n...     samples=10\n... )  The default for  samples  is 5.  You may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set  failable_evals . This should be used very sparingly!   grader = FormulaGrader(\n...     answers='1+x^2',\n...     variables=['x'],\n...     samples=10,\n...     failable_evals=1\n... )", 
            "title": "Samples and Failable Evaluations"
        }, 
        {
            "location": "/grading_math/formula_grader/#constants", 
            "text": "By default, four constants are defined:  e ,  pi , and  i=j=sqrt(-1) . You can define new constants by passing in a dictionary to  user_constants  as follows.   grader = FormulaGrader(\n...     answers='1/sqrt(1-v^2/c^2)',\n...     variables=['v'],\n...     user_constants={\n...         'c': 3e8\n...     }\n... )  Constants are treated as variables that only ever have one value.", 
            "title": "Constants"
        }, 
        {
            "location": "/grading_math/formula_grader/#functions", 
            "text": "By default, a large array of mathematical functions are available for use. See the full list  here . Note that all functions are capable of handling complex expressions unless otherwise stated. In the following example,  z*z  is recognized to be different from  abs(z)^2 .   grader = FormulaGrader(\n...     answers='abs(z)^2',\n...     variables=['z'],\n...     sample_from={\n...         'z': ComplexRectangle()\n...     }\n... )  grader(None, 'z*z')['ok']\nFalse  grader(None, 'z*conj(z)')['ok']\nTrue", 
            "title": "Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#user-functions", 
            "text": "You can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the  user_functions  key as follows.   grader = FormulaGrader(\n...     answers='x*x',\n...     variables=['x'],\n...     user_functions={'f': lambda x: x*x}\n... )  This defines a function  f(x) = x^2  that students may use. User-defined function names must start with a letter, and can use numbers and underscores, such as  my_func2 . They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg,  f'' . Be careful about using quotation marks appropriately when using primes in function names, as in the following example.   grader = FormulaGrader(\n...     answers= f''(x) ,\n...     variables=['x'],\n...     user_functions={ f'' : lambda x: x*x}\n... )", 
            "title": "User Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#choosing-a-function-randomly", 
            "text": "You can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows.   import numpy as np  grader = FormulaGrader(\n...     answers= f(x) ,\n...     variables=['x'],\n...     user_functions={ f : [np.sin, np.cos]}\n... )  Each time this formula is checked, the function  f  will be sampled from the list of available functions.  You can also specify a random well-behaved function by using the  RandomFunction()  sampling set.   grader = FormulaGrader(\n...     answers= f''(x) + omega^2*f(x) ,\n...     variables=['x', 'omega'],\n...     user_functions={\n...          f : RandomFunction(),\n...          f'' : RandomFunction()\n...     }\n... )  This allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example. See  Sampling  for further options associated with  RandomFunction .", 
            "title": "Choosing a Function Randomly"
        }, 
        {
            "location": "/grading_math/formula_grader/#overriding-default-functions-and-constants", 
            "text": "You can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with  suppress_warnings=True . The following grader raises this warning when constructed:   try:\n...     grader = FormulaGrader(\n...         answers='x^2',\n...         variables=['x'],\n...         user_functions={'sin': lambda x: x*x},\n...     )\n... except ConfigError as error:\n...     print(error)\nWarning: 'user_functions' contains entries 'sin' which will override default values. If you intend to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.  The error can be suppressed by setting  suppress_warnings=True .   grader = FormulaGrader(\n...     answers='x^2',\n...     variables=['x'],\n...     user_functions={'sin': lambda x: x*x},\n...     suppress_warnings=True\n... )", 
            "title": "Overriding Default Functions and Constants"
        }, 
        {
            "location": "/grading_math/formula_grader/#restricting-student-input", 
            "text": "For some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand  sin(2*theta) , then you don't want students to be able to just write  sin(2*theta)  and be graded correct.  FormulaGrader  offers a number of ways to restrict what sort of answers will be marked correct.", 
            "title": "Restricting Student Input"
        }, 
        {
            "location": "/grading_math/formula_grader/#instructor-variables", 
            "text": "In some situations, you need an extra variable to help define the problem in some way, particularly when using  DependentSampler . Alternatively, you may want to remove a default constant such as  e ,  i ,  j  or  pi  from the problem. Both of these situations can be addressed by specifying particular variables to be instructor variables, as in the following.   grader = FormulaGrader(\n...     answers='s/c',\n...     variables=['s', 'c', 'phi'],\n...     sample_from={\n...         's': DependentSampler(depends=['phi'], formula='sin(phi)'),\n...         'c': DependentSampler(depends=['phi'], formula='cos(phi)')\n...     },\n...     instructor_vars=['phi']\n... )  Here, students can use  s  and  c , but not  phi  in their answer. The  instructor_vars  key accepts a list of the variables/constants you wish to make unavailable to students.", 
            "title": "Instructor Variables"
        }, 
        {
            "location": "/grading_math/formula_grader/#forbidden-strings", 
            "text": "You can forbid students from entering certain strings using the  forbidden_strings  key:   grader = FormulaGrader(\n...     answers='2*sin(theta)*cos(theta)',\n...     variables=['theta'],\n...     forbidden_strings=['*theta', 'theta*', 'theta/', '+theta', 'theta+', '-theta', 'theta-'],\n...     forbidden_message= Your answer should only use trigonometric functions acting on theta, not multiples of theta \n... )  If a student tries to use one of these strings, then they receive the  forbidden_message , without giving away what the forbidden string is. We recommend using this sparingly, as students may find it confusing. The default  forbidden_message  is \"Invalid Input: This particular answer is forbidden\".  Forbidden strings and student answers are stripped of whitespace before being compared. Thus, if  x + y  is forbidden, then answers containing  x+y  or  x   +   y  will be rejected.", 
            "title": "Forbidden Strings"
        }, 
        {
            "location": "/grading_math/formula_grader/#blacklists-and-whitelists", 
            "text": "You can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example,  sin  is disallowed in correct answers.   grader = FormulaGrader(\n...     answers='sqrt(1 - cos(x)^2)',\n...     variables=['x'],\n...     sample_from={'x': [0, np.pi]},\n...     blacklist=['sin']\n... )  If you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are  sin  and  cos .   grader = FormulaGrader(\n...     answers='sin(x)/cos(x)',\n...     variables=['x'],\n...     whitelist=['sin', 'cos']\n... )  If you want to exclude all functions, use  whitelist=[None] :   grader = FormulaGrader(\n...     answers='pi/2-x',\n...     variables=['x'],\n...     whitelist=[None]  # no functions are allowed\n... )  You cannot use a whitelist and a blacklist at the same time.", 
            "title": "Blacklists and Whitelists"
        }, 
        {
            "location": "/grading_math/formula_grader/#required-functions", 
            "text": "You can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required.   grader = FormulaGrader(\n...     answers='2*sin(theta)*cos(theta)',\n...     variables=['theta'],\n...     required_functions=['sin', 'cos']\n... )", 
            "title": "Required Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#tolerance", 
            "text": "Student inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg,  0.1 ) or a percentage (eg,  '0.01%' , which is the default tolerance). Tolerances must be nonnegative numbers or percentages.   grader = FormulaGrader(\n...     answers='2*sin(theta)*cos(theta)',\n...     variables=['theta'],\n...     tolerance=0.00001\n... )  Tolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers.  Note that if the answer is exactly  0  (or can be sampled to be exactly  0 , such as when using integer sampling), percentage tolerances don't work (as any percentage of zero is still zero). This means that the student-supplied answer must also evaluate to exactly zero to be graded correctly. Note that answers like  cos(pi/2)  evaluate to approximately  10^(-16)  due to numerical roundoff error. If you want such answers to be graded correctly, make sure to use an absolute tolerance instead of a relative tolerance on such questions.", 
            "title": "Tolerance"
        }, 
        {
            "location": "/grading_math/formula_grader/#suffixes", 
            "text": "Numbers with a  %  at the end will be treated as percentages, and converted to the appropriate decimals. If you desire, you can also enable the use of metric suffixes by setting the appropriate setting as follows.   grader = FormulaGrader(\n...     answers='2m*a',  # Equivalent to '0.002*a'\n...     variables=['a'],\n...     metric_suffixes=True\n... )  The included suffixes are:   k : 1e3  M : 1e6  G : 1e9  T : 1e12  m : 1e-3  u : 1e-6  n : 1e-9  p : 1e-12   We strongly recommend  not  combining these suffixes with the variables names  k ,  M ,  G ,  T ,  m ,  u ,  n  or  p , as  2m  and  2*m  will then represent two very different things, which can lead to much student confusion.", 
            "title": "Suffixes"
        }, 
        {
            "location": "/grading_math/formula_grader/#sibling-variables", 
            "text": "When a student submits several mathematical expressions as part of one problem, it is sometimes useful to grade these inputs in comparison to each other. This can be done using  sibling variables , which are available when  FormulaGrader  is used as a subgrader in  ordered   ListGrader  problems.  For example:   grader = ListGrader(\n...     answers=[\n...         ('x', '2*x','3*x'),     # first input can be any of these 3 answers\n...         'sibling_1^2',          # second input must be first input squared\n...         'sibling_2^2'           # third input must be second input squared\n...     ],\n...     ordered=True,\n...     subgraders=FormulaGrader(variables=['x'])\n... )  Note that in this example, the sequence of inputs  ['2*x', 4*x^2, 16*x^4]  is correct, and so is  ['3*x', 9*x^2, 81*x^4] , but  ['3*x', 4*x^2, 16*x^4]  receives only two-thirds credit (from the first entry matching a given answer, and the last entry being the square of the second entry).   student_inputs = ['2*x','4*x^2', '16*x^4']  result1, result2, result3 = grader(None, student_inputs)['input_list']  result1['ok'], result2['ok'], result3['ok']\n(True, True, True)  student_inputs = ['3*x','9*x^2', '81*x^4']  result1, result2, result3 = grader(None, student_inputs)['input_list']  result1['ok'], result2['ok'], result3['ok']\n(True, True, True)  student_inputs = ['3*x','4*x^2', '16*x^4']  result1, result2, result3 = grader(None, student_inputs)['input_list']  result1['ok'], result2['ok'], result3['ok']\n(True, False, True)  Notes:   Sibling variables are available to  FormulaGrader ,  NumericalGrader , and  MatrixGrader , but only in  ordered   ListGrader  problems.  The jth student input is referenced as  sibling_j . (Exception: If nesting  ListGraders  with grouping,  sibling_j  refers to the jth member of any particular group.)  Students are not able to use  sibling_j  in any of their answers.", 
            "title": "Sibling Variables"
        }, 
        {
            "location": "/grading_math/formula_grader/#comparer-functions", 
            "text": "Comparer functions allow you to compare the student input to the author's expectation using aspects other than equality, or to use a given scheme to assign partial credit. See  Comparer Functions  for details.", 
            "title": "Comparer Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#other-improvements", 
            "text": "We have made a number of other improvements over the edX formula graders, including:   Square roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like  sqrt(x-1)  or  (x-1)^0.5  always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases.  Our parser uses a parsing cache, and hence runs much more efficiently than the edX graders.  If a student inputs an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue.  When students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable.  Similarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing.  If an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the  debug  flag to  True , and a more technical message will usually be displayed.  Full sampling details are included when the  debug  flag is set to  True .  Enhancements to the AsciiMath renderer (the preview that students see when using  textline /  inputs) are available using our highly recommended  AsciiMath renderer definitions .   Note that a few of these improvements have been merged into edX by the authors of this library.", 
            "title": "Other Improvements"
        }, 
        {
            "location": "/grading_math/formula_grader/#options-listing", 
            "text": "Here is the full list of options specific to a  FormulaGrader .  grader = FormulaGrader(\n    variables=list,  # default []\n    numbered_vars=list,  # default []\n    sample_from=dict,  # default {}\n    samples=int,  # default 5\n    user_functions=dict,  # default {}\n    user_constants=dict,  # default {}\n    failable_evals=int,  # default 0\n    instructor_vars=list,  # default []\n    blacklist=list,  # default []\n    whitelist=list,  # default []\n    forbidden_strings=list,  # default []\n    forbidden_message=str,  # default 'Invalid Input: This particular answer is forbidden'\n    required_functions=list,  # default []\n    metric_suffixes=bool,  # default False\n    tolerance=(float | percentage),  # default '0.01%'\n)", 
            "title": "Options Listing"
        }, 
        {
            "location": "/grading_math/numerical_grader/", 
            "text": "NumericalGrader\n # \n\n\nWhen grading math expressions without functions or variables, you can use \nNumericalGrader\n instead of \nFormulaGrader\n. \nNumericalGrader\n is a specialized version of \nFormulaGrader\n whose behavior resembles the edX \nnumericalresponse/\n tag.\n\n\nConfiguration\n # \n\n\nNumericalGrader\n has all of the same options as \nFormulaGrader\n except:\n\n\n\n\ntolerance\n: has a higher default value of \n'5%'\n\n\nfailable_evals\n is always set to 0\n\n\nsamples\n is always set to 1\n\n\nvariables\n is always set to \n[]\n (no variables allowed)\n\n\nsample_from\n is always set to \n{}\n (no variables allowed)\n\n\nuser_functions\n can only define specific functions, with no random functions\n\n\n\n\nNote that \nNumericalGrader\n will still evaluate formulas. If you are grading simple integers (such as 0, 1, 2, -1, etc), you may want to consider using \nStringGrader\n instead of \nNumericalGrader\n.", 
            "title": "NumericalGrader"
        }, 
        {
            "location": "/grading_math/numerical_grader/#numericalgrader", 
            "text": "When grading math expressions without functions or variables, you can use  NumericalGrader  instead of  FormulaGrader .  NumericalGrader  is a specialized version of  FormulaGrader  whose behavior resembles the edX  numericalresponse/  tag.", 
            "title": "NumericalGrader"
        }, 
        {
            "location": "/grading_math/numerical_grader/#configuration", 
            "text": "NumericalGrader  has all of the same options as  FormulaGrader  except:   tolerance : has a higher default value of  '5%'  failable_evals  is always set to 0  samples  is always set to 1  variables  is always set to  []  (no variables allowed)  sample_from  is always set to  {}  (no variables allowed)  user_functions  can only define specific functions, with no random functions   Note that  NumericalGrader  will still evaluate formulas. If you are grading simple integers (such as 0, 1, 2, -1, etc), you may want to consider using  StringGrader  instead of  NumericalGrader .", 
            "title": "Configuration"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/", 
            "text": "MatrixGrader\n # \n\n\nMatrixGrader\n is an extended version of \nFormulaGrader\n used to grade mathematical expressions containing scalars, vectors, and matrices. Authors and students may enter matrix (or vector) expressions by using variables sampled from matrices, or by entering a matrix entry-by-entry.\n\n\nCompared to \nFormulaGrader\n, \nMatrixGrader\n has enhanced error-handling capabilities specific to issues with arrays, extra functions for manipulating vectors and matrices, and partial credit options for component-by-component comparison.\n\n\nDo not let its name fool you: \nMatrixGrader\n is capable of handling vectors, matrices and tensors. We will sometimes refer to all of these possibilities as \"arrays\" (\nMatrixGrader\n just sounds cooler than \nArrayGrader\n though, doesn't it?).\n\n\nA First Example\n # \n\n\nA typical use of \nMatrixGrader\n might look like\n\n\n from mitxgraders import *\n\n grader1 = MatrixGrader(\n...   answers='4*A*B^2*v',\n...   variables=['A', 'B', 'v'],\n...   identity_dim=2, # makes 'I' available to students as the 2x2 identity matrix\n...   sample_from={\n...      'A': RealMatrices(), # samples from 2 by 2 matrices by default\n...      'B': RealMatrices(),\n...      'v': RealVectors(shape=2), # sample 2-component vectors\n...   }\n... )\n\n\n\n\nThe next few lines call the grader as a check function. The inputs \n'4*A*B^2*v'\n and \n'4*A*B*B*v'\n are correct:\n\n\n result = grader1(None, '4*A*B^2*v')\n\n result == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n result = grader1(None, '4*A*B*B*v')\n\n result == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue\n\n\n\n\nwhile the input \n'4*B*A*B*v'\n is incorrect because the matrix-sampled variables are non-commutative:\n\n\n result = grader1(None, '4*B*A*B*v')\n\n result == {'msg': '', 'grade_decimal': 0, 'ok': False}\nTrue\n\n\n\n\nMatrix Sampling\n # \n\n\nIn the MatrixGrader example above, the variables \nA\n and \nB\n were sampled from \nRealMatrices()\n. The \nRealMatrices\n sampling class samples from 2 by 2 matrices by default but can be configured to sample matrices of different shapes. See \nSampling\n for more information about matrix and vector sampling.\n\n\nMatrix Entry\n # \n\n\nIn addition to using variables that vectors and matrices, students can also enter matrices and vectors directly, entry-by-entry.\n\n\n\n\n\n\n\n\nInput with symbols:\n\n\nInput entry-by-entry:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nIn order for matrices entered entry-by-entry to display correctly in edX, authors must use the AsciiMath renderer provided by \ntextline math='true'/\n.\n\n\n\n\n\n\nBy default, students can only input vectors and \nnot matrices\n. This is configured through the \nmax_array_dim\n configuration key:\n\n\n\n\nmax_array_dim=1\n: This (the default) allows students to enter vectors entry-by-entry but not matrices.\n\n\nentering vector \n[x, y + 1, z]\n is OK.\n\n\nentering matrix \n[[1, x], [y, 2]]\n raises an error.\n\n\n\n\n\n\nmax_array_dim=2\n: This allows student to vectors and matrices.\n\n\nentering vector \n[x, y + 1, z]\n is OK.\n\n\nentering matrix \n[[1, x], [y, 2]]\n is OK.\n\n\nentering tensor \n[ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ]\n raises an error.\n\n\n\n\n\n\n\n\nThe decision to disable matrix-entry by default is intended to prevent students from entering single-row or single-column matrices when a vector is expected.\n\n\nMatrix Operations and MathArrays\n # \n\n\nMatrixGrader\n uses a custom subclass of \nnumpy.ndarray\n to internally represent matrices. Understanding how the \nMathArray\n class behaves is useful for creating \nMatrixGrader\n problems, and \nMathArray\n can be used directly by problem-authors to add extra matrices to a problem.\n\n\nHow MatrixGrader uses MathArrays\n # \n\n\nWhether a matrix is input entry-by-entry or represented through variables, \nMathArray\ns are used to evaluate student expressions.\n\n\nFor example, consider the grader below.\n\n\n grader = MatrixGrader(\n...     answers='2*A*[1, 2, 3] + v',\n...     user_constants={\n...       'A': MathArray([[1, 2, 3], [4, 5, 6]])\n...     },\n...     variables=['v'],\n...     sample_from={\n...       'v': RealVectors(shape=2) # samples a random 2-component vector\n...     }\n... )\n\n\n\n\nWhen a student inputs \nv + A*2*[1, 2, 3]\n to the grader above, a calculation similar to\n\n\n v = MathArray([2, -1]) # Really, random samples would be chosen.\n\n A = MathArray([[1, 2, 3], [4, 5, 6]])\n\n v + A*2*MathArray([1, 2, 3])  # below is the result of evaluating student input, which would next be compared to author's answer\nMathArray([30, 63])\n\n\n\n\nis performed (but repeated multiple times with different values for the random variables).\n\n\nDimension and Shape\n # \n\n\nMathArray\ns have dimension and shape. For example:\n\n\n\n\n\n\n\n\nStudent Input\n\n\nConverted to\n\n\nName\n\n\ndimension\n\n\nshape\n\n\n\n\n\n\n\n\n\n\n[1, 2, 3]\n\n\nMathArray([1, 2, 3])\n\n\n\"vector\"\n\n\n1\n\n\n(3,  )\n\n\n\n\n\n\n[[1, 2, 3], [4, 5, 6]]\n\n\nMathArray([[1, 2, 3], [4, 5, 6]])\n\n\n\"matrix\"\n\n\n2\n\n\n(2, 3)\n\n\n\n\n\n\n[[1, 2, 3]]\n\n\nMathArray([[1, 2, 3]])\n\n\n\"single-row matrix\"\n\n\n2\n\n\n(1, 3)\n\n\n\n\n\n\n[[1], [2], [3]]\n\n\nMathArray([[1], [2], [3]])\n\n\n\"single-column matrix\"\n\n\n2\n\n\n(3, 1)\n\n\n\n\n\n\n[[[1, 2]], [[3, 4]]]\n\n\nMathArray([[[1, 2]], [[3, 4]]])\n\n\n\"tensor\"\n\n\n3\n\n\n(1, 1, 2)\n\n\n\n\n\n\n\n\nTensor math arrays (dimension 3+) currently have very little support.\n\n\n\n\nWarning\n\n\nNote that a vector, a single-column matrix, and a single-row matrix are distinct entities. We suggest avoiding single-row and single-column matrices.\n\n\nSee \nA note about vectors\n\n\n\n\nAllowed operations\n # \n\n\nMathArray\ns support the usual binary operations for vectors and matrices, with appropriate shape restrictions. Compared to \nnumpy.ndarray\n, \nMathArray\n has much more stringent shape restrictions.\n\n\n\n\n\n\nAddition and Subtraction\n: Performed elementwise.\n\n\n\n\n\n\n\n\nExpression\n\n\nraises error unless\n\n\nresult type\n\n\n\n\n\n\n\n\n\n\nMathArray +/- MathArray\n\n\nboth inputs have exactly the same shape\n\n\nMathArray\n\n\n\n\n\n\nMathArray +/- number\n\n\nnumber=0\n\n\nMathArray\n\n\n\n\n\n\nnumber +/- MathArray\n\n\nnumber=0\n\n\nMathArray\n\n\n\n\n\n\n\n\n\n\n\n\nMultiplication\n: Note that \nvector * vector\n is a dot product\n\n\n\n\n\n\n\n\nExpression\n\n\nleft-input shape\n\n\nright-input shape\n\n\nraises error unless\n\n\nresult type\n\n\n\n\n\n\n\n\n\n\nvector * vector\n\n\n(k1, )\n\n\n(k2, )\n\n\nk1=k2\n\n\nnumber\n (dot product of two vectors)\n\n\n\n\n\n\nMathArray * number\n\n\nany\n\n\n-\n\n\n-\n\n\nMathArray\n (elementwise multiplication)\n\n\n\n\n\n\nnumber * MathArray\n\n\n-\n\n\nany\n\n\n-\n\n\nMathArray\n (elementwise multiplication)\n\n\n\n\n\n\nmatrix * vector\n\n\n(m, n)\n\n\n(k)\n\n\nn=k\n\n\nvector\n with \nm\n components\n\n\n\n\n\n\nvector * matrix\n\n\n(k, )\n\n\n(m, n)\n\n\nm=k\n\n\nvector\n with \nn\n components\n\n\n\n\n\n\nmatrix * matrix\n\n\n(m1, n1)\n\n\n(m2, n2)\n\n\nn1=m2\n\n\nmatrix\n of shape \n(m1, n2)\n\n\n\n\n\n\n\n\n\n\n\n\nDivision\n: Division either raises an error, or is performed elementwise:\n\n\n\n\n\n\n\n\nExpression\n\n\nraises error unless\n\n\nresult type\n\n\n\n\n\n\n\n\n\n\nany / MathArray\n\n\nalways raises error\n\n\n-\n\n\n\n\n\n\nMathArray / number\n\n\n-\n\n\nMathArray\n (elementwise division)\n\n\n\n\n\n\n\n\n\n\n\n\nPowers\n: If \nA\n is a MathArray, then \nA^k\n will always raise an error unless\n\n\n\n\nA\n is a square matrix, \nand\n\n\nk\n is an integer.\n\n\n\n\nIn this case, \nA^k\n is equivalent to:\n\n\n\n\nk\n repeated multiplications of \nA\n if \nk \n 0\n,\n\n\n(inverse of A)^|k|\n if \nk \n 0\n, and\n\n\nthe identity matrix if \nk=0\n.\n\n\n\n\nNote\n: Negative exponents can give students \"too much power\". For example, if you want students to enter the inverse of \n[[1, 2], [3, 4]]\n, you probably want them to enter \n[[-2, 1], [1.5, -0.5]]\n rather than \n[[1, 2], [3, 4]]^-1\n. To this end, you can disable negative powers in MatrixGrader problems by setting \nnegative_powers=False\n.\n\n\n\n\n\n\nA Note About Vectors\n # \n\n\nVectors are distinct from single-row matrices and single-column matrices, and can be left- or right-multiplied by a matrix:\n\n\n vec = MathArray([1, 2, 3])\n\n row = MathArray([[1, 2, 3]])\n\n col = MathArray([[1], [2], [3]])\n\n try:\n...     vec + row # raises error\n... except StudentFacingError as error:\n...     print(error)\nCannot add/subtract a vector of length 3 with a matrix of shape (rows: 1, cols: 3).\n\n\n A = MathArray([[1, 2, 3], [4, 5, 6]])\n\n A * vec # matrix * vector\nMathArray([14, 32])\n\n other_vec = MathArray([1, 2])\n\n other_vec * A # vector * matrix\nMathArray([ 9, 12, 15])\n\n\n\n\nWe suggest avoiding single-column and single-row matrices.\n\n\nShape Errors\n # \n\n\nWhen operations cannot be performed because of shape-mismatch, MathArray raises readable \nStudentFacingError\ns. These error messages are intended to be presented directly to students. For example:\n\n\n A = MathArray([[1, 2], [3, 4], [5, 6]]) # matrix, shape (3, 2)\n\n B = MathArray([[1, 2], [3, 4]])         # matrix, shape (2, 2)\n\n v = MathArray([1, 2])                   # vector, shape (2,  )\n\n\n\n\nSome sample error messages:\n\n\n\n\n\n\n\n\nStudent input:\n\n\nValid?\n\n\nStudent receives error message:\n\n\n\n\n\n\n\n\n\n\n'A+B'\n\n\nNo\n\n\nCannot add/subtract a matrix of shape (rows: 3, cols: 2) with a matrix of shape (rows: 2, cols: 2).\n\n\n\n\n\n\n'v*A'\n\n\nNo\n\n\nCannot multiply a vector of length 2 with a matrix of shape (rows: 3, cols: 2).\n\n\n\n\n\n\n'B*v'\n\n\nYes\n\n\n\n\n\n\n\n\n'A^2'\n\n\nNo\n\n\nCannot raise a non-square matrix to powers.\n\n\n\n\n\n\n'B^2'\n\n\nYes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHandling Errors\n # \n\n\nWhile grading a student's input, matrix-related errors can occur in three places:\n\n\n\n\nwhile parsing the student's input,\n\n\nwhile evaluating the student's input, and\n\n\nwhile comparing the student's input to the author's stored answer.\n\n\n\n\nParse Errors:\n # \n\n\nFor example, if a student enters \n'[[1, 2],[3] ]'\n, a matrix missing an entry in second row:\n\n\n grader = MatrixGrader(\n...     answers='[[1, 2], [3, 4]]',\n...     max_array_dim=2, # allow students to enter matrices entry-by-entry\n... )\n\n student_input = '[[1, 2], [3]]'\n\n try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     print(error) # students see this error message\nUnable to parse vector/matrix. If you're trying to enter a matrix, this is most likely caused by an unequal number of elements in each row.\n\n\n\n\nSuch parse errors are \nalways\n displayed to students.\n\n\nShape-Mismatch Errors During Evaluation\n # \n\n\nIf a student submits an answer that will raise shape-mismatch errors then an error is raised with a helpful message. This avoids consuming one of the student's attempts. For example:\n\n\n grader = MatrixGrader(\n...     answers='[11, 22, 33]',\n... )\n\n student_input = '[10, 20, 30] + [1, 2]' # Error! Adding vectors with different shapes\n\n try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     print(error) # students see this error message\nCannot add/subtract a vector of length 3 with a vector of length 2.\n\n\n\n\nIf you would rather mark the student incorrect when shape errors occur (and also consume an attempt), set \nshape_errors=False\n.\n\n\nShape-Mismatch Errors During Comparison\n # \n\n\nIf the author's answer is a 3-component vector, and the student submits a different 3-component vector, then they will be marked incorrect. However, if the student submits a 2-component vector or a number, they will receive an error message:\n\n\n grader = MatrixGrader(\n...     answers='[1, 2, 3]',\n... )\n\n student_input = '[1, 2, -3]' # wrong answer\n\n result = grader(None, student_input) # grade the input like edX would\n\n result == {'msg': '', 'grade_decimal': 0, 'ok': False}\nTrue\n\n\n student_input = '[1, 2, 3, 4]' # too many components\n\n try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     print(error) # students see this error message\nExpected answer to be a vector, but input is a vector of incorrect shape\n\n\n student_input = '0' # scalar; should be a vector\n\n try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     print(error) # students see this error message\nExpected answer to be a vector, but input is a scalar\n\n\n\n\nThe default handling of shape errors that arise when comparing student input to author's answer is:\n\n\n\n\nraise an error (do not mark student incorrect), and\n\n\nreveal the desired type (above, a vector) but not the desired shape (above, 3-components)\n\n\n\n\nThis behavior can be configured through the \nanswer_shape_mismatch\n key. We can choose whether an error is presented or an attempt is consumed through the \nis_raised\n key, while we choose whether to reveal the desired input shape or type with the \nmsg_detail\n key. For example, to\n\n\n\n\nmark students wrong instead of raising an error, and\n\n\nreveal the shape and the type\n\n\n\n\nwe can use:\n\n\n grader = MatrixGrader(\n...     answers='[1, 2, 3]',\n...     answer_shape_mismatch={\n...         'is_raised': False,\n...         'msg_detail': 'shape' # must be one of: None, 'type', 'shape'\n...     }\n... )\n\n student_input = '0' # wrong shape\n\n result = grader(None, student_input) # grades the input like edX would\n\n result == {\n...   'grade_decimal': 0,\n...   'msg': 'Expected answer to be a vector of length 3, but input is a scalar',\n...   'ok': False\n... }\nTrue\n\n\n\n\nHiding All Error Messages\n # \n\n\nMatrixGrader\ns can be used to introduce non-commuting variables. In such a situation, students may not know that the variables they are using are matrices \"under the hood\", and so we want to suppress all matrix errors and messages. We can do this by setting \nsuppress_matrix_messages=True\n, which overrides \nanswer_shape_mismatch={'is_raised'}\n and \nshape_errors\n. In the following example, \nA\n and \nB\n are secretly matrices that don't commute, but students will never see a matrix error message from typing something like \n1+A\n.\n\n\n grader = MatrixGrader(\n...     answers='A*B',\n...     variables=['A', 'B'],\n...     sample_from={\n...         'A': RealMatrices(),\n...         'B': RealMatrices()\n...     },\n...     max_array_dim=0,\n...     suppress_matrix_messages=True\n... )\n\n grader(None, 'A*B')['ok']\nTrue\n\n grader(None, 'B*A')['ok']\nFalse\n\n grader(None, 'A+1')['ok']\nFalse\n\n\n\n\nNote that this will also suppress error messages from trying to do things like \nsin([1, 2])\n or \n[1, 2]^2\n. If your answer needs to take functions of the non-commuting variables, then this option is insufficient.\n\n\nMatrix Functions\n # \n\n\nMatrixGrader\n provides all the default functions of \nFormulaGrader\n (\nsin\n, \ncos\n, etc.) plus some extras such as \ntrans(A)\n (transpose) and \ndet(A)\n (determinant). See \nMathematical Functions\n for full list.\n\n\nSince \nMatrixGrader\n has all of \nFormulaGrader\n's configuration options, additional functions can be supplied through the \nuser_functions\n configuration key. If you supply additional matrix functions, you may wish you use the \nspecify_domain\n decorator function to provide meaningful error messages to students. See \nUser Functions\n for details.\n\n\nIdentity Matrix\n # \n\n\nTo make an nxn identity matrix available to students, specify the configuration key \nidentity_dim=n\n. That is, the grader \nMatrixGrader(identity_dim=4, ...)\n will automatically have a constant \nI\n whose value is the 4 by 4 identity matrix.\n\n\nIf you want a different name (besides \nI\n) for the identity, or if you encounter situations where identity matrices of different sizes are required, you can use the \nidentity\n function. For example:\n\n\n grader = MatrixGrader(\n...     answers='[1, 2, 3]',\n...     user_constants={\n...         'I_2': identity(2),  # the 2 by 2 identity\n...         'I_3': identity(3)  # the 3 by 3 identity\n...     }\n... )\n\n\n\n\nPartial Credit\n # \n\n\nA special \ncomparer\n called \nMatrixEntryComparer\n has been built to cater for partial credit in \nMatrixGrader\n problems. In order to facilitate the use of \nMatrixEntryComparer\n, if either of the following two configuration options are present, \nMatrixGrader\n will use \nMatrixEntryComparer\n as the default comparer instead of \nequality_comparer\n.\n\n\n\n\nentry_partial_credit\n: \nproportional\n or a number\n\n\nentry_partial_msg\n: The message to display\n\n\n\n\nSee the documentation for \nMatrixEntryComparer\n for details on how these options work.\n\n\nConfiguration Options\n # \n\n\nMatrixGrader\n has all of \nFormulaGrader\n's configuration options, plus some extras. The extras are:\n\n\n\n\nidentity_dim\n: If specified as a positive integer \nn\n, then an n by n identity matrix is added to the available constants with name \n'I'\n. Defaults to \nNone\n.\n\n\nmax_array_dim\n (nonnegative int): Controls the maximum \ndimension\n of arrays that students can enter entry-by-entry. Default is \n1\n: vectors can be entered entry-by-entry, but not matrices.\n\n\nnegative_powers\n (bool): whether negative powers are enabled for square matrices (which calculate powers of matrix inverse). Defaults to \nTrue\n.\n\n\nshape_errors\n (bool): See \nHandling Errors: Shape-mismatch errors during evaluation\n. Defaults to \nTrue\n.\n\n\nsuppress_matrix_messages\n (bool): See \nHiding All Error Messages\n. Defaults to \nFalse\n.\n\n\n\n\nanswer_shape_mismatch\n (dict): A dictionary whose keys are listed below. Some or all keys may be set. Unset keys take default values. See \nHandling Errors: Shape-mismatch errors during comparison\n for details.\n\n\n\n\n'is_raised'\n (bool): defaults to \nTrue\n\n\n'msg_detail'\n (None | 'type' | 'shape'): defaults to \n'type'\n\n\n\n\n\n\n\n\nentry_partial_credit\n: If set to \nproportional\n or a number, uses this setting with \nMatrixEntryComparer\n as the default comparer.\n\n\n\n\nentry_partial_msg\n: If set to a text value, uses this setting with \nMatrixEntryComparer\n as the default comparer.", 
            "title": "MatrixGrader"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#matrixgrader", 
            "text": "MatrixGrader  is an extended version of  FormulaGrader  used to grade mathematical expressions containing scalars, vectors, and matrices. Authors and students may enter matrix (or vector) expressions by using variables sampled from matrices, or by entering a matrix entry-by-entry.  Compared to  FormulaGrader ,  MatrixGrader  has enhanced error-handling capabilities specific to issues with arrays, extra functions for manipulating vectors and matrices, and partial credit options for component-by-component comparison.  Do not let its name fool you:  MatrixGrader  is capable of handling vectors, matrices and tensors. We will sometimes refer to all of these possibilities as \"arrays\" ( MatrixGrader  just sounds cooler than  ArrayGrader  though, doesn't it?).", 
            "title": "MatrixGrader"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#a-first-example", 
            "text": "A typical use of  MatrixGrader  might look like   from mitxgraders import *  grader1 = MatrixGrader(\n...   answers='4*A*B^2*v',\n...   variables=['A', 'B', 'v'],\n...   identity_dim=2, # makes 'I' available to students as the 2x2 identity matrix\n...   sample_from={\n...      'A': RealMatrices(), # samples from 2 by 2 matrices by default\n...      'B': RealMatrices(),\n...      'v': RealVectors(shape=2), # sample 2-component vectors\n...   }\n... )  The next few lines call the grader as a check function. The inputs  '4*A*B^2*v'  and  '4*A*B*B*v'  are correct:   result = grader1(None, '4*A*B^2*v')  result == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  result = grader1(None, '4*A*B*B*v')  result == {'grade_decimal': 1, 'msg': '', 'ok': True}\nTrue  while the input  '4*B*A*B*v'  is incorrect because the matrix-sampled variables are non-commutative:   result = grader1(None, '4*B*A*B*v')  result == {'msg': '', 'grade_decimal': 0, 'ok': False}\nTrue", 
            "title": "A First Example"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#matrix-sampling", 
            "text": "In the MatrixGrader example above, the variables  A  and  B  were sampled from  RealMatrices() . The  RealMatrices  sampling class samples from 2 by 2 matrices by default but can be configured to sample matrices of different shapes. See  Sampling  for more information about matrix and vector sampling.", 
            "title": "Matrix Sampling"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#matrix-entry", 
            "text": "In addition to using variables that vectors and matrices, students can also enter matrices and vectors directly, entry-by-entry.     Input with symbols:  Input entry-by-entry:            Note   In order for matrices entered entry-by-entry to display correctly in edX, authors must use the AsciiMath renderer provided by  textline math='true'/ .    By default, students can only input vectors and  not matrices . This is configured through the  max_array_dim  configuration key:   max_array_dim=1 : This (the default) allows students to enter vectors entry-by-entry but not matrices.  entering vector  [x, y + 1, z]  is OK.  entering matrix  [[1, x], [y, 2]]  raises an error.    max_array_dim=2 : This allows student to vectors and matrices.  entering vector  [x, y + 1, z]  is OK.  entering matrix  [[1, x], [y, 2]]  is OK.  entering tensor  [ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ]  raises an error.     The decision to disable matrix-entry by default is intended to prevent students from entering single-row or single-column matrices when a vector is expected.", 
            "title": "Matrix Entry"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#matrix-operations-and-matharrays", 
            "text": "MatrixGrader  uses a custom subclass of  numpy.ndarray  to internally represent matrices. Understanding how the  MathArray  class behaves is useful for creating  MatrixGrader  problems, and  MathArray  can be used directly by problem-authors to add extra matrices to a problem.", 
            "title": "Matrix Operations and MathArrays"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#how-matrixgrader-uses-matharrays", 
            "text": "Whether a matrix is input entry-by-entry or represented through variables,  MathArray s are used to evaluate student expressions.  For example, consider the grader below.   grader = MatrixGrader(\n...     answers='2*A*[1, 2, 3] + v',\n...     user_constants={\n...       'A': MathArray([[1, 2, 3], [4, 5, 6]])\n...     },\n...     variables=['v'],\n...     sample_from={\n...       'v': RealVectors(shape=2) # samples a random 2-component vector\n...     }\n... )  When a student inputs  v + A*2*[1, 2, 3]  to the grader above, a calculation similar to   v = MathArray([2, -1]) # Really, random samples would be chosen.  A = MathArray([[1, 2, 3], [4, 5, 6]])  v + A*2*MathArray([1, 2, 3])  # below is the result of evaluating student input, which would next be compared to author's answer\nMathArray([30, 63])  is performed (but repeated multiple times with different values for the random variables).", 
            "title": "How MatrixGrader uses MathArrays"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#dimension-and-shape", 
            "text": "MathArray s have dimension and shape. For example:     Student Input  Converted to  Name  dimension  shape      [1, 2, 3]  MathArray([1, 2, 3])  \"vector\"  1  (3,  )    [[1, 2, 3], [4, 5, 6]]  MathArray([[1, 2, 3], [4, 5, 6]])  \"matrix\"  2  (2, 3)    [[1, 2, 3]]  MathArray([[1, 2, 3]])  \"single-row matrix\"  2  (1, 3)    [[1], [2], [3]]  MathArray([[1], [2], [3]])  \"single-column matrix\"  2  (3, 1)    [[[1, 2]], [[3, 4]]]  MathArray([[[1, 2]], [[3, 4]]])  \"tensor\"  3  (1, 1, 2)     Tensor math arrays (dimension 3+) currently have very little support.   Warning  Note that a vector, a single-column matrix, and a single-row matrix are distinct entities. We suggest avoiding single-row and single-column matrices.  See  A note about vectors", 
            "title": "Dimension and Shape"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#allowed-operations", 
            "text": "MathArray s support the usual binary operations for vectors and matrices, with appropriate shape restrictions. Compared to  numpy.ndarray ,  MathArray  has much more stringent shape restrictions.    Addition and Subtraction : Performed elementwise.     Expression  raises error unless  result type      MathArray +/- MathArray  both inputs have exactly the same shape  MathArray    MathArray +/- number  number=0  MathArray    number +/- MathArray  number=0  MathArray       Multiplication : Note that  vector * vector  is a dot product     Expression  left-input shape  right-input shape  raises error unless  result type      vector * vector  (k1, )  (k2, )  k1=k2  number  (dot product of two vectors)    MathArray * number  any  -  -  MathArray  (elementwise multiplication)    number * MathArray  -  any  -  MathArray  (elementwise multiplication)    matrix * vector  (m, n)  (k)  n=k  vector  with  m  components    vector * matrix  (k, )  (m, n)  m=k  vector  with  n  components    matrix * matrix  (m1, n1)  (m2, n2)  n1=m2  matrix  of shape  (m1, n2)       Division : Division either raises an error, or is performed elementwise:     Expression  raises error unless  result type      any / MathArray  always raises error  -    MathArray / number  -  MathArray  (elementwise division)       Powers : If  A  is a MathArray, then  A^k  will always raise an error unless   A  is a square matrix,  and  k  is an integer.   In this case,  A^k  is equivalent to:   k  repeated multiplications of  A  if  k   0 ,  (inverse of A)^|k|  if  k   0 , and  the identity matrix if  k=0 .   Note : Negative exponents can give students \"too much power\". For example, if you want students to enter the inverse of  [[1, 2], [3, 4]] , you probably want them to enter  [[-2, 1], [1.5, -0.5]]  rather than  [[1, 2], [3, 4]]^-1 . To this end, you can disable negative powers in MatrixGrader problems by setting  negative_powers=False .", 
            "title": "Allowed operations"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#a-note-about-vectors", 
            "text": "Vectors are distinct from single-row matrices and single-column matrices, and can be left- or right-multiplied by a matrix:   vec = MathArray([1, 2, 3])  row = MathArray([[1, 2, 3]])  col = MathArray([[1], [2], [3]])  try:\n...     vec + row # raises error\n... except StudentFacingError as error:\n...     print(error)\nCannot add/subtract a vector of length 3 with a matrix of shape (rows: 1, cols: 3).  A = MathArray([[1, 2, 3], [4, 5, 6]])  A * vec # matrix * vector\nMathArray([14, 32])  other_vec = MathArray([1, 2])  other_vec * A # vector * matrix\nMathArray([ 9, 12, 15])  We suggest avoiding single-column and single-row matrices.", 
            "title": "A Note About Vectors"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#shape-errors", 
            "text": "When operations cannot be performed because of shape-mismatch, MathArray raises readable  StudentFacingError s. These error messages are intended to be presented directly to students. For example:   A = MathArray([[1, 2], [3, 4], [5, 6]]) # matrix, shape (3, 2)  B = MathArray([[1, 2], [3, 4]])         # matrix, shape (2, 2)  v = MathArray([1, 2])                   # vector, shape (2,  )  Some sample error messages:     Student input:  Valid?  Student receives error message:      'A+B'  No  Cannot add/subtract a matrix of shape (rows: 3, cols: 2) with a matrix of shape (rows: 2, cols: 2).    'v*A'  No  Cannot multiply a vector of length 2 with a matrix of shape (rows: 3, cols: 2).    'B*v'  Yes     'A^2'  No  Cannot raise a non-square matrix to powers.    'B^2'  Yes", 
            "title": "Shape Errors"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#handling-errors", 
            "text": "While grading a student's input, matrix-related errors can occur in three places:   while parsing the student's input,  while evaluating the student's input, and  while comparing the student's input to the author's stored answer.", 
            "title": "Handling Errors"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#parse-errors", 
            "text": "For example, if a student enters  '[[1, 2],[3] ]' , a matrix missing an entry in second row:   grader = MatrixGrader(\n...     answers='[[1, 2], [3, 4]]',\n...     max_array_dim=2, # allow students to enter matrices entry-by-entry\n... )  student_input = '[[1, 2], [3]]'  try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     print(error) # students see this error message\nUnable to parse vector/matrix. If you're trying to enter a matrix, this is most likely caused by an unequal number of elements in each row.  Such parse errors are  always  displayed to students.", 
            "title": "Parse Errors:"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#shape-mismatch-errors-during-evaluation", 
            "text": "If a student submits an answer that will raise shape-mismatch errors then an error is raised with a helpful message. This avoids consuming one of the student's attempts. For example:   grader = MatrixGrader(\n...     answers='[11, 22, 33]',\n... )  student_input = '[10, 20, 30] + [1, 2]' # Error! Adding vectors with different shapes  try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     print(error) # students see this error message\nCannot add/subtract a vector of length 3 with a vector of length 2.  If you would rather mark the student incorrect when shape errors occur (and also consume an attempt), set  shape_errors=False .", 
            "title": "Shape-Mismatch Errors During Evaluation"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#shape-mismatch-errors-during-comparison", 
            "text": "If the author's answer is a 3-component vector, and the student submits a different 3-component vector, then they will be marked incorrect. However, if the student submits a 2-component vector or a number, they will receive an error message:   grader = MatrixGrader(\n...     answers='[1, 2, 3]',\n... )  student_input = '[1, 2, -3]' # wrong answer  result = grader(None, student_input) # grade the input like edX would  result == {'msg': '', 'grade_decimal': 0, 'ok': False}\nTrue  student_input = '[1, 2, 3, 4]' # too many components  try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     print(error) # students see this error message\nExpected answer to be a vector, but input is a vector of incorrect shape  student_input = '0' # scalar; should be a vector  try:\n...     grader(None, student_input) # grade the input like edX would\n... except StudentFacingError as error:\n...     print(error) # students see this error message\nExpected answer to be a vector, but input is a scalar  The default handling of shape errors that arise when comparing student input to author's answer is:   raise an error (do not mark student incorrect), and  reveal the desired type (above, a vector) but not the desired shape (above, 3-components)   This behavior can be configured through the  answer_shape_mismatch  key. We can choose whether an error is presented or an attempt is consumed through the  is_raised  key, while we choose whether to reveal the desired input shape or type with the  msg_detail  key. For example, to   mark students wrong instead of raising an error, and  reveal the shape and the type   we can use:   grader = MatrixGrader(\n...     answers='[1, 2, 3]',\n...     answer_shape_mismatch={\n...         'is_raised': False,\n...         'msg_detail': 'shape' # must be one of: None, 'type', 'shape'\n...     }\n... )  student_input = '0' # wrong shape  result = grader(None, student_input) # grades the input like edX would  result == {\n...   'grade_decimal': 0,\n...   'msg': 'Expected answer to be a vector of length 3, but input is a scalar',\n...   'ok': False\n... }\nTrue", 
            "title": "Shape-Mismatch Errors During Comparison"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#hiding-all-error-messages", 
            "text": "MatrixGrader s can be used to introduce non-commuting variables. In such a situation, students may not know that the variables they are using are matrices \"under the hood\", and so we want to suppress all matrix errors and messages. We can do this by setting  suppress_matrix_messages=True , which overrides  answer_shape_mismatch={'is_raised'}  and  shape_errors . In the following example,  A  and  B  are secretly matrices that don't commute, but students will never see a matrix error message from typing something like  1+A .   grader = MatrixGrader(\n...     answers='A*B',\n...     variables=['A', 'B'],\n...     sample_from={\n...         'A': RealMatrices(),\n...         'B': RealMatrices()\n...     },\n...     max_array_dim=0,\n...     suppress_matrix_messages=True\n... )  grader(None, 'A*B')['ok']\nTrue  grader(None, 'B*A')['ok']\nFalse  grader(None, 'A+1')['ok']\nFalse  Note that this will also suppress error messages from trying to do things like  sin([1, 2])  or  [1, 2]^2 . If your answer needs to take functions of the non-commuting variables, then this option is insufficient.", 
            "title": "Hiding All Error Messages"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#matrix-functions", 
            "text": "MatrixGrader  provides all the default functions of  FormulaGrader  ( sin ,  cos , etc.) plus some extras such as  trans(A)  (transpose) and  det(A)  (determinant). See  Mathematical Functions  for full list.  Since  MatrixGrader  has all of  FormulaGrader 's configuration options, additional functions can be supplied through the  user_functions  configuration key. If you supply additional matrix functions, you may wish you use the  specify_domain  decorator function to provide meaningful error messages to students. See  User Functions  for details.", 
            "title": "Matrix Functions"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#identity-matrix", 
            "text": "To make an nxn identity matrix available to students, specify the configuration key  identity_dim=n . That is, the grader  MatrixGrader(identity_dim=4, ...)  will automatically have a constant  I  whose value is the 4 by 4 identity matrix.  If you want a different name (besides  I ) for the identity, or if you encounter situations where identity matrices of different sizes are required, you can use the  identity  function. For example:   grader = MatrixGrader(\n...     answers='[1, 2, 3]',\n...     user_constants={\n...         'I_2': identity(2),  # the 2 by 2 identity\n...         'I_3': identity(3)  # the 3 by 3 identity\n...     }\n... )", 
            "title": "Identity Matrix"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#partial-credit", 
            "text": "A special  comparer  called  MatrixEntryComparer  has been built to cater for partial credit in  MatrixGrader  problems. In order to facilitate the use of  MatrixEntryComparer , if either of the following two configuration options are present,  MatrixGrader  will use  MatrixEntryComparer  as the default comparer instead of  equality_comparer .   entry_partial_credit :  proportional  or a number  entry_partial_msg : The message to display   See the documentation for  MatrixEntryComparer  for details on how these options work.", 
            "title": "Partial Credit"
        }, 
        {
            "location": "/grading_math/matrix_grader/matrix_grader/#configuration-options", 
            "text": "MatrixGrader  has all of  FormulaGrader 's configuration options, plus some extras. The extras are:   identity_dim : If specified as a positive integer  n , then an n by n identity matrix is added to the available constants with name  'I' . Defaults to  None .  max_array_dim  (nonnegative int): Controls the maximum  dimension  of arrays that students can enter entry-by-entry. Default is  1 : vectors can be entered entry-by-entry, but not matrices.  negative_powers  (bool): whether negative powers are enabled for square matrices (which calculate powers of matrix inverse). Defaults to  True .  shape_errors  (bool): See  Handling Errors: Shape-mismatch errors during evaluation . Defaults to  True .  suppress_matrix_messages  (bool): See  Hiding All Error Messages . Defaults to  False .   answer_shape_mismatch  (dict): A dictionary whose keys are listed below. Some or all keys may be set. Unset keys take default values. See  Handling Errors: Shape-mismatch errors during comparison  for details.   'is_raised'  (bool): defaults to  True  'msg_detail'  (None | 'type' | 'shape'): defaults to  'type'     entry_partial_credit : If set to  proportional  or a number, uses this setting with  MatrixEntryComparer  as the default comparer.   entry_partial_msg : If set to a text value, uses this setting with  MatrixEntryComparer  as the default comparer.", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/grading_math/sampling/", 
            "text": "Sampling\n # \n\n\nWhenever random variables/functions are involved, they need to be sampled from an appropriate distribution. In this library, distributions are defined in classes that are called \nsampling sets\n. We have defined a number of sampling sets for various common situations, but you can also create your own by using plugins.\n\n\nThese sampling classes are available for use in \nFormulaGrader\n, \nMatrixGrader\n, etc.\n\n\nVariable Sampling: Numbers (Scalars)\n # \n\n\nThese sampling sets generate a random number on demand. It may be real or complex.\n\n\nRealInterval\n # \n\n\nSample from a real interval defined by a \nstart\n and a \nstop\n value. RealInterval can be initialized using explicit values, or an interval.\n\n\n from mitxgraders import *\n\n # Generate random real numbers between 3 and 7\n\n sampler = RealInterval(start=3, stop=7)\n\n # This is equivalent to\n\n sampler = RealInterval([3, 7])\n\n # The default is [1, 5]\n\n RealInterval() == RealInterval([1, 5])\nTrue\n\n # A list can also be used to specify an interval\n\n sampler = [3, 7]\n\n\n\n\nIntegerRange\n # \n\n\nSample from an integer defined by a \nstart\n and a \nstop\n value (both start and stop are included in the range). \nIntegerRange\n can be initialized using explicit values, or an interval.\n\n\n # Generate random integers between 3 and 7 inclusive\n\n sampler = IntegerRange(start=3, stop=7)\n\n # This is equivalent to\n\n sampler = IntegerRange([3, 7])\n\n # The default is [1, 5]\n\n IntegerRange() == IntegerRange([1, 5])\nTrue\n\n\n\n\nComplexRectangle\n # \n\n\nSample complex numbers from a rectangle in the complex plane, specified by a real range and an imaginary range.\n\n\n # Select random complex numbers in a rectangle from 0 to 1 + i\n\n sampler = ComplexRectangle(re=[0, 1], im=[0, 1])\n\n # The default is re=[1, 3], im=[1, 3]\n\n ComplexRectangle() == ComplexRectangle(re=[1, 3], im=[1, 3])\nTrue\n\n\n\n\nComplexSector\n # \n\n\nSample complex numbers from an annular sector in the complex plane, specified by a modulus range and an argument range.\n\n\n import numpy as np\n\n # Select random complex numbers from inside the unit circle\n\n sampler = ComplexSector(modulus=[0, 1], argument=[-np.pi, np.pi])\n\n # The default is modulus=[1, 3], argument=[0, pi/2]\n\n ComplexSector() == ComplexSector(modulus=[1, 3], argument=[0, np.pi/2])\nTrue\n\n\n\n\nVariable Sampling: Vectors, Matrices and Tensors\n # \n\n\nWe have a broad range of sampling sets for vectors, matrices and tensors. The following options are common to many of these sets:\n\n\n\n\nshape\n: Either be a number (to specify a vector of that dimension), or a tuple or list of numbers (to specify a matrix/tensor with those dimensions).\n\n\nnorm\n: Specify a \nRealInterval\n for the norm of the object. (Frobenius norm is used.)\n\n\n\n\nIf you want to sample a vector/matrix/tensor in a way that depends on a scalar, see \nDependentSampler\n below.\n\n\nRealVectors and ComplexVectors\n # \n\n\nSample real/complex vectors with specified shape (number of components) and norm.\n\n\n # Sample real vectors with 4 components and unit norm\n\n sampler = RealVectors(shape=4, norm=[1, 1])\n\n # The default is 3 component vectors with norm from 1 to 5\n\n RealVectors() == RealVectors(shape=3, norm=[1, 5])\nTrue\n\n # Similarly for complex vectors\n\n ComplexVectors() == ComplexVectors(shape=3, norm=[1, 5])\nTrue\n\n\n\n\nRealMatrices and ComplexMatrices\n # \n\n\nSample real/complex matrices of a specific shape and norm. An extra option exists to specify that the matrix be upper or lower triangular. The given shape must be a list or tuple of two numbers.\n\n\n # Sample 3 by 2 real matrices with norm between 5 and 10\n\n sampler = RealMatrices(shape=[3, 2], norm=[5, 10])\n\n # The default is shape=[2, 2] and norm=[1, 5]\n\n RealMatrices() == RealMatrices({'norm': [1, 5], 'shape': (2, 2)})\nTrue\n\n # Similarly for complex matrices\n\n ComplexMatrices() == ComplexMatrices({'norm': [1, 5], 'shape': (2, 2)})\nTrue\n\n # Sample an upper triangular real 2x2 matrix.\n\n sampler = RealMatrices(triangular='upper')\n\n # Sample a lower triangular complex 2x2 matrix.\n\n sampler = ComplexMatrices(triangular='lower')\n\n\n\n\nRealTensors and ComplexTensors\n # \n\n\nSample real/complex tensors of a specific shape and norm. A shape must be provided as a list or tuple of three or more numbers (there is no default).\n\n\n # Sample 3x2x4 real tensors with norm between 5 and 10\n\n sampler = RealTensors(shape=[3, 2, 4], norm=[5, 10])\n\n # Sample 2x2x2x2 complex tensors with unit norm\n\n sampler = ComplexTensors(shape=[2, 2, 2, 2], norm=[1, 1])\n\n\n\n\nIdentityMatrixMultiples\n # \n\n\nSample square matrices of a given dimension consisting of the identity matrix multiplied by a scalar. The \nsampler\n parameter can be any scalar sampling set listed above. This sampling set is useful when you want a variable that will commute with other matrices, but can also be added to them.\n\n\n # Sample 3x3 matrices consisting of a random number between 1 and 3 multiplying the identity\n\n sampler = IdentityMatrixMultiples(dimension=3, sampler=[1, 3])\n\n # The default is dimension=2 and sampler=[1, 5]\n\n IdentityMatrixMultiples() == IdentityMatrixMultiples(dimension=2, sampler=[1, 5])\nTrue\n\n\n\n\nSquareMatrices\n # \n\n\nThis is a general sampling set for square matrices. A large number of options for specifying properties of square matrices are included:\n\n\n\n\ndimension\n (int): Specify the number of dimensions of the matrix (default 2)\n\n\ncomplex\n (bool): Should the matrix be complex (True) or real (False, default) (ignored if \nhermitian\n or \nantihermitian\n are selected)\n\n\ntraceless\n (bool): Whether or not the matrix should be traceless (default False)\n\n\ndeterminant\n (None | 0 | 1): Specify the determinant of the matrix (default None for no restriction)\n\n\nsymmetry\n: Choose from the following symmetries: \nNone\n, \n'diagonal'\n, \n'symmetric'\n, \n'antisymmetric'\n, \n'hermitian'\n, \n'antihermitian'\n (default \nNone\n)\n\n\nnorm\n (float): Specify a \nRealInterval\n to sample the norm of the matrix (default \n[1, 5]\n; ignored if \ndeterminant=1\n is specified)\n\n\n\n\nNote that some combinations of options do not exist (e.g., odd-dimension, unit-determinant antisymmetric matrix). If you select such a combination, an error message will result.\n\n\nOther types of square matrices can be sampled using \nRealMatrices\n, \nComplexMatrices\n, \nIdentityMatrixMultiples\n, \nOrthogonalMatrices\n and \nUnitaryMatrices\n.\n\n\nHere are a handful of examples:\n\n\n # By default, we generate real 2x2 matrices with no restrictions:\n\n SquareMatrices() == SquareMatrices(dimension=2, complex=False, traceless=False, determinant=None, symmetry=None, norm=[1,5])\nTrue\n\n\n # Diagonal, complex, traceless and unit determinant\n\n matrices = SquareMatrices(symmetry='diagonal', complex=True, traceless=True,\n...                           determinant=1)\n\n\n # Symmetric, real, zero determinant\n\n matrices = SquareMatrices(symmetry='symmetric', determinant=0)\n\n\n # Hermitian (enforces complex)\n\n matrices = SquareMatrices(symmetry='hermitian')\n\n\n\n\nOrthogonalMatrices\n # \n\n\nSample from orthogonal matrices of a given dimension. To sample special orthogonal matrices (unit determinant), use the \nunitdet=True\n option.\n\n\n # Sample 3x3 orthogonal matrices with unit determinant\n\n sampler = OrthogonalMatrices(dimension=3, unitdet=True)\n\n # The default is dimension=2 and unitdet=False\n\n OrthogonalMatrices() == OrthogonalMatrices(dimension=2, unitdet=False)\nTrue\n\n\n\n\n\n\nNote\n\n\n\n\nOrthogonal matrix sampling relies on features of newer versions of numpy and scipy than are currently available in edX. We expect this feature to be available by the end of 2019.\n\n\n\n\n\n\nUnitaryMatrices\n # \n\n\nSample from unitary matrices of a given dimension. To sample special unitary matrices (unit determinant), use the \nunitdet=True\n option.\n\n\n # Sample 3x3 unitary matrices with unit determinant\n\n sampler = UnitaryMatrices(dimension=3, unitdet=True)\n\n # The default is dimension=2 and unitdet=False\n\n UnitaryMatrices() == UnitaryMatrices(dimension=2, unitdet=False)\nTrue\n\n\n\n\n\n\nNote\n\n\n\n\nUnitary matrix sampling relies on features of newer versions of numpy and scipy than are currently available in edX. We expect this feature to be available by the end of 2019.\n\n\n\n\n\n\nVariable Sampling: Generic\n # \n\n\nDiscreteSet\n # \n\n\nSample from any discrete set of values that are specified in a tuple. A single value may also be provided, but this case should usually be specified as a constant instead of as a sampling set.\n\n\n # Select random numbers from (1, 3, 5, 7, 9)\n\n sampler = DiscreteSet((1, 3, 5, 7, 9))\n\n # Always select 3.5\n\n sampler = DiscreteSet(3.5)\n\n # A tuple can also be used to specify a discrete set\n\n sampler = (1, 3, 5, 7, 9)\n\n # Select randomly between two matrices\n\n sampler = DiscreteSet((MathArray([[1, 0], [0, 1]]), MathArray([[0, 1], [1, 0]])))\n\n\n\n\nDependentSampler\n # \n\n\nCompute a value for a variable based on the values of other constants/variables. The sampler is simply initialized with the desired formula, which can use any base or user-defined functions (except for randomly sampled functions, see below). \nDependentSampler\ns can depend on other dependent variables. If you construct a self-referential chain, an error will occur. Note that \nDependentSampler\n can depend on vector/matrix quantities as well as scalars.\n\n\n # Set radius based on the random values of x, y and z\n\n sampler = DependentSampler(formula=\nsqrt(x^2+y^2+z^2)\n)\n\n # Construct a matrix that depends on a variable\n\n sampler = DependentSampler(formula=\n[[x,0],[0,-x^2]]\n)\n\n\n\n\n\n\nNote\n\n\n\n\nPrevious versions required a list of variables that the formula depends on to be passed to \nDependentSampler\n using the \ndepends\n key. This is now obsolete, as this variable list is dynamically inferred. Anything passed to the \ndepends\n key is now ignored.\n\n\n\n\n\n\nFunction Sampling\n # \n\n\nWe have two methods for selecting a random function.\n\n\nSpecificFunctions\n # \n\n\nSamples functions from a specific list of functions. You can also specify just a single function, but usually this shouldn't be done as a sampling set.\n\n\n # Select either sin or cos randomly\n\n functionsampler = SpecificFunctions([np.cos, np.sin])\n\n # Equivalent sampling set specified as a list\n\n functionsampler = [np.cos, np.sin]\n\n # Always select a single lambda function\n\n functionsampler = SpecificFunctions(lambda x: x*x)\n\n\n\n\nRandomFunction\n # \n\n\nGenerate a random well-behaved function. The function is constructed from the sum of sinusoids with random amplitudes, frequencies and phases. It oscillates about a specified center value with up to a specified amplitude.\n\n\n # Generate a random function\n\n functionsampler = RandomFunction(center=1, amplitude=2)\n\n # The default is center=0, amplitude=10\n\n functionsampler = RandomFunction()\n\n\n\n\nYou can control how many random sinusoids are added together by specifying \nnum_terms\n.\n\n\n # Generate a random sinusoid\n\n functionsampler = RandomFunction(num_terms=1)\n\n\n\n\nYou can also generate a non-unary function by specifying the input dimension, and generate vector output by specifying the output dimension.\n\n\n # Generate a function that takes in two scalar values and outputs a 3D vector\n\n functionsampler = RandomFunction(input_dim=2, output_dim=3)\n\n\n\n\nFinally, if you want to generate a complex random function, set \ncomplex=True\n. In this situation, the randomly generated function works as previously, but the sinusoid coefficients are complex numbers.\n\n\n functionsampler = RandomFunction(complex=True)", 
            "title": "Sampling Sets"
        }, 
        {
            "location": "/grading_math/sampling/#sampling", 
            "text": "Whenever random variables/functions are involved, they need to be sampled from an appropriate distribution. In this library, distributions are defined in classes that are called  sampling sets . We have defined a number of sampling sets for various common situations, but you can also create your own by using plugins.  These sampling classes are available for use in  FormulaGrader ,  MatrixGrader , etc.", 
            "title": "Sampling"
        }, 
        {
            "location": "/grading_math/sampling/#variable-sampling-numbers-scalars", 
            "text": "These sampling sets generate a random number on demand. It may be real or complex.", 
            "title": "Variable Sampling: Numbers (Scalars)"
        }, 
        {
            "location": "/grading_math/sampling/#realinterval", 
            "text": "Sample from a real interval defined by a  start  and a  stop  value. RealInterval can be initialized using explicit values, or an interval.   from mitxgraders import *  # Generate random real numbers between 3 and 7  sampler = RealInterval(start=3, stop=7)  # This is equivalent to  sampler = RealInterval([3, 7])  # The default is [1, 5]  RealInterval() == RealInterval([1, 5])\nTrue  # A list can also be used to specify an interval  sampler = [3, 7]", 
            "title": "RealInterval"
        }, 
        {
            "location": "/grading_math/sampling/#integerrange", 
            "text": "Sample from an integer defined by a  start  and a  stop  value (both start and stop are included in the range).  IntegerRange  can be initialized using explicit values, or an interval.   # Generate random integers between 3 and 7 inclusive  sampler = IntegerRange(start=3, stop=7)  # This is equivalent to  sampler = IntegerRange([3, 7])  # The default is [1, 5]  IntegerRange() == IntegerRange([1, 5])\nTrue", 
            "title": "IntegerRange"
        }, 
        {
            "location": "/grading_math/sampling/#complexrectangle", 
            "text": "Sample complex numbers from a rectangle in the complex plane, specified by a real range and an imaginary range.   # Select random complex numbers in a rectangle from 0 to 1 + i  sampler = ComplexRectangle(re=[0, 1], im=[0, 1])  # The default is re=[1, 3], im=[1, 3]  ComplexRectangle() == ComplexRectangle(re=[1, 3], im=[1, 3])\nTrue", 
            "title": "ComplexRectangle"
        }, 
        {
            "location": "/grading_math/sampling/#complexsector", 
            "text": "Sample complex numbers from an annular sector in the complex plane, specified by a modulus range and an argument range.   import numpy as np  # Select random complex numbers from inside the unit circle  sampler = ComplexSector(modulus=[0, 1], argument=[-np.pi, np.pi])  # The default is modulus=[1, 3], argument=[0, pi/2]  ComplexSector() == ComplexSector(modulus=[1, 3], argument=[0, np.pi/2])\nTrue", 
            "title": "ComplexSector"
        }, 
        {
            "location": "/grading_math/sampling/#variable-sampling-vectors-matrices-and-tensors", 
            "text": "We have a broad range of sampling sets for vectors, matrices and tensors. The following options are common to many of these sets:   shape : Either be a number (to specify a vector of that dimension), or a tuple or list of numbers (to specify a matrix/tensor with those dimensions).  norm : Specify a  RealInterval  for the norm of the object. (Frobenius norm is used.)   If you want to sample a vector/matrix/tensor in a way that depends on a scalar, see  DependentSampler  below.", 
            "title": "Variable Sampling: Vectors, Matrices and Tensors"
        }, 
        {
            "location": "/grading_math/sampling/#realvectors-and-complexvectors", 
            "text": "Sample real/complex vectors with specified shape (number of components) and norm.   # Sample real vectors with 4 components and unit norm  sampler = RealVectors(shape=4, norm=[1, 1])  # The default is 3 component vectors with norm from 1 to 5  RealVectors() == RealVectors(shape=3, norm=[1, 5])\nTrue  # Similarly for complex vectors  ComplexVectors() == ComplexVectors(shape=3, norm=[1, 5])\nTrue", 
            "title": "RealVectors and ComplexVectors"
        }, 
        {
            "location": "/grading_math/sampling/#realmatrices-and-complexmatrices", 
            "text": "Sample real/complex matrices of a specific shape and norm. An extra option exists to specify that the matrix be upper or lower triangular. The given shape must be a list or tuple of two numbers.   # Sample 3 by 2 real matrices with norm between 5 and 10  sampler = RealMatrices(shape=[3, 2], norm=[5, 10])  # The default is shape=[2, 2] and norm=[1, 5]  RealMatrices() == RealMatrices({'norm': [1, 5], 'shape': (2, 2)})\nTrue  # Similarly for complex matrices  ComplexMatrices() == ComplexMatrices({'norm': [1, 5], 'shape': (2, 2)})\nTrue  # Sample an upper triangular real 2x2 matrix.  sampler = RealMatrices(triangular='upper')  # Sample a lower triangular complex 2x2 matrix.  sampler = ComplexMatrices(triangular='lower')", 
            "title": "RealMatrices and ComplexMatrices"
        }, 
        {
            "location": "/grading_math/sampling/#realtensors-and-complextensors", 
            "text": "Sample real/complex tensors of a specific shape and norm. A shape must be provided as a list or tuple of three or more numbers (there is no default).   # Sample 3x2x4 real tensors with norm between 5 and 10  sampler = RealTensors(shape=[3, 2, 4], norm=[5, 10])  # Sample 2x2x2x2 complex tensors with unit norm  sampler = ComplexTensors(shape=[2, 2, 2, 2], norm=[1, 1])", 
            "title": "RealTensors and ComplexTensors"
        }, 
        {
            "location": "/grading_math/sampling/#identitymatrixmultiples", 
            "text": "Sample square matrices of a given dimension consisting of the identity matrix multiplied by a scalar. The  sampler  parameter can be any scalar sampling set listed above. This sampling set is useful when you want a variable that will commute with other matrices, but can also be added to them.   # Sample 3x3 matrices consisting of a random number between 1 and 3 multiplying the identity  sampler = IdentityMatrixMultiples(dimension=3, sampler=[1, 3])  # The default is dimension=2 and sampler=[1, 5]  IdentityMatrixMultiples() == IdentityMatrixMultiples(dimension=2, sampler=[1, 5])\nTrue", 
            "title": "IdentityMatrixMultiples"
        }, 
        {
            "location": "/grading_math/sampling/#squarematrices", 
            "text": "This is a general sampling set for square matrices. A large number of options for specifying properties of square matrices are included:   dimension  (int): Specify the number of dimensions of the matrix (default 2)  complex  (bool): Should the matrix be complex (True) or real (False, default) (ignored if  hermitian  or  antihermitian  are selected)  traceless  (bool): Whether or not the matrix should be traceless (default False)  determinant  (None | 0 | 1): Specify the determinant of the matrix (default None for no restriction)  symmetry : Choose from the following symmetries:  None ,  'diagonal' ,  'symmetric' ,  'antisymmetric' ,  'hermitian' ,  'antihermitian'  (default  None )  norm  (float): Specify a  RealInterval  to sample the norm of the matrix (default  [1, 5] ; ignored if  determinant=1  is specified)   Note that some combinations of options do not exist (e.g., odd-dimension, unit-determinant antisymmetric matrix). If you select such a combination, an error message will result.  Other types of square matrices can be sampled using  RealMatrices ,  ComplexMatrices ,  IdentityMatrixMultiples ,  OrthogonalMatrices  and  UnitaryMatrices .  Here are a handful of examples:   # By default, we generate real 2x2 matrices with no restrictions:  SquareMatrices() == SquareMatrices(dimension=2, complex=False, traceless=False, determinant=None, symmetry=None, norm=[1,5])\nTrue  # Diagonal, complex, traceless and unit determinant  matrices = SquareMatrices(symmetry='diagonal', complex=True, traceless=True,\n...                           determinant=1)  # Symmetric, real, zero determinant  matrices = SquareMatrices(symmetry='symmetric', determinant=0)  # Hermitian (enforces complex)  matrices = SquareMatrices(symmetry='hermitian')", 
            "title": "SquareMatrices"
        }, 
        {
            "location": "/grading_math/sampling/#orthogonalmatrices", 
            "text": "Sample from orthogonal matrices of a given dimension. To sample special orthogonal matrices (unit determinant), use the  unitdet=True  option.   # Sample 3x3 orthogonal matrices with unit determinant  sampler = OrthogonalMatrices(dimension=3, unitdet=True)  # The default is dimension=2 and unitdet=False  OrthogonalMatrices() == OrthogonalMatrices(dimension=2, unitdet=False)\nTrue   Note   Orthogonal matrix sampling relies on features of newer versions of numpy and scipy than are currently available in edX. We expect this feature to be available by the end of 2019.", 
            "title": "OrthogonalMatrices"
        }, 
        {
            "location": "/grading_math/sampling/#unitarymatrices", 
            "text": "Sample from unitary matrices of a given dimension. To sample special unitary matrices (unit determinant), use the  unitdet=True  option.   # Sample 3x3 unitary matrices with unit determinant  sampler = UnitaryMatrices(dimension=3, unitdet=True)  # The default is dimension=2 and unitdet=False  UnitaryMatrices() == UnitaryMatrices(dimension=2, unitdet=False)\nTrue   Note   Unitary matrix sampling relies on features of newer versions of numpy and scipy than are currently available in edX. We expect this feature to be available by the end of 2019.", 
            "title": "UnitaryMatrices"
        }, 
        {
            "location": "/grading_math/sampling/#variable-sampling-generic", 
            "text": "", 
            "title": "Variable Sampling: Generic"
        }, 
        {
            "location": "/grading_math/sampling/#discreteset", 
            "text": "Sample from any discrete set of values that are specified in a tuple. A single value may also be provided, but this case should usually be specified as a constant instead of as a sampling set.   # Select random numbers from (1, 3, 5, 7, 9)  sampler = DiscreteSet((1, 3, 5, 7, 9))  # Always select 3.5  sampler = DiscreteSet(3.5)  # A tuple can also be used to specify a discrete set  sampler = (1, 3, 5, 7, 9)  # Select randomly between two matrices  sampler = DiscreteSet((MathArray([[1, 0], [0, 1]]), MathArray([[0, 1], [1, 0]])))", 
            "title": "DiscreteSet"
        }, 
        {
            "location": "/grading_math/sampling/#dependentsampler", 
            "text": "Compute a value for a variable based on the values of other constants/variables. The sampler is simply initialized with the desired formula, which can use any base or user-defined functions (except for randomly sampled functions, see below).  DependentSampler s can depend on other dependent variables. If you construct a self-referential chain, an error will occur. Note that  DependentSampler  can depend on vector/matrix quantities as well as scalars.   # Set radius based on the random values of x, y and z  sampler = DependentSampler(formula= sqrt(x^2+y^2+z^2) )  # Construct a matrix that depends on a variable  sampler = DependentSampler(formula= [[x,0],[0,-x^2]] )   Note   Previous versions required a list of variables that the formula depends on to be passed to  DependentSampler  using the  depends  key. This is now obsolete, as this variable list is dynamically inferred. Anything passed to the  depends  key is now ignored.", 
            "title": "DependentSampler"
        }, 
        {
            "location": "/grading_math/sampling/#function-sampling", 
            "text": "We have two methods for selecting a random function.", 
            "title": "Function Sampling"
        }, 
        {
            "location": "/grading_math/sampling/#specificfunctions", 
            "text": "Samples functions from a specific list of functions. You can also specify just a single function, but usually this shouldn't be done as a sampling set.   # Select either sin or cos randomly  functionsampler = SpecificFunctions([np.cos, np.sin])  # Equivalent sampling set specified as a list  functionsampler = [np.cos, np.sin]  # Always select a single lambda function  functionsampler = SpecificFunctions(lambda x: x*x)", 
            "title": "SpecificFunctions"
        }, 
        {
            "location": "/grading_math/sampling/#randomfunction", 
            "text": "Generate a random well-behaved function. The function is constructed from the sum of sinusoids with random amplitudes, frequencies and phases. It oscillates about a specified center value with up to a specified amplitude.   # Generate a random function  functionsampler = RandomFunction(center=1, amplitude=2)  # The default is center=0, amplitude=10  functionsampler = RandomFunction()  You can control how many random sinusoids are added together by specifying  num_terms .   # Generate a random sinusoid  functionsampler = RandomFunction(num_terms=1)  You can also generate a non-unary function by specifying the input dimension, and generate vector output by specifying the output dimension.   # Generate a function that takes in two scalar values and outputs a 3D vector  functionsampler = RandomFunction(input_dim=2, output_dim=3)  Finally, if you want to generate a complex random function, set  complex=True . In this situation, the randomly generated function works as previously, but the sinusoid coefficients are complex numbers.   functionsampler = RandomFunction(complex=True)", 
            "title": "RandomFunction"
        }, 
        {
            "location": "/grading_math/functions_and_constants/", 
            "text": "Mathematical Functions and Constants\n # \n\n\nFormulaGrader and NumericalGrader Default Functions\n # \n\n\n\n\nNote\n\n\nBelow, expressions marked with a * may require our \nAsciiMath renderer definitions\n to display properly in edX.\n\n\n\n\nBy default, all of the following functions are made available to students in \nFormulaGrader\n problems.\n\n\n\n\nsin(x)\n Sine\n\n\ncos(x)\n Cosine\n\n\ntan(x)\n Tangent\n\n\nsec(x)\n Secant\n\n\ncsc(x)\n Cosecant\n\n\ncot(x)\n Cotangent\n\n\nsqrt(x)\n Square Root\n\n\nlog10(x)\n Log (base 10)*\n\n\nlog2(x)\n Log (base 2)*\n\n\nln(x)\n Natural logarithm\n\n\nexp(x)\n Exponential\n\n\narccos(x)\n Inverse Cosine\n\n\narcsin(x)\n Inverse Sine\n\n\narctan(x)\n Inverse Tangent\n\n\narctan2(x, y)\n Four-quadrant Inverse Tangent*\n\n\narcsec(x)\n Inverse Secant*\n\n\narccsc(x)\n Inverse Cosecant*\n\n\narccot(x)\n Inverse Cotangent*\n\n\nabs(x)\n Absolute value (real) or modulus (complex)\n\n\nfactorial(x)\n and \nfact(x)\n Factorial*\n\n\ndomain: all complex numbers except negative integers. Large outputs may raise \nOverflowError\ns.\n\n\n\n\n\n\nsinh(x)\n Hyperbolic Sine\n\n\ncosh(x)\n Hyperbolic Cosine\n\n\ntanh(x)\n Hyperbolic Tangent\n\n\nsech(x)\n Hyperbolic Secant\n\n\ncsch(x)\n Hyperbolic Cosecant\n\n\ncoth(x)\n Hyperbolic Cotangent\n\n\narcsinh(x)\n Inverse Hyperbolic Sine*\n\n\narccosh(x)\n Inverse Hyperbolic Cosine*\n\n\narctanh(x)\n Inverse Hyperbolic Tangent*\n\n\narcsech(x)\n Inverse Hyperbolic Secant*\n\n\narccsch(x)\n Inverse Hyperbolic Cosecant*\n\n\narccoth(x)\n Inverse Hyperbolic Cotangent*\n\n\nfloor(x)\n Floor function (applies only to real numbers)\n\n\nceil(x)\n Ceiling function (applies only to real numbers)\n\n\nmin(x, y, z, ...)\n Minimum of the arguments (applies only to real numbers, 2 or more arguments)\n\n\nmax(x, y, z, ...)\n Maximum of the arguments (applies only to real numbers, 2 or more arguments)\n\n\nre(x)\n Real part of a complex expression*\n\n\nim(x)\n Imaginary part of a complex expression*\n\n\nconj(x)\n Complex conjugate of a complex expression*\n\n\nkronecker(x, y)\n Kronecker delta* (Note that we highly recommend integer sampling over a short range (eg, 1 to 4) when Kronecker deltas appear in an answer, and using many samples (eg, 30) so that most permutations appear in the sampling.)\n\n\n\n\nMatrixGrader Default Functions\n # \n\n\nIn \nMatrixGrader\n problems, all \nFormulaGrader\n functions are available by default, as are the following extra functions:\n\n\n\n\nabs(x)\n: absolute value of a scalar or magnitude of a vector\n\n\nadj(x)\n: Hermitian adjoint, same as \nctrans(x)\n*\n\n\ncross(x, y)\n: cross product, inputs must be 3-component vectors*\n\n\nctrans(x)\n: conjugate transpose, same as \nadj(x)\n*\n\n\ndet(x)\n: determinant, input must be square matrix\n\n\nnorm(x)\n: Frobenius norm, works for scalars, vectors, and matrices\n\n\ntrans(x)\n: transpose*\n\n\ntrace(x)\n: trace\n\n\n\n\nDefault Constants\n # \n\n\nAvailable in \nFormulaGrader\n, \nNumericalGrader\n, and \nMatrixGrader\n by default:\n\n\n\n\ni\n: imaginary unit (same as \nj\n)\n\n\nj\n: imaginary unit (same as \ni\n)\n\n\ne\n: approximately 2.718281828\n\n\npi\n: approximately 3.141592654\n\n\n\n\nOptional Constant Collections\n # \n\n\nWe provide a few collections of constants that can be imported for convenience and reuse. For example, \npauli\n is a dictionary with keys \nsigma_x\n, \nsigma_y\n, and \nsigma_z\n that are \nMathArray\n representations of the 2x2 Pauli matrices.\n\n\nThe collections of available mathematical constants are:\n\n\n\n\npauli\n: MathArray representations of the 2x2 Pauli matrices, \nsigma_x\n, \nsigma_y\n, and \nsigma_z\n\n\ncartesian_xyz\n: MathArray representations of the three-dimensional Cartesian unit vectors, named \nhatx\n, \nhaty\n, \nhatz\n\n\ncartesian_ijk\n: MathArray representations of the three-dimensional Cartesian unit vectors, named \nhati\n, \nhatj\n, \nhatk\n\n\n\n\nEach collection is a dictionary that can be provided as a value of \nuser_constants\n:\n\n\n from mitxgraders import *\n\n grader = MatrixGrader(\n...   answers='sigma_x + sigma_z',\n...   user_constants=pauli\n... )", 
            "title": "Functions and Constants List"
        }, 
        {
            "location": "/grading_math/functions_and_constants/#mathematical-functions-and-constants", 
            "text": "", 
            "title": "Mathematical Functions and Constants"
        }, 
        {
            "location": "/grading_math/functions_and_constants/#formulagrader-and-numericalgrader-default-functions", 
            "text": "Note  Below, expressions marked with a * may require our  AsciiMath renderer definitions  to display properly in edX.   By default, all of the following functions are made available to students in  FormulaGrader  problems.   sin(x)  Sine  cos(x)  Cosine  tan(x)  Tangent  sec(x)  Secant  csc(x)  Cosecant  cot(x)  Cotangent  sqrt(x)  Square Root  log10(x)  Log (base 10)*  log2(x)  Log (base 2)*  ln(x)  Natural logarithm  exp(x)  Exponential  arccos(x)  Inverse Cosine  arcsin(x)  Inverse Sine  arctan(x)  Inverse Tangent  arctan2(x, y)  Four-quadrant Inverse Tangent*  arcsec(x)  Inverse Secant*  arccsc(x)  Inverse Cosecant*  arccot(x)  Inverse Cotangent*  abs(x)  Absolute value (real) or modulus (complex)  factorial(x)  and  fact(x)  Factorial*  domain: all complex numbers except negative integers. Large outputs may raise  OverflowError s.    sinh(x)  Hyperbolic Sine  cosh(x)  Hyperbolic Cosine  tanh(x)  Hyperbolic Tangent  sech(x)  Hyperbolic Secant  csch(x)  Hyperbolic Cosecant  coth(x)  Hyperbolic Cotangent  arcsinh(x)  Inverse Hyperbolic Sine*  arccosh(x)  Inverse Hyperbolic Cosine*  arctanh(x)  Inverse Hyperbolic Tangent*  arcsech(x)  Inverse Hyperbolic Secant*  arccsch(x)  Inverse Hyperbolic Cosecant*  arccoth(x)  Inverse Hyperbolic Cotangent*  floor(x)  Floor function (applies only to real numbers)  ceil(x)  Ceiling function (applies only to real numbers)  min(x, y, z, ...)  Minimum of the arguments (applies only to real numbers, 2 or more arguments)  max(x, y, z, ...)  Maximum of the arguments (applies only to real numbers, 2 or more arguments)  re(x)  Real part of a complex expression*  im(x)  Imaginary part of a complex expression*  conj(x)  Complex conjugate of a complex expression*  kronecker(x, y)  Kronecker delta* (Note that we highly recommend integer sampling over a short range (eg, 1 to 4) when Kronecker deltas appear in an answer, and using many samples (eg, 30) so that most permutations appear in the sampling.)", 
            "title": "FormulaGrader and NumericalGrader Default Functions"
        }, 
        {
            "location": "/grading_math/functions_and_constants/#matrixgrader-default-functions", 
            "text": "In  MatrixGrader  problems, all  FormulaGrader  functions are available by default, as are the following extra functions:   abs(x) : absolute value of a scalar or magnitude of a vector  adj(x) : Hermitian adjoint, same as  ctrans(x) *  cross(x, y) : cross product, inputs must be 3-component vectors*  ctrans(x) : conjugate transpose, same as  adj(x) *  det(x) : determinant, input must be square matrix  norm(x) : Frobenius norm, works for scalars, vectors, and matrices  trans(x) : transpose*  trace(x) : trace", 
            "title": "MatrixGrader Default Functions"
        }, 
        {
            "location": "/grading_math/functions_and_constants/#default-constants", 
            "text": "Available in  FormulaGrader ,  NumericalGrader , and  MatrixGrader  by default:   i : imaginary unit (same as  j )  j : imaginary unit (same as  i )  e : approximately 2.718281828  pi : approximately 3.141592654", 
            "title": "Default Constants"
        }, 
        {
            "location": "/grading_math/functions_and_constants/#optional-constant-collections", 
            "text": "We provide a few collections of constants that can be imported for convenience and reuse. For example,  pauli  is a dictionary with keys  sigma_x ,  sigma_y , and  sigma_z  that are  MathArray  representations of the 2x2 Pauli matrices.  The collections of available mathematical constants are:   pauli : MathArray representations of the 2x2 Pauli matrices,  sigma_x ,  sigma_y , and  sigma_z  cartesian_xyz : MathArray representations of the three-dimensional Cartesian unit vectors, named  hatx ,  haty ,  hatz  cartesian_ijk : MathArray representations of the three-dimensional Cartesian unit vectors, named  hati ,  hatj ,  hatk   Each collection is a dictionary that can be provided as a value of  user_constants :   from mitxgraders import *  grader = MatrixGrader(\n...   answers='sigma_x + sigma_z',\n...   user_constants=pauli\n... )", 
            "title": "Optional Constant Collections"
        }, 
        {
            "location": "/grading_math/user_functions/", 
            "text": "User-Defined Functions: Arguments, Shapes, and Error Messages\n # \n\n\nIt's possible to construct user-defined functions that take in scalar/vector/matrix arguments, and produce a scalar/vector/matrix appropriately.\n\n\nExample\n # \n\n\nSuppose we have a \nMatrixGrader\n problem in which we want to provide students with a function \nrot(vector, axis, angle)\n that rotates a vector about a given axis by a given angle. We can provide such a function with the \nuser_functions\n configuration key.\n\n\n import numpy as np\n\n from mitxgraders import *\n\n\n def rot(vec, axis, angle):\n...     \n\n...     Rotate vec by angle around axis. Implemented by Euler-Rodrigues formula:\n...     https://en.wikipedia.org/wiki/Euler-Rodrigues_formula\n...\n...     Arguments:\n...         vec: a 3-component MathArray to rotate\n...         axis: a 3-component MathArray to rotate around\n...         angle: a number\n...     \n\n...     vec = np.array(vec)\n...     unit_axis = np.array(axis)/np.linalg.norm(axis)\n...     a = np.cos(angle/2)\n...     omega = unit_axis * np.sin(angle/2)\n...     crossed = np.cross(omega, vec)\n...     result = vec + 2*a*crossed + 2*np.cross(omega, crossed)\n...     return MathArray(result)\n\n\n grader_1 = MatrixGrader(\n...    answers='rot(v, [0, 0, 1], theta)',\n...    variables=['v', 'theta'],\n...    sample_from={\n...        'v': RealVectors(shape=3),\n...    },\n...    user_functions={\n...        'rot': rot\n...    }\n... )\n\n\n\n\nThe Problem\n # \n\n\nOur \nrot(vec, axis, angle)\n function works, but if students supply the function above with arguments of incorrect type, they receive unhelpful error messages:\n\n\n try:\n...     grader_1(None, 'rot(v, theta, [0, 0, 1])')\n... except StudentFacingError as error:\n...     print(error)\nThere was an error evaluating rot(...). Its input does not seem to be in its domain.\n\n\n\n\nThe Solution\n # \n\n\nTo provide students with more useful error messages, we can use \nspecify_domain\n, a decorator function imported from \nmitxgraders\n. \nDecorator Functions\n are \"higher-order functions\" that take functions as input and produce functions as output, usually modifying the input function's behavior. In our case, \nspecify_domain\n will modify the behavior of \nrot\n so as to provide more helpful \nStudentFacingError\ns.\n\n\nHere we go:\n\n\n @specify_domain(input_shapes=[[3], [3], [1]], display_name='rot')\n... def rot_with_error_messages(vec, axis, angle):\n...     # rot(vec, axis, angle) defined above\n...     return rot(vec, axis, angle)\n\n\n # Define new grader using rot_with_error_messages\n\n grader_2 = MatrixGrader(\n...    answers='rot(v, [0, 0, 1], theta)',\n...    variables=['v', 'theta'],\n...    sample_from={\n...        'v': RealVectors(shape=3),\n...    },\n...    user_functions={\n...        'rot': rot_with_error_messages\n...    }\n... )\n\n\n\n\nNow if a student calls \nrot\n with incorrect inputs, they receive a more helpful message:\n\n\n try:\n...     grader_2(None, 'rot(v, theta, [0, 0, 1])')\n... except StudentFacingError as error:\n...     print(str(error).replace('\nbr/\n', '\\n'))\nThere was an error evaluating function rot(...)\n1st input is ok: received a vector of length 3 as expected\n2nd input has an error: received a scalar, expected a vector of length 3\n3rd input has an error: received a vector of length 3, expected a scalar\n\n\n\n\nConfiguring specify_domain\n # \n\n\nThe decorator \nspecify_domain\n accepts optional keyword arguments and should be called in either of two equivalent ways:\n\n\n @specify_domain(keyword_arguments)                # doctest: +SKIP\n... def target_function(x, y, z):\n...     pass # do whatever you want\n\n # or, equivalently:\n\n def target_function(x, y ,z):\n...     pass # do whatever you want\n\n decorated_function = specify_domain(keyword_arguments)(target_function) # doctest: +SKIP\n\n\n\n\nThe keyword arguments are:\n\n\n\n\ninput_shapes\n: A list that indicates the shape of each input to the target function. This list \nmust\n have the same length as the number of arguments in the target function. Each list element should be one of the following:\n\n\n1\n: indicates input is scalar\n\n\nk\n (positive integer \n 1): indicates input is a k-component vector\n\n\n[k1, k2, ...]\n, list of positive integers: means input is an array of shape (k1, k2, ...)\n\n\n(k1, k2, ...)\n, tuple of positive integers: equivalent to \n[k1, k2, ...]\n\n\n'square'\n (string): indicates a square matrix of any dimension\n\n\n\n\n\n\ndisplay_name\n (str): Function name to be used in error messages.\n    Defaults to \nNone\n, meaning that the function's \n__name__\n attribute is used.\n\n\n\n\nSo, for example,\n\n\n @specify_domain(input_shapes=[1, [3, 2], 4], display_name='myfunc')\n... def some_function(x, A, v):\n...     pass\n\n\n\n\nspecifies that the function \nsome_func\n must be called with three arguments:\n\n\n\n\n1st argument: scalar,\n\n\n2nd argument: 3 by 2 matrix, and a\n\n\n3rd argument: 4-component vector.\n\n\n\n\nArbitrary Same-Shape Arguments\n # \n\n\nSome functions may allow an arbitrary number of arguments to be passed in. For example, consider a user-defined minimum function:\n\n\n def my_min(*args):\n...     return min(*args)\n\n\n\n\nTo inform \nspecify_domain\n that a function should accept arbitrarily many arguments of a certain shape, supply a single shape to \ninput_shapes\n, and also pass in a \nmin_length\n parameter, to specify the minimum number of arguments required. (If you specify \nmin_length\n and have more than one shape in \ninput_shapes\n, a \nConfigError\n will result.) So, our \nmy_min\n function can be decorated as follows:\n\n\n @specify_domain(input_shapes=[1], display_name='min', min_length=2)\n... def my_min(*args):\n...     return min(*args)\n\n my_min(1.5, 2.3, 4.6)\n1.5\n\n try:\n...     my_min(1)\n... except StudentFacingError as error:\n...     print(error)\nWrong number of arguments passed to min(...): Expected at least 2 inputs, but received 1.\n\n try:\n...     my_min(MathArray([1, 2]), MathArray([3, 4]))\n... except StudentFacingError as error:\n...     print(error)\nThere was an error evaluating function min(...)\n1st input has an error: received a vector of length 2, expected a scalar\n2nd input has an error: received a vector of length 2, expected a scalar", 
            "title": "User-Defined Functions"
        }, 
        {
            "location": "/grading_math/user_functions/#user-defined-functions-arguments-shapes-and-error-messages", 
            "text": "It's possible to construct user-defined functions that take in scalar/vector/matrix arguments, and produce a scalar/vector/matrix appropriately.", 
            "title": "User-Defined Functions: Arguments, Shapes, and Error Messages"
        }, 
        {
            "location": "/grading_math/user_functions/#example", 
            "text": "Suppose we have a  MatrixGrader  problem in which we want to provide students with a function  rot(vector, axis, angle)  that rotates a vector about a given axis by a given angle. We can provide such a function with the  user_functions  configuration key.   import numpy as np  from mitxgraders import *  def rot(vec, axis, angle):\n...      \n...     Rotate vec by angle around axis. Implemented by Euler-Rodrigues formula:\n...     https://en.wikipedia.org/wiki/Euler-Rodrigues_formula\n...\n...     Arguments:\n...         vec: a 3-component MathArray to rotate\n...         axis: a 3-component MathArray to rotate around\n...         angle: a number\n...      \n...     vec = np.array(vec)\n...     unit_axis = np.array(axis)/np.linalg.norm(axis)\n...     a = np.cos(angle/2)\n...     omega = unit_axis * np.sin(angle/2)\n...     crossed = np.cross(omega, vec)\n...     result = vec + 2*a*crossed + 2*np.cross(omega, crossed)\n...     return MathArray(result)  grader_1 = MatrixGrader(\n...    answers='rot(v, [0, 0, 1], theta)',\n...    variables=['v', 'theta'],\n...    sample_from={\n...        'v': RealVectors(shape=3),\n...    },\n...    user_functions={\n...        'rot': rot\n...    }\n... )", 
            "title": "Example"
        }, 
        {
            "location": "/grading_math/user_functions/#the-problem", 
            "text": "Our  rot(vec, axis, angle)  function works, but if students supply the function above with arguments of incorrect type, they receive unhelpful error messages:   try:\n...     grader_1(None, 'rot(v, theta, [0, 0, 1])')\n... except StudentFacingError as error:\n...     print(error)\nThere was an error evaluating rot(...). Its input does not seem to be in its domain.", 
            "title": "The Problem"
        }, 
        {
            "location": "/grading_math/user_functions/#the-solution", 
            "text": "To provide students with more useful error messages, we can use  specify_domain , a decorator function imported from  mitxgraders .  Decorator Functions  are \"higher-order functions\" that take functions as input and produce functions as output, usually modifying the input function's behavior. In our case,  specify_domain  will modify the behavior of  rot  so as to provide more helpful  StudentFacingError s.  Here we go:   @specify_domain(input_shapes=[[3], [3], [1]], display_name='rot')\n... def rot_with_error_messages(vec, axis, angle):\n...     # rot(vec, axis, angle) defined above\n...     return rot(vec, axis, angle)  # Define new grader using rot_with_error_messages  grader_2 = MatrixGrader(\n...    answers='rot(v, [0, 0, 1], theta)',\n...    variables=['v', 'theta'],\n...    sample_from={\n...        'v': RealVectors(shape=3),\n...    },\n...    user_functions={\n...        'rot': rot_with_error_messages\n...    }\n... )  Now if a student calls  rot  with incorrect inputs, they receive a more helpful message:   try:\n...     grader_2(None, 'rot(v, theta, [0, 0, 1])')\n... except StudentFacingError as error:\n...     print(str(error).replace(' br/ ', '\\n'))\nThere was an error evaluating function rot(...)\n1st input is ok: received a vector of length 3 as expected\n2nd input has an error: received a scalar, expected a vector of length 3\n3rd input has an error: received a vector of length 3, expected a scalar", 
            "title": "The Solution"
        }, 
        {
            "location": "/grading_math/user_functions/#configuring-specify_domain", 
            "text": "The decorator  specify_domain  accepts optional keyword arguments and should be called in either of two equivalent ways:   @specify_domain(keyword_arguments)                # doctest: +SKIP\n... def target_function(x, y, z):\n...     pass # do whatever you want  # or, equivalently:  def target_function(x, y ,z):\n...     pass # do whatever you want  decorated_function = specify_domain(keyword_arguments)(target_function) # doctest: +SKIP  The keyword arguments are:   input_shapes : A list that indicates the shape of each input to the target function. This list  must  have the same length as the number of arguments in the target function. Each list element should be one of the following:  1 : indicates input is scalar  k  (positive integer   1): indicates input is a k-component vector  [k1, k2, ...] , list of positive integers: means input is an array of shape (k1, k2, ...)  (k1, k2, ...) , tuple of positive integers: equivalent to  [k1, k2, ...]  'square'  (string): indicates a square matrix of any dimension    display_name  (str): Function name to be used in error messages.\n    Defaults to  None , meaning that the function's  __name__  attribute is used.   So, for example,   @specify_domain(input_shapes=[1, [3, 2], 4], display_name='myfunc')\n... def some_function(x, A, v):\n...     pass  specifies that the function  some_func  must be called with three arguments:   1st argument: scalar,  2nd argument: 3 by 2 matrix, and a  3rd argument: 4-component vector.", 
            "title": "Configuring specify_domain"
        }, 
        {
            "location": "/grading_math/user_functions/#arbitrary-same-shape-arguments", 
            "text": "Some functions may allow an arbitrary number of arguments to be passed in. For example, consider a user-defined minimum function:   def my_min(*args):\n...     return min(*args)  To inform  specify_domain  that a function should accept arbitrarily many arguments of a certain shape, supply a single shape to  input_shapes , and also pass in a  min_length  parameter, to specify the minimum number of arguments required. (If you specify  min_length  and have more than one shape in  input_shapes , a  ConfigError  will result.) So, our  my_min  function can be decorated as follows:   @specify_domain(input_shapes=[1], display_name='min', min_length=2)\n... def my_min(*args):\n...     return min(*args)  my_min(1.5, 2.3, 4.6)\n1.5  try:\n...     my_min(1)\n... except StudentFacingError as error:\n...     print(error)\nWrong number of arguments passed to min(...): Expected at least 2 inputs, but received 1.  try:\n...     my_min(MathArray([1, 2]), MathArray([3, 4]))\n... except StudentFacingError as error:\n...     print(error)\nThere was an error evaluating function min(...)\n1st input has an error: received a vector of length 2, expected a scalar\n2nd input has an error: received a vector of length 2, expected a scalar", 
            "title": "Arbitrary Same-Shape Arguments"
        }, 
        {
            "location": "/grading_math/comparer_functions/", 
            "text": "Comparer Functions\n # \n\n\nBy default, \nFormulaGrader\n, \nNumericalGrader\n, and \nMatrixGrader\n compare the numerically-sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. Functions that perform the actual comparison are called \"comparers\", and there are a few ways to invoke them.\n\n\nEmploying Comparer Functions\n # \n\n\nWhen an answer is passed into \nFormulaGrader\n, \nNumericalGrader\n or \nMatrixGrader\n, it is automatically paired up with a comparer. For example, the default comparer is \nequality_comparer\n. When you construct a grader like the following,\n\n\n from mitxgraders import *\n\n grader1 = FormulaGrader(\n...     answers='a+b',\n...     variables=['a', 'b']\n... )\n\n\n\n\nFormulaGrader\n automatically converts the \nanswers\n key to the following:\n\n\n grader2 = FormulaGrader(\n...     answers={\n...         'expect': {'comparer': equality_comparer, 'comparer_params': ['a+b']},\n...         'grade_decimal': 1,\n...         'msg': ''\n...     },\n...     variables=['a', 'b']\n... )\n\n grader1 == grader2\nTrue\n\n\n\n\nTo specify an alternate comparer, you can simply change the relevant answer to a dictionary \n{'comparer': comparer_func, 'comparer_params': [list, of, params]}\n. Different comparers use \ncomparer_params\n in different ways.\n\n\nFor example, if grading angles in degrees, it may be useful to compare formulas modulo 2\n. You can write your own comparer functions, but for this we can use the pre-built \ncongruent_modulo\n comparer. This grader will accept any input congruent to \n'b^2/a'\n modulo \n2*pi\n.\n\n\n grader = FormulaGrader(\n...     answers={\n...         'comparer': congruence_comparer,\n...         # first parameter is expected value, second is the modulus\n...         'comparer_params': ['b^2/a', '2*pi']\n...     },\n...     variables=['a', 'b']\n... )\n\n grader(None, 'b^2/a + 6*pi')['ok']\nTrue\n\n grader(None, 'b^2/a + 5.5*pi')['ok']\nFalse\n\n\n\n\nHere, the \ncomparer_params\n (\n['b^2/a', '2*pi']\n) are evaluated just like the student input, and used by the comparer function during grading.\n\n\nChanging Defaults\n # \n\n\nThe default comparer function for each of \nFormulaGrader\n, \nNumericalGrader\n and \nMatrixGrader\n can be set by calling \nset_default_comparer\n as follows:\n\n\n FormulaGrader.set_default_comparer(LinearComparer())\n\n\n\n\nThis sets the default comparer to \nLinearComparer()\n (see below) for all \nFormulaGrader\ns in the given problem. Comparers set in this manner must only take a single comparer parameter. Using this default set approach is typically simpler than setting comparers explicitly, and allows answers to be inferred from \nexpect\n values. However, comparers that require two or more \ncomparer_params\n cannot use this method.\n\n\nIf for some reason you need to reset the default comparer, you can use\n\n\n FormulaGrader.reset_default_comparer()\n\n\n\n\nwhich is equivalent to setting the default comparer to \nequality_comparer\n.\n\n\nAvailable Comparers\n # \n\n\nThe table below lists the pre-built comparers along with the expected comparer parameters. Note that \ncomparer_params\n is \nalways\n a list of strings, and can use any variables available to the student. When using an ordered \nListGrader\n, they can also use sibling values.\n\n\n\n\n\n\n\n\ncomparer\n\n\nuse with\n\n\ncomparer_params\n \n (a list of strings)\n\n\npurpose\n\n\n\n\n\n\n\n\n\n\nequality_comparer\n\n\nFormulaGrader\n \n \nNumericalGrader\n \n \nMatrixGrader\n\n\n[expected]\n\n\nchecks that student input and \nexpected\n differ by less than grader's tolerance.\n\n\n\n\n\n\ncongruence_comparer\n\n\nFormulaGrader\n \n \nNumericalGrader\n\n\n[expected, modulus]\n\n\nreduces student input modulo modulus, then checks for equality within grader's tolerance.\n\n\n\n\n\n\nbetween_comparer\n\n\nFormulaGrader\n \n \nNumericalGrader\n\n\n[start, stop]\n\n\nchecks that student input is real and between \nstart\n and \nstop\n.\n\n\n\n\n\n\neigenvector_comparer\n\n\nMatrixGrader\n\n\n[matrix, eigenvalue]\n\n\nchecks that student input is an eigenvector of \nmatrix\n with eigenvalue \neigenvalue\n within grader's tolerance.\n\n\n\n\n\n\nvector_phase_comparer\n\n\nMatrixGrader\n\n\n[comparison_vector]\n\n\nchecks that student input is equal to \ncomparison_vector\n up to a phase, within grader's tolerance.\n\n\n\n\n\n\nvector_span_comparer\n\n\nMatrixGrader\n\n\n[vector1, vector2, ...]\n\n\nchecks that student input is nonzero and in the span of the given list of vectors, within grader's tolerance. If only a single vector is given, checks if the student input is equal to the given vector up to a (possibly complex) constant of proportionality.\n\n\n\n\n\n\n\n\nAll of these comparers (as well as the ones below) are available when using \nfrom mitxgraders import *\n.\n\n\nSpecial Comparers\n # \n\n\nThere are three special built-in comparer classes that can be used as comparers that take in a single input.\n\n\nEqualityComparer\n # \n\n\nThe \nEqualityComparer\n class simply checks for equality up to tolerance. In fact, \nequality_comparer = EqualityComparer()\n. The reason this class exists, however, is to allow for an extra option to be used when desired.\n\n\nThe \ntransform\n option allows the author to specify a transforming function to be called on both the answer and the student input prior to comparison. Here is an example:\n\n\n import numpy as np\n\n comparer = EqualityComparer(transform=np.real)\n\n\n\n\nThis comparer will take the real part of the answer and the student input before comparing the results. This is useful if only the real part of the answers need to agree.\n\n\nLinearComparer\n # \n\n\nThe \nLinearComparer\n checks if the student's answer is linearly related to the problem's answer, and can provide partial credit as appropriate. Here are all of the options:\n\n\ncomparer = LinearComparer(\n    equals=float,  # default 1\n    proportional=(None | float),  # default 0.5\n    offset=(None | float),  # default None\n    linear=(None | float),  # default None\n    equals_msg=(None | str),  # default None\n    proportional_msg=(None | str),  # default 'The submitted answer differs from an expected answer by a constant factor.'\n    offset_msg=(None | str),  # default None\n    linear_msg=(None | str),  # default None\n)\n\n\n\n\nThe first four settings specify how much credit to award the different situations, while the next four describe a message to display when that credit is awarded. Note that setting credit to \nNone\n means that that type of credit will never be awarded, while setting credit to \n0\n means that it can be awarded (usually to display the relevant message). When the grading is performed, the largest credit of the available settings is awarded.\n\n\nHere is an example of a \nLinearComparer\n that can be used to award partial credit if students are off from the answer by a constant multiple.\n\n\n comparer = LinearComparer()\n\n\n\n\nEasy, isn't it? You can combine this with \nset_default_comparer\n to enable partial credit of this sort with one line in each problem!\n\n\nHere is an example of setting up a \nLinearComparer\n that doesn't care about shift offsets (useful when describing indefinite integration).\n\n\n comparer = LinearComparer(proportional=None, linear=1)\n\n\n\n\nNote that \nLinearComparer\n can only perform meaningful comparisons when random variables are used. If the answer is a numerical constant, then student answers will always be proportional to that constant, which probably isn't the desired behavior. Also note that when the answer is zero or the student supplies zero as their answer, partial credit cannot be assigned.\n\n\nMatrixEntryComparer\n # \n\n\nThis comparer is used only for \nMatrixGrader\ns. It has a \ntransform\n option that is exactly equivalent to \nEqualityComparer\n, but it also has two options related to partial credit.\n\n\ncomparer = MatrixEntryComparer(\n    transform=(None | func),  # default None\n    entry_partial_credit=('proportional' | float),  # default 0\n    entry_partial_msg=str,  # default \nSome array entries are incorrect, marked below:\\n{error_locations}\n\n)\n\n\n\n\nWhen \nentry_partial_credit\n is set to a number, if at least one entry in the array is correct (but not all of them), that amount of credit is assigned. When partial credit is assigned, the message \nentry_partial_msg\n is displayed to the student, with the text \n{error_locations}\n replaced by a graphic displaying which entries are correct/incorrect. To turn off the message, simply set \nentry_partial_msg=''\n. Setting \nentry_partial_msg=''\n and \nentry_partial_credit=0\n makes this grader equivalent to \nEqualityComparer\n.\n\n\nBecause this ability to assign partial credit to array input is so useful, \nMatrixEntryComparer\n can be set as the grader for \nMatrixGrader\ns using configuration options.\n\n\nCustom Comparer Functions\n # \n\n\nIn addition to using the built-in comparers, you can write your own.\n\n\nSee \ncomparers.py\n for documentation and examples.", 
            "title": "Comparer Functions"
        }, 
        {
            "location": "/grading_math/comparer_functions/#comparer-functions", 
            "text": "By default,  FormulaGrader ,  NumericalGrader , and  MatrixGrader  compare the numerically-sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. Functions that perform the actual comparison are called \"comparers\", and there are a few ways to invoke them.", 
            "title": "Comparer Functions"
        }, 
        {
            "location": "/grading_math/comparer_functions/#employing-comparer-functions", 
            "text": "When an answer is passed into  FormulaGrader ,  NumericalGrader  or  MatrixGrader , it is automatically paired up with a comparer. For example, the default comparer is  equality_comparer . When you construct a grader like the following,   from mitxgraders import *  grader1 = FormulaGrader(\n...     answers='a+b',\n...     variables=['a', 'b']\n... )  FormulaGrader  automatically converts the  answers  key to the following:   grader2 = FormulaGrader(\n...     answers={\n...         'expect': {'comparer': equality_comparer, 'comparer_params': ['a+b']},\n...         'grade_decimal': 1,\n...         'msg': ''\n...     },\n...     variables=['a', 'b']\n... )  grader1 == grader2\nTrue  To specify an alternate comparer, you can simply change the relevant answer to a dictionary  {'comparer': comparer_func, 'comparer_params': [list, of, params]} . Different comparers use  comparer_params  in different ways.  For example, if grading angles in degrees, it may be useful to compare formulas modulo 2 . You can write your own comparer functions, but for this we can use the pre-built  congruent_modulo  comparer. This grader will accept any input congruent to  'b^2/a'  modulo  2*pi .   grader = FormulaGrader(\n...     answers={\n...         'comparer': congruence_comparer,\n...         # first parameter is expected value, second is the modulus\n...         'comparer_params': ['b^2/a', '2*pi']\n...     },\n...     variables=['a', 'b']\n... )  grader(None, 'b^2/a + 6*pi')['ok']\nTrue  grader(None, 'b^2/a + 5.5*pi')['ok']\nFalse  Here, the  comparer_params  ( ['b^2/a', '2*pi'] ) are evaluated just like the student input, and used by the comparer function during grading.", 
            "title": "Employing Comparer Functions"
        }, 
        {
            "location": "/grading_math/comparer_functions/#changing-defaults", 
            "text": "The default comparer function for each of  FormulaGrader ,  NumericalGrader  and  MatrixGrader  can be set by calling  set_default_comparer  as follows:   FormulaGrader.set_default_comparer(LinearComparer())  This sets the default comparer to  LinearComparer()  (see below) for all  FormulaGrader s in the given problem. Comparers set in this manner must only take a single comparer parameter. Using this default set approach is typically simpler than setting comparers explicitly, and allows answers to be inferred from  expect  values. However, comparers that require two or more  comparer_params  cannot use this method.  If for some reason you need to reset the default comparer, you can use   FormulaGrader.reset_default_comparer()  which is equivalent to setting the default comparer to  equality_comparer .", 
            "title": "Changing Defaults"
        }, 
        {
            "location": "/grading_math/comparer_functions/#available-comparers", 
            "text": "The table below lists the pre-built comparers along with the expected comparer parameters. Note that  comparer_params  is  always  a list of strings, and can use any variables available to the student. When using an ordered  ListGrader , they can also use sibling values.     comparer  use with  comparer_params    (a list of strings)  purpose      equality_comparer  FormulaGrader     NumericalGrader     MatrixGrader  [expected]  checks that student input and  expected  differ by less than grader's tolerance.    congruence_comparer  FormulaGrader     NumericalGrader  [expected, modulus]  reduces student input modulo modulus, then checks for equality within grader's tolerance.    between_comparer  FormulaGrader     NumericalGrader  [start, stop]  checks that student input is real and between  start  and  stop .    eigenvector_comparer  MatrixGrader  [matrix, eigenvalue]  checks that student input is an eigenvector of  matrix  with eigenvalue  eigenvalue  within grader's tolerance.    vector_phase_comparer  MatrixGrader  [comparison_vector]  checks that student input is equal to  comparison_vector  up to a phase, within grader's tolerance.    vector_span_comparer  MatrixGrader  [vector1, vector2, ...]  checks that student input is nonzero and in the span of the given list of vectors, within grader's tolerance. If only a single vector is given, checks if the student input is equal to the given vector up to a (possibly complex) constant of proportionality.     All of these comparers (as well as the ones below) are available when using  from mitxgraders import * .", 
            "title": "Available Comparers"
        }, 
        {
            "location": "/grading_math/comparer_functions/#special-comparers", 
            "text": "There are three special built-in comparer classes that can be used as comparers that take in a single input.", 
            "title": "Special Comparers"
        }, 
        {
            "location": "/grading_math/comparer_functions/#equalitycomparer", 
            "text": "The  EqualityComparer  class simply checks for equality up to tolerance. In fact,  equality_comparer = EqualityComparer() . The reason this class exists, however, is to allow for an extra option to be used when desired.  The  transform  option allows the author to specify a transforming function to be called on both the answer and the student input prior to comparison. Here is an example:   import numpy as np  comparer = EqualityComparer(transform=np.real)  This comparer will take the real part of the answer and the student input before comparing the results. This is useful if only the real part of the answers need to agree.", 
            "title": "EqualityComparer"
        }, 
        {
            "location": "/grading_math/comparer_functions/#linearcomparer", 
            "text": "The  LinearComparer  checks if the student's answer is linearly related to the problem's answer, and can provide partial credit as appropriate. Here are all of the options:  comparer = LinearComparer(\n    equals=float,  # default 1\n    proportional=(None | float),  # default 0.5\n    offset=(None | float),  # default None\n    linear=(None | float),  # default None\n    equals_msg=(None | str),  # default None\n    proportional_msg=(None | str),  # default 'The submitted answer differs from an expected answer by a constant factor.'\n    offset_msg=(None | str),  # default None\n    linear_msg=(None | str),  # default None\n)  The first four settings specify how much credit to award the different situations, while the next four describe a message to display when that credit is awarded. Note that setting credit to  None  means that that type of credit will never be awarded, while setting credit to  0  means that it can be awarded (usually to display the relevant message). When the grading is performed, the largest credit of the available settings is awarded.  Here is an example of a  LinearComparer  that can be used to award partial credit if students are off from the answer by a constant multiple.   comparer = LinearComparer()  Easy, isn't it? You can combine this with  set_default_comparer  to enable partial credit of this sort with one line in each problem!  Here is an example of setting up a  LinearComparer  that doesn't care about shift offsets (useful when describing indefinite integration).   comparer = LinearComparer(proportional=None, linear=1)  Note that  LinearComparer  can only perform meaningful comparisons when random variables are used. If the answer is a numerical constant, then student answers will always be proportional to that constant, which probably isn't the desired behavior. Also note that when the answer is zero or the student supplies zero as their answer, partial credit cannot be assigned.", 
            "title": "LinearComparer"
        }, 
        {
            "location": "/grading_math/comparer_functions/#matrixentrycomparer", 
            "text": "This comparer is used only for  MatrixGrader s. It has a  transform  option that is exactly equivalent to  EqualityComparer , but it also has two options related to partial credit.  comparer = MatrixEntryComparer(\n    transform=(None | func),  # default None\n    entry_partial_credit=('proportional' | float),  # default 0\n    entry_partial_msg=str,  # default  Some array entries are incorrect, marked below:\\n{error_locations} \n)  When  entry_partial_credit  is set to a number, if at least one entry in the array is correct (but not all of them), that amount of credit is assigned. When partial credit is assigned, the message  entry_partial_msg  is displayed to the student, with the text  {error_locations}  replaced by a graphic displaying which entries are correct/incorrect. To turn off the message, simply set  entry_partial_msg='' . Setting  entry_partial_msg=''  and  entry_partial_credit=0  makes this grader equivalent to  EqualityComparer .  Because this ability to assign partial credit to array input is so useful,  MatrixEntryComparer  can be set as the grader for  MatrixGrader s using configuration options.", 
            "title": "MatrixEntryComparer"
        }, 
        {
            "location": "/grading_math/comparer_functions/#custom-comparer-functions", 
            "text": "In addition to using the built-in comparers, you can write your own.  See  comparers.py  for documentation and examples.", 
            "title": "Custom Comparer Functions"
        }, 
        {
            "location": "/grading_math/renderer/", 
            "text": "AsciiMath Renderer Definitions\n # \n\n\nWhen math input is expected from students, edX offers a math preview that attempts to show their expression in normal mathematical notation. There are two ways to provide this preview:\n\n\nformulaequationinput/\n\nor\n\ntextline math=\n1\n/\n\n\n\n\nThe \nformulaequationinput\n tag uses server-side parsing and rendering to display the preview to the student. By and large, the preview from \nformulaequationinput\n is better than that of \ntextline\n, as it treats functions correctly, and displays a number of LaTeX symbols natively. The downsides to \nformulaequationinput\n are that it doesn't recognize vectors such as \nvecx\n or \nhatx\n, the factorial and conjugation functions just apply as \nfact(x)\n and \nconj(x)\n, and because the processing is done server-side, we are unable to enhance the display at all.\n\n\nThe \ntextline\n tag treats the student input as AsciiMath for the purpose of generating a preview, using MathJax to render it. While the preview does a reasonably good job, there are many situations where it falls down, even for standard edX functions (for example, try typing in \n1/arctanh(x)\n in a textline box!). Because this is done client-side through javascript, it's possible to supplement the AsciiMath definitions to handle new situations. We have constructed a series of renderer definitions to supplement the standard AsciiMath definitions in order to provide better previews.\n\n\nThis article describes how to use our new AsciiMath renderer definitions with a \ntextline\n tag.\n\n\nHow it Works\n # \n\n\nThe renderer definitions are located in a javascript file, \nMJxPrep.js\n, which should be uploaded to the static assets folder for your course. This javascript file has two components: symbol definitions and a preprocessor.\n\n\nThe symbol definitions are used to teach AsciiMath how to display various functions properly, such as \nre\n, \nim\n, \narctanh\n etc. To load the symbol definitions in a problem, place the following HTML code somewhere in the problem.\n\n\nscript type=\ntext/javascript\n src=\n/static/MJxPrep.js\n/script\n\n\n\n\nSome functions are too complex for a symbol definition, and need the student's input to be preprocessed into AsciiMath before rendering. These functions include \nlog10\n, \nlog2\n, \nfact\n/\nfactorial\n, \ntrans\n, \nadj\n/\nctrans\n and \ncross\n.\n\n\nIt is quite common to have a variable name begin with \ndelta\n or \nDelta\n, such as \nDeltax\n. Unfortunately, AsciiMath treats such variables as two separate entries, and can sometimes split them inopportunely, such as for the expression \n1/Deltax\n. The preprocessor detects such variable names and ensures that AsciiMath displays them correctly.\n\n\nTo use these features, you need to add \npreprocessorClassName\n and \npreprocessorSrc\n properties to any \ntextline/\n tags that use the preprocessor, such as in the following example.\n\n\ncustomresponse cfn=\ngrader\n\n    \ntextline correct_answer=\n1/fact(5)\n math=\n1\n preprocessorClassName=\nMJxPrep\n preprocessorSrc=\n/static/MJxPrep.js\n/\n\n\n/customresponse\n\n\n\n\nIf you use the preprocessor in your problem, you get the symbol definitions as well (you don't need to load them separately using a script tag).\n\n\nOptions\n # \n\n\nThere are a few configurable options for the preprocessor in \nMJxPrep.js\n.\n\n\nBy default, \nconj()\n displays as a bar over the argument to the function. However, you may wish for complex conjugates to be displayed as a superscript star. If so, you can set \nconj_as_star: true\n at the start of the file.\n\n\nBy default, vectors \n[1, 2, 3]\n display as a column vector when the preprocessor is loaded (without the preprocessor, it will display as a row). If you would instead like them to display as a row vector, you can set the option \nvectors_as_columns: false\n at the start of the file.\n\n\nExtending Definitions\n # \n\n\nIf you're building a course that uses math extensively, it's likely that you want to use some sort of symbol that can't be written in the form of an edX variable. In this situation, we have provided two functions to extend the preprocessor. At the bottom of \nMJxPrep.js\n, you will find the functions \ncustomPreReplacements\n and \ncustomPostReplacements\n, which are called before and after our preprocessing functions occur, respectively. You can perform whatever manipulations you desire in these functions. As an example of a pre-replacement, consider the following line which implements the double factorial:\n\n\nworking = replaceFunctionCalls(working, 'ffact', funcToPostfix('!!') )\n\n\n\n\nThis leverages our \nreplaceFunctionCalls\n and \nfuncToPostfix\n functions which detect function calls and perform replacements, respectively (a number of other useful functions are included in the javascript file).\n\n\nAs an example of a post-replacement, the following line simply replaces a variable name with something that actually looks like a derivative:\n\n\nworking = working.replace(/dphidx/g, '{:(partial phi)/(partial x):}');\n\n\n\n\nThis is a trivial example of using regex to make a replacement; of course, more complicated replacements are also possible.\n\n\nFinally, if you want to introduce new symbols to AsciiMath using unicode, it's simple to do so. Here's an example of how we introduce hbar to the system:\n\n\n// This is hbar, often used in physics\nAM.newsymbol({\n  input:\nhbar\n,\n  tag:\nmo\n,\n  output:\n\\u210F\n,\n  tex:null,\n  ttype:AM.TOKEN.CONST});\n\n\n\n\nNotes\n # \n\n\n\n\n\n\nYou can take advantage of the symbol definitions and preprocessor even if you're not using the grading library at all. Just load it up in any \ntextline\n tags you're using. (We find the preprocessor so good that we use if for every math display problem in our courses!)\n\n\n\n\n\n\nThe javascript is constructed to only load its definitions once, no matter how many times the file is loaded. It's safe to use the preprocessor in as many \ntextline\n boxes as you like.\n\n\n\n\n\n\nThe \nmathematical functions\n article provides the complete list of functions that are corrected by the new AsciiMath renderer definitions.", 
            "title": "AsciiMath Renderer Definitions"
        }, 
        {
            "location": "/grading_math/renderer/#asciimath-renderer-definitions", 
            "text": "When math input is expected from students, edX offers a math preview that attempts to show their expression in normal mathematical notation. There are two ways to provide this preview:  formulaequationinput/ \nor textline math= 1 /  The  formulaequationinput  tag uses server-side parsing and rendering to display the preview to the student. By and large, the preview from  formulaequationinput  is better than that of  textline , as it treats functions correctly, and displays a number of LaTeX symbols natively. The downsides to  formulaequationinput  are that it doesn't recognize vectors such as  vecx  or  hatx , the factorial and conjugation functions just apply as  fact(x)  and  conj(x) , and because the processing is done server-side, we are unable to enhance the display at all.  The  textline  tag treats the student input as AsciiMath for the purpose of generating a preview, using MathJax to render it. While the preview does a reasonably good job, there are many situations where it falls down, even for standard edX functions (for example, try typing in  1/arctanh(x)  in a textline box!). Because this is done client-side through javascript, it's possible to supplement the AsciiMath definitions to handle new situations. We have constructed a series of renderer definitions to supplement the standard AsciiMath definitions in order to provide better previews.  This article describes how to use our new AsciiMath renderer definitions with a  textline  tag.", 
            "title": "AsciiMath Renderer Definitions"
        }, 
        {
            "location": "/grading_math/renderer/#how-it-works", 
            "text": "The renderer definitions are located in a javascript file,  MJxPrep.js , which should be uploaded to the static assets folder for your course. This javascript file has two components: symbol definitions and a preprocessor.  The symbol definitions are used to teach AsciiMath how to display various functions properly, such as  re ,  im ,  arctanh  etc. To load the symbol definitions in a problem, place the following HTML code somewhere in the problem.  script type= text/javascript  src= /static/MJxPrep.js /script  Some functions are too complex for a symbol definition, and need the student's input to be preprocessed into AsciiMath before rendering. These functions include  log10 ,  log2 ,  fact / factorial ,  trans ,  adj / ctrans  and  cross .  It is quite common to have a variable name begin with  delta  or  Delta , such as  Deltax . Unfortunately, AsciiMath treats such variables as two separate entries, and can sometimes split them inopportunely, such as for the expression  1/Deltax . The preprocessor detects such variable names and ensures that AsciiMath displays them correctly.  To use these features, you need to add  preprocessorClassName  and  preprocessorSrc  properties to any  textline/  tags that use the preprocessor, such as in the following example.  customresponse cfn= grader \n     textline correct_answer= 1/fact(5)  math= 1  preprocessorClassName= MJxPrep  preprocessorSrc= /static/MJxPrep.js /  /customresponse  If you use the preprocessor in your problem, you get the symbol definitions as well (you don't need to load them separately using a script tag).", 
            "title": "How it Works"
        }, 
        {
            "location": "/grading_math/renderer/#options", 
            "text": "There are a few configurable options for the preprocessor in  MJxPrep.js .  By default,  conj()  displays as a bar over the argument to the function. However, you may wish for complex conjugates to be displayed as a superscript star. If so, you can set  conj_as_star: true  at the start of the file.  By default, vectors  [1, 2, 3]  display as a column vector when the preprocessor is loaded (without the preprocessor, it will display as a row). If you would instead like them to display as a row vector, you can set the option  vectors_as_columns: false  at the start of the file.", 
            "title": "Options"
        }, 
        {
            "location": "/grading_math/renderer/#extending-definitions", 
            "text": "If you're building a course that uses math extensively, it's likely that you want to use some sort of symbol that can't be written in the form of an edX variable. In this situation, we have provided two functions to extend the preprocessor. At the bottom of  MJxPrep.js , you will find the functions  customPreReplacements  and  customPostReplacements , which are called before and after our preprocessing functions occur, respectively. You can perform whatever manipulations you desire in these functions. As an example of a pre-replacement, consider the following line which implements the double factorial:  working = replaceFunctionCalls(working, 'ffact', funcToPostfix('!!') )  This leverages our  replaceFunctionCalls  and  funcToPostfix  functions which detect function calls and perform replacements, respectively (a number of other useful functions are included in the javascript file).  As an example of a post-replacement, the following line simply replaces a variable name with something that actually looks like a derivative:  working = working.replace(/dphidx/g, '{:(partial phi)/(partial x):}');  This is a trivial example of using regex to make a replacement; of course, more complicated replacements are also possible.  Finally, if you want to introduce new symbols to AsciiMath using unicode, it's simple to do so. Here's an example of how we introduce hbar to the system:  // This is hbar, often used in physics\nAM.newsymbol({\n  input: hbar ,\n  tag: mo ,\n  output: \\u210F ,\n  tex:null,\n  ttype:AM.TOKEN.CONST});", 
            "title": "Extending Definitions"
        }, 
        {
            "location": "/grading_math/renderer/#notes", 
            "text": "You can take advantage of the symbol definitions and preprocessor even if you're not using the grading library at all. Just load it up in any  textline  tags you're using. (We find the preprocessor so good that we use if for every math display problem in our courses!)    The javascript is constructed to only load its definitions once, no matter how many times the file is loaded. It's safe to use the preprocessor in as many  textline  boxes as you like.    The  mathematical functions  article provides the complete list of functions that are corrected by the new AsciiMath renderer definitions.", 
            "title": "Notes"
        }, 
        {
            "location": "/grading_math/integral_grader/", 
            "text": "IntegralGrader\n # \n\n\nIntegralGrader\n is a specialized grading class used to grade the construction of integrals. Students can input the limits on the integral, the variable of integration, and the integrand (or some subset thereof), and will be graded correct if their construction is numerically equivalent to the instructor's construction. This method of grading allows for arbitrary variable substitutions and redefinitions.\n\n\nThe grader numerically evaluates the student- and instructor-specified integrals using \nscipy.integrate.quad\n. This quadrature-based integration technique is efficient and flexible. It handles many integrals with poles in the integrand and can integrate over infinite domains.\n\n\nHowever, some integrals may behave badly. These include, but are not limited to,\nthe following:\n\n\n\n\nintegrals with highly oscillatory integrands\n\n\nintegrals that evaluate analytically to zero\n\n\n\n\nIn some cases, problems might be avoided by using the integrator_options configuration key to provide extra instructions to \nscipy.integrate.quad\n, as documented below.\n\n\nXML Setup\n # \n\n\nWe recommend copying the following XML to set up a problem using \nIntegralGrader\n:\n\n\nstyle\n\n  .xmodule_display.xmodule_CapaModule .problem .capa_inputtype.textline input {\n    min-width: 0 !important;\n  }\n  .xmodule_display.xmodule_CapaModule div.problem section div span.MathJax {\n    display: inline-block !important;\n  }\n  .xmodule_display.xmodule_CapaModule div.problem section div span.MathJax_Preview {\n    display: inline-block !important;\n  }\n\n/style\n\n\n\nspan\n\n  \ncustomresponse cfn=\ngrader\n\n    \ntable\n\n      \ncol style=\nwidth:10%\n/\n\n      \ncol style=\nwidth:90%\n/\n\n      \ntbody\n\n        \ntr\n\n          \ntd colspan=\n2\n\n            \ntextline size=\n5\n correct_answer=\n1\n/\n\n          \n/td\n\n        \n/tr\n\n        \ntr\n\n          \ntd\n\n            \np\n \\( \\displaystyle \\huge{ \\int }\\)\n/p\n\n          \n/td\n\n          \ntd\n\n            \nbr/\n\n            \ntextline inline=\n1\n size=\n10\n correct_answer=\ne^x\n trailing_text=\n  [mathjaxinline] dx [/mathjaxinline]\n/\n\n          \n/td\n\n        \n/tr\n\n        \ntr\n\n          \ntd colspan=\n2\n\n            \ntextline size=\n5\n correct_answer=\n0\n/\n\n          \n/td\n\n        \n/tr\n\n      \n/tbody\n\n    \n/table\n\n  \n/customresponse\n\n\n/span\n\n\n\n\nThis sets up an integral where students can input the limits of integration and the integrand (the variable of integration has been fixed to be \nx\n in this case).\n\n\nFurther examples of formatting integrals are shown in the example course.\n\n\nSpecifying the Input Format\n # \n\n\nThe grader must be told which input is what, based on the order that the inputs appear in the XML. This is done through the \ninput_positions\n dictionary. If not specified, it is assumed that the following positions are used:\n\n\ninput_positions = {\n    'lower': 1,\n    'upper': 2,\n    'integrand': 3,\n    'integration_variable': 4\n}\n\n\n\n\nThis requires students to enter all four parameters in the indicated order.\n\n\nIf the author overrides the default \ninput_positions\n value, any subset of the keys ('lower', 'upper', 'integrand', 'integration_variable') may be specified. Key values should be\n\n\n\n\ncontinuous integers starting at 1, or\n\n\n(default) None, indicating that the parameter is not entered by student\n\n\n\n\nFor example,\n\n\ninput_positions = {\n    'lower': 1,\n    'upper': 2,\n    'integrand': 3\n}\n\n\n\n\nindicates that the problem has 3 input boxes which represent the lower limit, upper limit, and integrand in that order. The \nintegration_variable\n is NOT entered by student and is instead given by the value specified by author in 'answers'.\n\n\nHere is a sample grader for the above XML:\n\n\n from mitxgraders import *\n\n grader = IntegralGrader(\n...     answers={\n...         'lower':'0',\n...         'upper':'1',\n...         'integrand':'e^x',\n...         'integration_variable':'x'\n...     },\n...     input_positions = {\n...         'upper': 1,\n...         'integrand': 2,\n...         'lower': 3\n...     }\n... )\n\n\n\n\nSpecifying the Answer\n # \n\n\nThe author's answer should be specified as a dictionary with the following keys:\n\n\nanswers = {\n    'lower': 'lower_limit',\n    'upper': 'upper_limit',\n    'integrand': 'integrand',\n    'integration_variable': 'variable_of_integration'\n}\n\n\n\n\nNote that each entry is a string value.\n\n\nIntegralGrader\n can handle integrals over both finite and infinite domains. A special constant \n'infty'\n is recognized to cater for the infinite case (and takes on the special value \nfloat('inf')\n).\n\n\nOther Options\n # \n\n\nIf you wish to allow a student's integrand to be complex-valued at any point in the domain of the integral, set \ncomplex_integrand=True\n. If set to False (the default), a student's submission will be graded as incorrect if their integrand becomes complex anywhere in the domain.\n\n\nYou can modify the integration options used by \nscipy.integrate.quad\n by passing a dictionary of keyword-argument values using the option \nintegrator_options\n.\n\n\nThe following options from \nFormulaGrader\n are available for use in \nIntegralGrader\n:\n\n\n\n\nuser_constants\n\n\nuser_functions\n\n\nwhitelist\n\n\nblacklist\n\n\ntolerance\n\n\nsamples\n (default: 1)\n\n\nvariables\n\n\nsample_from\n\n\nfailable_evals\n\n\n\n\nUnless otherwise specified, the defaults are the same as in \nFormulaGrader\n.\n\n\nOption Listing\n # \n\n\nHere is the full list of options specific to an \nIntegralGrader\n.\n\n\ngrader = IntegralGrader(\n    input_positions=dict,\n    answers=dict,\n    complex_integrand=dict,  # default {'full_output': 1}\n    integrator_options=bool,  # default False\n    # The below options are the same as in FormulaGrader\n    variables=list,  # default []\n    sample_from=dict,  # default {}\n    samples=int,  # default 1\n    user_functions=dict,  # default {}\n    user_constants=dict,  # default {}\n    failable_evals=int,  # default 0\n    blacklist=list,  # default []\n    whitelist=list,  # default []\n    tolerance=(float | percentage),  # default '0.01%'\n)", 
            "title": "IntegralGrader"
        }, 
        {
            "location": "/grading_math/integral_grader/#integralgrader", 
            "text": "IntegralGrader  is a specialized grading class used to grade the construction of integrals. Students can input the limits on the integral, the variable of integration, and the integrand (or some subset thereof), and will be graded correct if their construction is numerically equivalent to the instructor's construction. This method of grading allows for arbitrary variable substitutions and redefinitions.  The grader numerically evaluates the student- and instructor-specified integrals using  scipy.integrate.quad . This quadrature-based integration technique is efficient and flexible. It handles many integrals with poles in the integrand and can integrate over infinite domains.  However, some integrals may behave badly. These include, but are not limited to,\nthe following:   integrals with highly oscillatory integrands  integrals that evaluate analytically to zero   In some cases, problems might be avoided by using the integrator_options configuration key to provide extra instructions to  scipy.integrate.quad , as documented below.", 
            "title": "IntegralGrader"
        }, 
        {
            "location": "/grading_math/integral_grader/#xml-setup", 
            "text": "We recommend copying the following XML to set up a problem using  IntegralGrader :  style \n  .xmodule_display.xmodule_CapaModule .problem .capa_inputtype.textline input {\n    min-width: 0 !important;\n  }\n  .xmodule_display.xmodule_CapaModule div.problem section div span.MathJax {\n    display: inline-block !important;\n  }\n  .xmodule_display.xmodule_CapaModule div.problem section div span.MathJax_Preview {\n    display: inline-block !important;\n  } /style  span \n   customresponse cfn= grader \n     table \n       col style= width:10% / \n       col style= width:90% / \n       tbody \n         tr \n           td colspan= 2 \n             textline size= 5  correct_answer= 1 / \n           /td \n         /tr \n         tr \n           td \n             p  \\( \\displaystyle \\huge{ \\int }\\) /p \n           /td \n           td \n             br/ \n             textline inline= 1  size= 10  correct_answer= e^x  trailing_text=   [mathjaxinline] dx [/mathjaxinline] / \n           /td \n         /tr \n         tr \n           td colspan= 2 \n             textline size= 5  correct_answer= 0 / \n           /td \n         /tr \n       /tbody \n     /table \n   /customresponse  /span  This sets up an integral where students can input the limits of integration and the integrand (the variable of integration has been fixed to be  x  in this case).  Further examples of formatting integrals are shown in the example course.", 
            "title": "XML Setup"
        }, 
        {
            "location": "/grading_math/integral_grader/#specifying-the-input-format", 
            "text": "The grader must be told which input is what, based on the order that the inputs appear in the XML. This is done through the  input_positions  dictionary. If not specified, it is assumed that the following positions are used:  input_positions = {\n    'lower': 1,\n    'upper': 2,\n    'integrand': 3,\n    'integration_variable': 4\n}  This requires students to enter all four parameters in the indicated order.  If the author overrides the default  input_positions  value, any subset of the keys ('lower', 'upper', 'integrand', 'integration_variable') may be specified. Key values should be   continuous integers starting at 1, or  (default) None, indicating that the parameter is not entered by student   For example,  input_positions = {\n    'lower': 1,\n    'upper': 2,\n    'integrand': 3\n}  indicates that the problem has 3 input boxes which represent the lower limit, upper limit, and integrand in that order. The  integration_variable  is NOT entered by student and is instead given by the value specified by author in 'answers'.  Here is a sample grader for the above XML:   from mitxgraders import *  grader = IntegralGrader(\n...     answers={\n...         'lower':'0',\n...         'upper':'1',\n...         'integrand':'e^x',\n...         'integration_variable':'x'\n...     },\n...     input_positions = {\n...         'upper': 1,\n...         'integrand': 2,\n...         'lower': 3\n...     }\n... )", 
            "title": "Specifying the Input Format"
        }, 
        {
            "location": "/grading_math/integral_grader/#specifying-the-answer", 
            "text": "The author's answer should be specified as a dictionary with the following keys:  answers = {\n    'lower': 'lower_limit',\n    'upper': 'upper_limit',\n    'integrand': 'integrand',\n    'integration_variable': 'variable_of_integration'\n}  Note that each entry is a string value.  IntegralGrader  can handle integrals over both finite and infinite domains. A special constant  'infty'  is recognized to cater for the infinite case (and takes on the special value  float('inf') ).", 
            "title": "Specifying the Answer"
        }, 
        {
            "location": "/grading_math/integral_grader/#other-options", 
            "text": "If you wish to allow a student's integrand to be complex-valued at any point in the domain of the integral, set  complex_integrand=True . If set to False (the default), a student's submission will be graded as incorrect if their integrand becomes complex anywhere in the domain.  You can modify the integration options used by  scipy.integrate.quad  by passing a dictionary of keyword-argument values using the option  integrator_options .  The following options from  FormulaGrader  are available for use in  IntegralGrader :   user_constants  user_functions  whitelist  blacklist  tolerance  samples  (default: 1)  variables  sample_from  failable_evals   Unless otherwise specified, the defaults are the same as in  FormulaGrader .", 
            "title": "Other Options"
        }, 
        {
            "location": "/grading_math/integral_grader/#option-listing", 
            "text": "Here is the full list of options specific to an  IntegralGrader .  grader = IntegralGrader(\n    input_positions=dict,\n    answers=dict,\n    complex_integrand=dict,  # default {'full_output': 1}\n    integrator_options=bool,  # default False\n    # The below options are the same as in FormulaGrader\n    variables=list,  # default []\n    sample_from=dict,  # default {}\n    samples=int,  # default 1\n    user_functions=dict,  # default {}\n    user_constants=dict,  # default {}\n    failable_evals=int,  # default 0\n    blacklist=list,  # default []\n    whitelist=list,  # default []\n    tolerance=(float | percentage),  # default '0.01%'\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/grading_lists/single_list_grader/", 
            "text": "SingleListGrader\n # \n\n\nIf you want a response to be a delimiter-separated list of items, you can use a special \nItemGrader\n called \nSingleListGrader\n to perform the grading. You need to specify a subgrader (which must be an \nItemGrader\n, and could even be another \nSingleListGrader\n) to evaluate each individual item. The basic usage is as follows.\n\n\n from mitxgraders import *\n\n grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader()\n... )\n\n grader(None, 'cat, dog') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'dog, cat') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'cat, octopus') == {'grade_decimal': 0.5, 'msg': '', 'ok': 'partial'}\nTrue\n\n\n\n\nTo receive full points for this problem, a student would enter \ncat, dog\n or \ndog, cat\n into the input box. Entering \ncat, octopus\n or just \ncat\n will receive half points.\n\n\nThe \nanswers\n key follows the usual \nItemGrader\n specification, with one change: instead of specifying individual strings or dictionaries, you need to specify lists of strings or dictionaries. Otherwise, the full scope of \nItemGrader\n configuration is available to you, such as using tuples to specify multiple lists of answers.\n\n\n grader = SingleListGrader(\n...     answers=(\n...         [('cat', 'feline'), 'dog'],\n...         ['goat', 'vole'],\n...     ),\n...     subgrader=StringGrader()\n... )\n\n grader(None, 'cat, dog') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'dog, feline') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'cat, vole') == {'grade_decimal': 0.5, 'msg': '', 'ok': 'partial'}\nTrue\n\n\n\n\nNow, \ncat, dog\n and \ngoat, vole\n will get full grades. But mixes won't: \ncat, vole\n will score half credit, as \ncat\n and \ndog\n are in the same answer list, while \nvole\n belongs with \ngoat\n.\n\n\nBelow is an example that uses literally all possible answer input styles.\n\n\n grader = SingleListGrader(\n...     answers=(\n...         [('cat', {'expect': 'feline', 'msg': 'Good enough!'}), 'dog'],\n...         {\n...             'expect': ['unicorn', 'lumberjack'],\n...             'msg': \nWell, you just had to do something strange, didn't you?\n,\n...             'grade_decimal': 0.5\n...         },\n...     ),\n...     subgrader=StringGrader()\n... )\n\n grader(None, 'feline, unicorn') == {'grade_decimal': 0.5, 'msg': 'Good enough!', 'ok': 'partial'}\nTrue\n\n grader(None, 'hippo, unicorn') == {'grade_decimal': 0.25, 'msg': '', 'ok': 'partial'}\nTrue\n\n grader(None, 'lumberjack, unicorn') == {'grade_decimal': 0.5, 'msg': \nWell, you just had to do something strange, didn't you?\n, 'ok': 'partial'}\nTrue\n\n\n\n\nNote that the list of answers can itself occur inside a dictionary that has a grade and message associated with it. In this case, the answers are evaluated as normal, and the overall grade is multiplied by \ngrade_decimal\n. The message is only shown if all of the inputs received credit. So, note that \nfeline, anything\n will get the \"Good enough!\" message, while the \"something strange\" message only appears if the student enters both \nunicorn\n and \nlumberjack\n.\n\n\nMessages\n # \n\n\nMessages from the individual items are all concatenated together and presented to the student. Overall messages associated with a list are included at the bottom. It is also possible to have a \nwrong_msg\n on the \nSingleListGrader\n, which is presented to the student if the score is zero and there are no other messages, just like on an \nItemGrader\n.\n\n\n grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     wrong_msg='Try again!'\n... )\n\n grader(None, 'wolf, feline') == {'grade_decimal': 0.0, 'msg': 'Try again!', 'ok': False}\nTrue\n\n\n\n\nOrdered Input\n # \n\n\nBy default, a \nSingleListGrader\n doesn't care which order the input is given in. If you want the answers and the student input to be compared in order, set \nordered=True\n.\n\n\n grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     ordered=True\n... )\n\n grader(None, 'cat, dog') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'dog, cat') == {'grade_decimal': 0.0, 'msg': '', 'ok': False}\nTrue\n\n\n\n\nNow \ncat, dog\n will receive full grades, but \ndog, cat\n will be marked wrong. Note that \ncat\n will receive half credit, but \ndog\n will receive zero, as dog is incorrect in the first position. Ordered is \nFalse\n by default.\n\n\nLength Checking\n # \n\n\nIf students are asked to enter a list of three items but only enter two, should this use up an attempt, or present an error message? If you want to present an error message, turn on length checking.\n\n\n grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n... )\n\n grader(None, 'cat, dog, unicorn') == {'grade_decimal': 0.5, 'msg': '', 'ok': 'partial'}\nTrue\n\n grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     length_error=True\n... )\n\n try:\n...     grader(None, 'cat')\n... except MissingInput as error:\n...     print(error)\nList length error: Expected 2 terms in the list, but received 1. Separate items with character \n,\n\n\n\n\nIf you give this \ncat\n, it will tell you that you've got the wrong length, and won't use up an attempt.\n\n\nBy default, \nlength_error\n is set to \nFalse\n. If you set \nlength_error\n to \nTrue\n, then all answers in a tuple of lists (rather than a single answer list) must have the same length.\n\n\nEmpty Entries\n # \n\n\nIn order to protect students from typos, the grader returns an error if a student's response has an empty entry (or an entry that just contains spaces). If you want students to be able to enter a list with an empty entry, you need to disable this behavior by setting \nmissing_error=False\n.\n\n\n grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader()\n... )\n\n try:\n...     grader(None, 'cat, dog,')\n... except MissingInput as error:\n...     print(error)\nList error: Empty entry detected in position 3\n\n grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     missing_error=False\n... )\n\n grader(None, 'cat, dog,') == {'grade_decimal': 0.5, 'msg': '', 'ok': 'partial'}\nTrue\n\n\n\n\nChoosing Delimiters\n # \n\n\nYou can use whatever delimiter you like. The default is a comma (\n,\n). The following uses a semicolon as a delimiter. We recommend not using multi-character delimiters, but do not disallow it.\n\n\n grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     delimiter=';'\n... )\n\n grader(None, 'cat; dog') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue\n\n\n\n\nBy using different delimiters, it is possible to nest \nSingleListGrader\ns:\n\n\n grader = SingleListGrader(\n...     answers=[['a', 'b'], ['c', 'd']],\n...     subgrader=SingleListGrader(\n...         subgrader=StringGrader()\n...     ),\n...     delimiter=';'\n... )\n\n grader(None, 'd, c; a, b') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue\n\n grader(None, 'a, c; d, b') == {'grade_decimal': 0.5, 'msg': '', 'ok': 'partial'}\nTrue\n\n\n\n\nHere the expected student input is \na, b; c, d\n. It will also take \nb, a; d, c\n or \nc, d; a, b\n due to the unordered nature of both lists. However, \na, c; d, b\n is only worth half points.\n\n\nPartial Credit\n # \n\n\nBy default, partial credit is awarded to partially correct answers. Answers that have insufficient items lose points, as do answers that have too many items. To turn off partial credit, set \npartial_credit=False\n. It is \nTrue\n by default.\n\n\n grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     partial_credit=False\n... )\n\n grader(None, 'cat, octopus') == {'grade_decimal': 0.0, 'msg': '', 'ok': False}\nTrue\n\n\n\n\nNow \ncat, octopus\n will receive a grade of zero.\n\n\nInferred Answers\n # \n\n\nJust as for normal \nItemGrader\ns, the \nanswers\n key can be inferred from the \nexpect\n or \nanswer\n parameter in a \ncustomresponse\n tag. Here is an example.\n\n\nproblem\n\n\n\nscript type=\nloncapa/python\n\nfrom mitxgraders import *\n\n/script\n\n\n\n!-- Define the problem --\n\n\ncustomresponse cfn=\nSingleListGrader(subgrader=StringGrader())\n expect=\na, b, c, d\n\n  \ntextline /\n\n\n/customresponse\n\n\n\n/problem\n\n\n\n\nHere, the grader is a \nSingleListGrader\n using \nStringGrader\n as a subgrader, and uses default values for all other options. The \nanswers\n key is missing, so it is inferred to be \n['a', 'b', 'c', 'd']\n from the \nexpect\n parameter of the \ncustomresponse\n tag. Answer inference will even work with nested \nSingleListGrader\ns.\n\n\nOption Listing\n # \n\n\nHere is the full list of options specific to a \nSingleListGrader\n.\n\n\ngrader = SingleListGrader(\n    answers=(list, {'expect': list}, (list, {'expect': list}, )),\n    subgrader=ItemGrader(),\n    partial_credit=bool,  # default True\n    ordered=bool,  # default False\n    length_error=bool,  # default False\n    missing_error=bool,  # default True\n    delimiter=str,  # default ','\n)", 
            "title": "SingleListGrader"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#singlelistgrader", 
            "text": "If you want a response to be a delimiter-separated list of items, you can use a special  ItemGrader  called  SingleListGrader  to perform the grading. You need to specify a subgrader (which must be an  ItemGrader , and could even be another  SingleListGrader ) to evaluate each individual item. The basic usage is as follows.   from mitxgraders import *  grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader()\n... )  grader(None, 'cat, dog') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue  grader(None, 'dog, cat') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue  grader(None, 'cat, octopus') == {'grade_decimal': 0.5, 'msg': '', 'ok': 'partial'}\nTrue  To receive full points for this problem, a student would enter  cat, dog  or  dog, cat  into the input box. Entering  cat, octopus  or just  cat  will receive half points.  The  answers  key follows the usual  ItemGrader  specification, with one change: instead of specifying individual strings or dictionaries, you need to specify lists of strings or dictionaries. Otherwise, the full scope of  ItemGrader  configuration is available to you, such as using tuples to specify multiple lists of answers.   grader = SingleListGrader(\n...     answers=(\n...         [('cat', 'feline'), 'dog'],\n...         ['goat', 'vole'],\n...     ),\n...     subgrader=StringGrader()\n... )  grader(None, 'cat, dog') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue  grader(None, 'dog, feline') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue  grader(None, 'cat, vole') == {'grade_decimal': 0.5, 'msg': '', 'ok': 'partial'}\nTrue  Now,  cat, dog  and  goat, vole  will get full grades. But mixes won't:  cat, vole  will score half credit, as  cat  and  dog  are in the same answer list, while  vole  belongs with  goat .  Below is an example that uses literally all possible answer input styles.   grader = SingleListGrader(\n...     answers=(\n...         [('cat', {'expect': 'feline', 'msg': 'Good enough!'}), 'dog'],\n...         {\n...             'expect': ['unicorn', 'lumberjack'],\n...             'msg':  Well, you just had to do something strange, didn't you? ,\n...             'grade_decimal': 0.5\n...         },\n...     ),\n...     subgrader=StringGrader()\n... )  grader(None, 'feline, unicorn') == {'grade_decimal': 0.5, 'msg': 'Good enough!', 'ok': 'partial'}\nTrue  grader(None, 'hippo, unicorn') == {'grade_decimal': 0.25, 'msg': '', 'ok': 'partial'}\nTrue  grader(None, 'lumberjack, unicorn') == {'grade_decimal': 0.5, 'msg':  Well, you just had to do something strange, didn't you? , 'ok': 'partial'}\nTrue  Note that the list of answers can itself occur inside a dictionary that has a grade and message associated with it. In this case, the answers are evaluated as normal, and the overall grade is multiplied by  grade_decimal . The message is only shown if all of the inputs received credit. So, note that  feline, anything  will get the \"Good enough!\" message, while the \"something strange\" message only appears if the student enters both  unicorn  and  lumberjack .", 
            "title": "SingleListGrader"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#messages", 
            "text": "Messages from the individual items are all concatenated together and presented to the student. Overall messages associated with a list are included at the bottom. It is also possible to have a  wrong_msg  on the  SingleListGrader , which is presented to the student if the score is zero and there are no other messages, just like on an  ItemGrader .   grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     wrong_msg='Try again!'\n... )  grader(None, 'wolf, feline') == {'grade_decimal': 0.0, 'msg': 'Try again!', 'ok': False}\nTrue", 
            "title": "Messages"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#ordered-input", 
            "text": "By default, a  SingleListGrader  doesn't care which order the input is given in. If you want the answers and the student input to be compared in order, set  ordered=True .   grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     ordered=True\n... )  grader(None, 'cat, dog') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue  grader(None, 'dog, cat') == {'grade_decimal': 0.0, 'msg': '', 'ok': False}\nTrue  Now  cat, dog  will receive full grades, but  dog, cat  will be marked wrong. Note that  cat  will receive half credit, but  dog  will receive zero, as dog is incorrect in the first position. Ordered is  False  by default.", 
            "title": "Ordered Input"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#length-checking", 
            "text": "If students are asked to enter a list of three items but only enter two, should this use up an attempt, or present an error message? If you want to present an error message, turn on length checking.   grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n... )  grader(None, 'cat, dog, unicorn') == {'grade_decimal': 0.5, 'msg': '', 'ok': 'partial'}\nTrue  grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     length_error=True\n... )  try:\n...     grader(None, 'cat')\n... except MissingInput as error:\n...     print(error)\nList length error: Expected 2 terms in the list, but received 1. Separate items with character  ,  If you give this  cat , it will tell you that you've got the wrong length, and won't use up an attempt.  By default,  length_error  is set to  False . If you set  length_error  to  True , then all answers in a tuple of lists (rather than a single answer list) must have the same length.", 
            "title": "Length Checking"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#empty-entries", 
            "text": "In order to protect students from typos, the grader returns an error if a student's response has an empty entry (or an entry that just contains spaces). If you want students to be able to enter a list with an empty entry, you need to disable this behavior by setting  missing_error=False .   grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader()\n... )  try:\n...     grader(None, 'cat, dog,')\n... except MissingInput as error:\n...     print(error)\nList error: Empty entry detected in position 3  grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     missing_error=False\n... )  grader(None, 'cat, dog,') == {'grade_decimal': 0.5, 'msg': '', 'ok': 'partial'}\nTrue", 
            "title": "Empty Entries"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#choosing-delimiters", 
            "text": "You can use whatever delimiter you like. The default is a comma ( , ). The following uses a semicolon as a delimiter. We recommend not using multi-character delimiters, but do not disallow it.   grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     delimiter=';'\n... )  grader(None, 'cat; dog') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue  By using different delimiters, it is possible to nest  SingleListGrader s:   grader = SingleListGrader(\n...     answers=[['a', 'b'], ['c', 'd']],\n...     subgrader=SingleListGrader(\n...         subgrader=StringGrader()\n...     ),\n...     delimiter=';'\n... )  grader(None, 'd, c; a, b') == {'grade_decimal': 1.0, 'msg': '', 'ok': True}\nTrue  grader(None, 'a, c; d, b') == {'grade_decimal': 0.5, 'msg': '', 'ok': 'partial'}\nTrue  Here the expected student input is  a, b; c, d . It will also take  b, a; d, c  or  c, d; a, b  due to the unordered nature of both lists. However,  a, c; d, b  is only worth half points.", 
            "title": "Choosing Delimiters"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#partial-credit", 
            "text": "By default, partial credit is awarded to partially correct answers. Answers that have insufficient items lose points, as do answers that have too many items. To turn off partial credit, set  partial_credit=False . It is  True  by default.   grader = SingleListGrader(\n...     answers=['cat', 'dog'],\n...     subgrader=StringGrader(),\n...     partial_credit=False\n... )  grader(None, 'cat, octopus') == {'grade_decimal': 0.0, 'msg': '', 'ok': False}\nTrue  Now  cat, octopus  will receive a grade of zero.", 
            "title": "Partial Credit"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#inferred-answers", 
            "text": "Just as for normal  ItemGrader s, the  answers  key can be inferred from the  expect  or  answer  parameter in a  customresponse  tag. Here is an example.  problem  script type= loncapa/python \nfrom mitxgraders import * /script  !-- Define the problem --  customresponse cfn= SingleListGrader(subgrader=StringGrader())  expect= a, b, c, d \n   textline /  /customresponse  /problem  Here, the grader is a  SingleListGrader  using  StringGrader  as a subgrader, and uses default values for all other options. The  answers  key is missing, so it is inferred to be  ['a', 'b', 'c', 'd']  from the  expect  parameter of the  customresponse  tag. Answer inference will even work with nested  SingleListGrader s.", 
            "title": "Inferred Answers"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  SingleListGrader .  grader = SingleListGrader(\n    answers=(list, {'expect': list}, (list, {'expect': list}, )),\n    subgrader=ItemGrader(),\n    partial_credit=bool,  # default True\n    ordered=bool,  # default False\n    length_error=bool,  # default False\n    missing_error=bool,  # default True\n    delimiter=str,  # default ','\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/grading_lists/list_grader/", 
            "text": "ListGrader\n # \n\n\nA \nListGrader\n is used to grade a list of student inputs wherein each input is entered in a separate answer box. (In contrast, \nSingleListGrader\n can be used to grade a list of items entered all at once into a single answer box.) \nListGrader\ns work by farming out individual items to subgraders, and then collecting the results and working out the optimal farming scheme for the student.\n\n\nNote that a \nListGrader\n is not an \nItemGrader\n, as it handles multiple inputs at once.\n\n\nBasic Usage\n # \n\n\nIn this example, each input is checked against the corresponding answer, using \nStringGrader\n as the subgrader.\n\n\n from mitxgraders import *\n\n grader = ListGrader(\n...     answers=['cat', 'dog'],\n...     subgraders=StringGrader()\n... )\n\n grader(None, ['cat', 'dog']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue\n\n\n\n\nAnswers are provided as a python list of individual \nItemGrader\n answers (or a tuple of such lists). Note that the individual answers may take advantage of all of the usual \nItemGrader\n flexibility, but \nListGrader\n requires either a list, or a tuple of lists. Each element of answers is set as an answer that is passed as the answers key into the subgrader. This particular example should be set up as two input boxes that the student types in, as follows.\n\n\nproblem\n\n\np\nWhat are the most common pets?\n/p\n\n\n\nscript type=\ntext/python\n system_path=\npython_lib\n\nfrom mitxgraders import *\ngrader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader()\n)\n\n/script\n\n\n\ncustomresponse cfn=\ngrader\n inline=\n1\n\n  \np style=\ndisplay:inline\nFirst answer: \n/p\ntextline math=\n1\n inline=\n1\n correct_answer=\ncat\n/\n\n  \nbr/\n\n  \np style=\ndisplay:inline\nSecond answer: \n/p\ntextline math=\n1\n inline=\n1\n correct_answer=\ndog\n/\n\n\n/customresponse\n\n\n/problem\n\n\n\n\nIn the above example, the item grader just sees single strings as the answer. The full versatility of the \nItemGrader\n answer scheme is available though, such as in the following.\n\n\n answer1 = (\n...     {'expect': 'zebra', 'grade_decimal': 1},\n...     {'expect': 'horse', 'grade_decimal': 0.45},\n...     {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'Unicorn? Really?'}\n... )\n\n answer2 = (\n...     {'expect': 'cat', 'grade_decimal': 1},\n...     {'expect': 'feline', 'grade_decimal': 0.5}\n... )\n\n grader = ListGrader(\n...     answers=[answer1, answer2],\n...     subgraders=StringGrader()\n... )\n\n grader(None, ['cat', 'unicorn']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 0, 'msg': 'Unicorn? Really?', 'ok': False}]\n...     }\nTrue\n\n grader(None, ['zebra', 'unicorn']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False}]\n...     }\nTrue\n\n\n\n\nIn this example, the grader will try assigning the first input to answer1 and the second to answer2, and computing the total score. Then it will repeat, with the inputs switched. The student will receive the highest grade. So, note that while \ncat\n and \nunicorn\n will get the unicorn message (and 1/2 points), \nzebra\n and \nunicorn\n will not (and also get 1/2 points).\n\n\nPartial Credit\n # \n\n\nBy default, every input receives its own grade. You may instead choose that all inputs are graded as incorrect unless every input is 100% correct by setting \npartial_credit=False\n. This is not a forgiving option: a single entry with a \ngrade_decimal\n value of 0.99 will cause all entries to be graded as wrong.\n\n\n from mitxgraders import *\n\n grader = ListGrader(\n...     answers=['cat', 'dog'],\n...     subgraders=StringGrader(),\n...     partial_credit=False\n... )\n\n grader(None, ['cat', 'unicorn']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 0, 'msg': '', 'ok': False},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False}]\n...     }\nTrue\n\n\n\n\nWe strongly recommend informing students that there will be no partial credit for questions that use this option, as otherwise there will be confusion when correct inputs receive red crosses.\n\n\nOrdered Input\n # \n\n\nBy default, a \nListGrader\n doesn't care what order the inputs are given in, so \"cat\" and \"dog\" is equivalent to \"dog\" and \"cat\". If you want the inputs to be ordered, simply set \nordered=True\n.\n\n\n grader = ListGrader(\n...     answers=['cat', 'dog'],\n...     subgraders=StringGrader(),\n...     ordered=True\n... )\n\n grader(None, ['cat', 'dog']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue\n\n grader(None, ['dog', 'cat']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 0, 'msg': '', 'ok': False},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False}]\n...     }\nTrue\n\n\n\n\nNow, \"cat\" and \"dog\" will receive full credit, but \"dog\" and \"cat\" will receive none.\n\n\nMultiple Graders\n # \n\n\nIf you have inhomogeneous inputs, you can grade them using different graders. Simply give a list of subgraders, and the data will be passed into the graders in that order. Note that the length of answers must be the same as the number of subgraders in this case. Further note that you must set \nordered=True\n when using a list of subgraders.\n\n\n grader = ListGrader(\n...     answers=['cat', 'x^2+1'],\n...     subgraders=[StringGrader(), FormulaGrader(variables=[\nx\n])],\n...     ordered=True\n... )\n\n grader(None, ['cat', 'x^2+1']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue\n\n\n\n\nIf \nsubgraders\n is given a single grader rather than a list, that grader is used for all inputs.\n\n\nSingleListGraders in ListGrader\n # \n\n\nSome questions will require nested list graders. Simple versions can make use of a \nSingleListGrader\n subgrader, as in the following example.\n\n\nConsider two input boxes, where the first should be a comma-separated list of even numbers beneath 5, and the second should be a comma-separated list of odd numbers beneath 5. The order of the boxes is important, but within each box, the order becomes unimportant. Here's how you can encode this type of problem.\n\n\n grader = ListGrader(\n...     answers=[\n...         ['2', '4'],\n...         ['1', '3']\n...     ],\n...     subgraders=SingleListGrader(\n...         subgrader=NumericalGrader()\n...     ),\n...     ordered=True\n... )\n\n grader(None, ['2, 4', '3, 1']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue\n\n\n\n\nThe nested \nSingleListGrader\n will be used to grade the first input box against an unordered answer of 2 and 4, and then the second input box against an unordered answer of 1 and 3.\n\n\nGrouped Inputs\n # \n\n\nIf you find yourself wanting to nest \nListGrader\ns, then you will need to specify how the inputs should be grouped together to be passed to the subgraders. A simple example would be to ask for the name and number of each animal in a picture. Each name/number group needs to be graded together. Here is an example of such a question.\n\n\n grader = ListGrader(\n...     answers=[\n...         ['cat', '1'],\n...         ['dog', '2'],\n...         ['tiger', '3']\n...     ],\n...     subgraders=ListGrader(\n...         subgraders=[StringGrader(), NumericalGrader()],\n...         ordered=True\n...     ),\n...     grouping=[1, 1, 2, 2, 3, 3]\n... )\n\n grader(None, ['cat', '1', 'tiger', '4', 'dog', '2']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue\n\n\n\n\nIn this case, the second level of grader is receiving multiple inputs, and so itself needs to be a \nListGrader\n. The grouping key specifies which group each input belongs to. In this case, answers 1 and 2 will be combined into a list and fed to the subgrader as group 1, as will 3 and 4 as group 2, and 5 and 6 as group 3. The third level of grader (\nStringGrader\n and \nNumericalGrader\n) will then receive a list of two inputs, and each of the items in the answers. Because this is an unordered list, the \nListGrader\n will find the optimal ordering of (animal, number) pairs.\n\n\nThe grouping keys must be integers starting at 1 and increasing. If you have N groups, then all numbers from 1 to N must be present in the grouping, but they need not be in monotonic order. So for example, [1, 2, 1, 2] is a valid grouping. For unordered groups, the groupings must each have the same number of elements.\n\n\nHere is another example. In this case, we have ordered entry, so we can specify a list of subgraders. We have three items in the first grouping and one item in the second, so we use a \nListGrader\n for the first grouping, and a \nStringGrader\n for the second. Note that the first entry in answers is a list that is passed directly into the \nListGrader\n, while the second entry is just a string. This second-level \nListGrader\n is unordered.\n\n\n grader = ListGrader(\n...     answers=[\n...         ['bat', 'ghost', 'pumpkin'],\n...         'Halloween'\n...     ],\n...     subgraders=[\n...         ListGrader(\n...             subgraders=StringGrader()\n...         ),\n...         StringGrader()\n...     ],\n...     ordered=True,\n...     grouping=[1, 1, 1, 2]\n... )\n\n grader(None, ['ghost', 'pumpkin', 'bat', 'Halloween']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue\n\n\n\n\nOur last pair of examples are for a math class, where we have a matrix that has two eigenvalues, and each eigenvalue has a corresponding eigenvector. We start by grouping the eigenvalue and eigenvector boxes together, and then grade the groups in an unordered fashion. The eigenvectors are normalized, but have a sign ambiguity. A tuple contains both possible answers, and the grader will accept either of them.\n\n\n grader = ListGrader(\n...     answers=[\n...         ['1', (['1', '0'], ['-1', '0'])],\n...         ['-1', (['0', '1'], ['0', '-1'])],\n...     ],\n...     subgraders=ListGrader(\n...         subgraders=[\n...             NumericalGrader(),\n...             SingleListGrader(\n...                 subgrader=NumericalGrader(),\n...                 ordered=True\n...             )\n...         ],\n...         ordered=True,\n...         partial_credit=False\n...     ),\n...     grouping=[1, 1, 2, 2]\n... )\n\n grader(None, ['1', '1, 0', '-1', '1, 1']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False}]\n...     }\nTrue\n\n\n\n\nThis example has four input boxes, with the first and third being graded by a \nNumericalGrader\n, and the second and fourth being graded by a \nSingleListGrader\n. Note that we have set \npartial_credit=False\n on the nested \nListGrader\n. This means that both the eigenvalue and eigenvector must be correct as a pair in order to get credit. However, as \npartial_credit\n is \nTrue\n for the highest level \nListGrader\n, students can get credit for each pair of eigenvalues/eigenvectors individually.\n\n\nIt is possible to specify a grouping on a nested \nListGrader\n. The outer \nListGrader\n must also have a grouping specified if doing so. Here is the same grader as above, where instead of taking the eigenvectors in a single input box list, there are four boxes to input each of the four vector components.\n\n\n grader = ListGrader(\n...     answers=[\n...         ['1', (['1', '0'], ['-1', '0'])],\n...         ['-1', (['0', '1'], ['0', '-1'])],\n...     ],\n...     subgraders=ListGrader(\n...         subgraders=[\n...             NumericalGrader(),\n...             ListGrader(\n...                 subgraders=NumericalGrader(),\n...                 ordered=True\n...             )\n...         ],\n...         ordered=True,\n...         grouping=[1, 2, 2]\n...     ),\n...     grouping=[1, 1, 1, 2, 2, 2]\n... )\n\n grader(None, ['1', '1', '0', '-1', '1', '1']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue\n\n\n\n\nIn this example, partial credit is turned on everywhere, so only the one entry is graded as incorrect. While we recommend using a \nMatrixGrader\n instead of entering components in separate boxes like this, this example illustrates how nested \nListGrader\ns work.\n\n\nOption Listing\n # \n\n\nHere is the full list of options specific to a \nListGrader\n.\n\n\ngrader = ListGrader(\n    answers=list,  # default []\n    subgraders=(ListGrader, ItemGrader, [ListGrader, ItemGrader]),\n    partial_credit=bool,  # default True\n    ordered=bool,  # default False\n    grouping=list,  # default []\n)", 
            "title": "ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#listgrader", 
            "text": "A  ListGrader  is used to grade a list of student inputs wherein each input is entered in a separate answer box. (In contrast,  SingleListGrader  can be used to grade a list of items entered all at once into a single answer box.)  ListGrader s work by farming out individual items to subgraders, and then collecting the results and working out the optimal farming scheme for the student.  Note that a  ListGrader  is not an  ItemGrader , as it handles multiple inputs at once.", 
            "title": "ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#basic-usage", 
            "text": "In this example, each input is checked against the corresponding answer, using  StringGrader  as the subgrader.   from mitxgraders import *  grader = ListGrader(\n...     answers=['cat', 'dog'],\n...     subgraders=StringGrader()\n... )  grader(None, ['cat', 'dog']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue  Answers are provided as a python list of individual  ItemGrader  answers (or a tuple of such lists). Note that the individual answers may take advantage of all of the usual  ItemGrader  flexibility, but  ListGrader  requires either a list, or a tuple of lists. Each element of answers is set as an answer that is passed as the answers key into the subgrader. This particular example should be set up as two input boxes that the student types in, as follows.  problem  p What are the most common pets? /p  script type= text/python  system_path= python_lib \nfrom mitxgraders import *\ngrader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader()\n) /script  customresponse cfn= grader  inline= 1 \n   p style= display:inline First answer:  /p textline math= 1  inline= 1  correct_answer= cat / \n   br/ \n   p style= display:inline Second answer:  /p textline math= 1  inline= 1  correct_answer= dog /  /customresponse  /problem  In the above example, the item grader just sees single strings as the answer. The full versatility of the  ItemGrader  answer scheme is available though, such as in the following.   answer1 = (\n...     {'expect': 'zebra', 'grade_decimal': 1},\n...     {'expect': 'horse', 'grade_decimal': 0.45},\n...     {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'Unicorn? Really?'}\n... )  answer2 = (\n...     {'expect': 'cat', 'grade_decimal': 1},\n...     {'expect': 'feline', 'grade_decimal': 0.5}\n... )  grader = ListGrader(\n...     answers=[answer1, answer2],\n...     subgraders=StringGrader()\n... )  grader(None, ['cat', 'unicorn']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 0, 'msg': 'Unicorn? Really?', 'ok': False}]\n...     }\nTrue  grader(None, ['zebra', 'unicorn']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False}]\n...     }\nTrue  In this example, the grader will try assigning the first input to answer1 and the second to answer2, and computing the total score. Then it will repeat, with the inputs switched. The student will receive the highest grade. So, note that while  cat  and  unicorn  will get the unicorn message (and 1/2 points),  zebra  and  unicorn  will not (and also get 1/2 points).", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/grading_lists/list_grader/#partial-credit", 
            "text": "By default, every input receives its own grade. You may instead choose that all inputs are graded as incorrect unless every input is 100% correct by setting  partial_credit=False . This is not a forgiving option: a single entry with a  grade_decimal  value of 0.99 will cause all entries to be graded as wrong.   from mitxgraders import *  grader = ListGrader(\n...     answers=['cat', 'dog'],\n...     subgraders=StringGrader(),\n...     partial_credit=False\n... )  grader(None, ['cat', 'unicorn']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 0, 'msg': '', 'ok': False},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False}]\n...     }\nTrue  We strongly recommend informing students that there will be no partial credit for questions that use this option, as otherwise there will be confusion when correct inputs receive red crosses.", 
            "title": "Partial Credit"
        }, 
        {
            "location": "/grading_lists/list_grader/#ordered-input", 
            "text": "By default, a  ListGrader  doesn't care what order the inputs are given in, so \"cat\" and \"dog\" is equivalent to \"dog\" and \"cat\". If you want the inputs to be ordered, simply set  ordered=True .   grader = ListGrader(\n...     answers=['cat', 'dog'],\n...     subgraders=StringGrader(),\n...     ordered=True\n... )  grader(None, ['cat', 'dog']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue  grader(None, ['dog', 'cat']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 0, 'msg': '', 'ok': False},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False}]\n...     }\nTrue  Now, \"cat\" and \"dog\" will receive full credit, but \"dog\" and \"cat\" will receive none.", 
            "title": "Ordered Input"
        }, 
        {
            "location": "/grading_lists/list_grader/#multiple-graders", 
            "text": "If you have inhomogeneous inputs, you can grade them using different graders. Simply give a list of subgraders, and the data will be passed into the graders in that order. Note that the length of answers must be the same as the number of subgraders in this case. Further note that you must set  ordered=True  when using a list of subgraders.   grader = ListGrader(\n...     answers=['cat', 'x^2+1'],\n...     subgraders=[StringGrader(), FormulaGrader(variables=[ x ])],\n...     ordered=True\n... )  grader(None, ['cat', 'x^2+1']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue  If  subgraders  is given a single grader rather than a list, that grader is used for all inputs.", 
            "title": "Multiple Graders"
        }, 
        {
            "location": "/grading_lists/list_grader/#singlelistgraders-in-listgrader", 
            "text": "Some questions will require nested list graders. Simple versions can make use of a  SingleListGrader  subgrader, as in the following example.  Consider two input boxes, where the first should be a comma-separated list of even numbers beneath 5, and the second should be a comma-separated list of odd numbers beneath 5. The order of the boxes is important, but within each box, the order becomes unimportant. Here's how you can encode this type of problem.   grader = ListGrader(\n...     answers=[\n...         ['2', '4'],\n...         ['1', '3']\n...     ],\n...     subgraders=SingleListGrader(\n...         subgrader=NumericalGrader()\n...     ),\n...     ordered=True\n... )  grader(None, ['2, 4', '3, 1']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue  The nested  SingleListGrader  will be used to grade the first input box against an unordered answer of 2 and 4, and then the second input box against an unordered answer of 1 and 3.", 
            "title": "SingleListGraders in ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#grouped-inputs", 
            "text": "If you find yourself wanting to nest  ListGrader s, then you will need to specify how the inputs should be grouped together to be passed to the subgraders. A simple example would be to ask for the name and number of each animal in a picture. Each name/number group needs to be graded together. Here is an example of such a question.   grader = ListGrader(\n...     answers=[\n...         ['cat', '1'],\n...         ['dog', '2'],\n...         ['tiger', '3']\n...     ],\n...     subgraders=ListGrader(\n...         subgraders=[StringGrader(), NumericalGrader()],\n...         ordered=True\n...     ),\n...     grouping=[1, 1, 2, 2, 3, 3]\n... )  grader(None, ['cat', '1', 'tiger', '4', 'dog', '2']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue  In this case, the second level of grader is receiving multiple inputs, and so itself needs to be a  ListGrader . The grouping key specifies which group each input belongs to. In this case, answers 1 and 2 will be combined into a list and fed to the subgrader as group 1, as will 3 and 4 as group 2, and 5 and 6 as group 3. The third level of grader ( StringGrader  and  NumericalGrader ) will then receive a list of two inputs, and each of the items in the answers. Because this is an unordered list, the  ListGrader  will find the optimal ordering of (animal, number) pairs.  The grouping keys must be integers starting at 1 and increasing. If you have N groups, then all numbers from 1 to N must be present in the grouping, but they need not be in monotonic order. So for example, [1, 2, 1, 2] is a valid grouping. For unordered groups, the groupings must each have the same number of elements.  Here is another example. In this case, we have ordered entry, so we can specify a list of subgraders. We have three items in the first grouping and one item in the second, so we use a  ListGrader  for the first grouping, and a  StringGrader  for the second. Note that the first entry in answers is a list that is passed directly into the  ListGrader , while the second entry is just a string. This second-level  ListGrader  is unordered.   grader = ListGrader(\n...     answers=[\n...         ['bat', 'ghost', 'pumpkin'],\n...         'Halloween'\n...     ],\n...     subgraders=[\n...         ListGrader(\n...             subgraders=StringGrader()\n...         ),\n...         StringGrader()\n...     ],\n...     ordered=True,\n...     grouping=[1, 1, 1, 2]\n... )  grader(None, ['ghost', 'pumpkin', 'bat', 'Halloween']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue  Our last pair of examples are for a math class, where we have a matrix that has two eigenvalues, and each eigenvalue has a corresponding eigenvector. We start by grouping the eigenvalue and eigenvector boxes together, and then grade the groups in an unordered fashion. The eigenvectors are normalized, but have a sign ambiguity. A tuple contains both possible answers, and the grader will accept either of them.   grader = ListGrader(\n...     answers=[\n...         ['1', (['1', '0'], ['-1', '0'])],\n...         ['-1', (['0', '1'], ['0', '-1'])],\n...     ],\n...     subgraders=ListGrader(\n...         subgraders=[\n...             NumericalGrader(),\n...             SingleListGrader(\n...                 subgrader=NumericalGrader(),\n...                 ordered=True\n...             )\n...         ],\n...         ordered=True,\n...         partial_credit=False\n...     ),\n...     grouping=[1, 1, 2, 2]\n... )  grader(None, ['1', '1, 0', '-1', '1, 1']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False}]\n...     }\nTrue  This example has four input boxes, with the first and third being graded by a  NumericalGrader , and the second and fourth being graded by a  SingleListGrader . Note that we have set  partial_credit=False  on the nested  ListGrader . This means that both the eigenvalue and eigenvector must be correct as a pair in order to get credit. However, as  partial_credit  is  True  for the highest level  ListGrader , students can get credit for each pair of eigenvalues/eigenvectors individually.  It is possible to specify a grouping on a nested  ListGrader . The outer  ListGrader  must also have a grouping specified if doing so. Here is the same grader as above, where instead of taking the eigenvectors in a single input box list, there are four boxes to input each of the four vector components.   grader = ListGrader(\n...     answers=[\n...         ['1', (['1', '0'], ['-1', '0'])],\n...         ['-1', (['0', '1'], ['0', '-1'])],\n...     ],\n...     subgraders=ListGrader(\n...         subgraders=[\n...             NumericalGrader(),\n...             ListGrader(\n...                 subgraders=NumericalGrader(),\n...                 ordered=True\n...             )\n...         ],\n...         ordered=True,\n...         grouping=[1, 2, 2]\n...     ),\n...     grouping=[1, 1, 1, 2, 2, 2]\n... )  grader(None, ['1', '1', '0', '-1', '1', '1']) == {'overall_message': '',\n...     'input_list': [{'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True},\n...                    {'grade_decimal': 0, 'msg': '', 'ok': False},\n...                    {'grade_decimal': 1, 'msg': '', 'ok': True}]\n...     }\nTrue  In this example, partial credit is turned on everywhere, so only the one entry is graded as incorrect. While we recommend using a  MatrixGrader  instead of entering components in separate boxes like this, this example illustrates how nested  ListGrader s work.", 
            "title": "Grouped Inputs"
        }, 
        {
            "location": "/grading_lists/list_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  ListGrader .  grader = ListGrader(\n    answers=list,  # default []\n    subgraders=(ListGrader, ItemGrader, [ListGrader, ItemGrader]),\n    partial_credit=bool,  # default True\n    ordered=bool,  # default False\n    grouping=list,  # default []\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/plugins/", 
            "text": "Plugins\n # \n\n\nPlugins are an advanced feature of the library that allows users to construct their own custom-built graders, built on top of the infrastructure of the library. They can also be used to allow for straightforward code re-use, and to override library defaults on a course-wide basis.\n\n\nAny \n.py\n file stored in the \nmitxgraders/plugins\n folder will be automatically loaded. All variables in the \n__all__\n list will be made available when doing \nfrom mitxgraders import *\n. See \ntemplate.py\n for an example.\n\n\nYou can define custom grading classes in your plugin. To learn how this works, we recommend copying the code from \nstringgrader.py\n, renaming the class, and building a simple plugin based on \nStringGrader\n.\n\n\nWe are happy to include user-contributed plugins in the repository for this library. If you have built a plugin that you would like to see combined into this library, please contact the authors through \ngithub\n. We are also willing to consider incorporating good plugins into the library itself.\n\n\nOverriding Library Defaults\n # \n\n\nLibrary defaults for any grading class can be specified by constructing the desired dictionary of defaults, and calling \nregister_defaults(dict)\n on the class. For example, to specify that all \nStringGrader\ns should be case-insensitive by default, you can do the following.\n\n\nStringGrader.register_defaults({\n    'case_sensitive': False\n})\n\n\n\n\nWhen this code is included in a file in the plugins folder, it automatically runs every time the library is loaded, leading to course-wide defaults. If for some reason you need to reset to the library defaults for a specific problem, you can call \nclear_registered_defaults()\n on the class in that problem.\n\n\nAn example plugin has been provided for you in \ndefaults_sample.py\n. The code in this plugin is commented out so that it doesn't change anything by default. If you are interested in overriding library defaults on a course-wide basis, we recommend copying this file to \ndefaults.py\n and setting the desired defaults using the code templates provided. This is particularly useful if you wish to use attempt-based partial credit throughout your course.", 
            "title": "Plugins"
        }, 
        {
            "location": "/plugins/#plugins", 
            "text": "Plugins are an advanced feature of the library that allows users to construct their own custom-built graders, built on top of the infrastructure of the library. They can also be used to allow for straightforward code re-use, and to override library defaults on a course-wide basis.  Any  .py  file stored in the  mitxgraders/plugins  folder will be automatically loaded. All variables in the  __all__  list will be made available when doing  from mitxgraders import * . See  template.py  for an example.  You can define custom grading classes in your plugin. To learn how this works, we recommend copying the code from  stringgrader.py , renaming the class, and building a simple plugin based on  StringGrader .  We are happy to include user-contributed plugins in the repository for this library. If you have built a plugin that you would like to see combined into this library, please contact the authors through  github . We are also willing to consider incorporating good plugins into the library itself.", 
            "title": "Plugins"
        }, 
        {
            "location": "/plugins/#overriding-library-defaults", 
            "text": "Library defaults for any grading class can be specified by constructing the desired dictionary of defaults, and calling  register_defaults(dict)  on the class. For example, to specify that all  StringGrader s should be case-insensitive by default, you can do the following.  StringGrader.register_defaults({\n    'case_sensitive': False\n})  When this code is included in a file in the plugins folder, it automatically runs every time the library is loaded, leading to course-wide defaults. If for some reason you need to reset to the library defaults for a specific problem, you can call  clear_registered_defaults()  on the class in that problem.  An example plugin has been provided for you in  defaults_sample.py . The code in this plugin is commented out so that it doesn't change anything by default. If you are interested in overriding library defaults on a course-wide basis, we recommend copying this file to  defaults.py  and setting the desired defaults using the code templates provided. This is particularly useful if you wish to use attempt-based partial credit throughout your course.", 
            "title": "Overriding Library Defaults"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions (FAQs)\n # \n\n\n\n\nDoes the grading library work with multiple choice/checkbox/dropdown lists?\n\n\n\n\nUnfortunately, no. Those problem types cannot be used in a \ncustomresponse\n problem, so we can't grade them with a python grader.", 
            "title": "FAQs"
        }, 
        {
            "location": "/faq/#frequently-asked-questions-faqs", 
            "text": "Does the grading library work with multiple choice/checkbox/dropdown lists?   Unfortunately, no. Those problem types cannot be used in a  customresponse  problem, so we can't grade them with a python grader.", 
            "title": "Frequently Asked Questions (FAQs)"
        }, 
        {
            "location": "/changelog/", 
            "text": "Change Log\n # \n\n\nVersion 2\n # \n\n\nThis is a major new version with many new features added. We have been very careful to preserve backwards compatability of the outward-facing API of the library while adding new features. The biggest change (and the reason for the major version number) is that we are now fully compatible with python versions 2.7, 3.6 and 3.7. All typical applications of version 1.2 should be compatible with version 2.0. However, we do warn that we broke internal backwards compatability in a number of locations in order to accomodate python 3. If you previously wrote custom plugins for version 1.2, we cannot guarantee that they will continue to work in version 2.0.\n\n\nVersion 2.0\n # \n\n\nVersion 2.0.0\n # \n\n\nFeature updates:\n\n\n\n\nGraders can now be constructed in-line in a customresponse, rather than in a python code block.\n\n\nCredit awarded can now be dependent upon the attempt number.\n\n\nIntroduced a new plug-in to set course-wide defaults that differ from library defaults.\n\n\nStringGrader\n received a major overhaul, and can now require minimum character or word lengths, and also pattern match to regular expressions. Further options to treat whitespace were introduced.\n\n\nThe structure of \nSingleListGrader\n answers now uses and extends that used by \nItemGrader\n answers, leading to more general ways of expressing answers and providing feedback to students.\n\n\nAnswers to \nSingleListGrader\n problems can now be inferred from the \nexpect\n keyword.\n\n\nSingleListGrader\n can now warn students that they have missing entries.\n\n\nPartial credit can now be turned off in \nListGrader\n problems.\n\n\nPartial credit can now be awarded in matrix entry problems, with messages explaining which entries are correct.\n\n\nImplemented \nLinearComparer\n, which can assign partial/full credit to formula responses that are linearly related to answers.\n\n\nComparers for math problems can now be set much more straightforwardly.\n\n\nfloor\n, \nceil\n, \nmin\n and \nmax\n functions were added to the math library.\n\n\nIn math problems, introduced an option to apply a transforming function to the answer and student input before comparing.\n\n\nCompletely overhauled matrix sampling to allow most typical matrix types to be sampled.\n\n\nIntroduced instructor variables for math problems, which authors can use in constructing the problem, but students may not use in their responses.\n\n\nDependentSampler\n now has access to constants and user functions, and no longer needs the \ndepends\n key.\n\n\nDiscreteSet\n will now work with arrays.\n\n\nAll comparers are now imported when using \nfrom mitxgraders import *\n.\n\n\n\n\nUnder the hood:\n\n\n\n\nEnsured that the entire library (including tests) is compatible with python 2.7 and python 3.6/3.7, in preparation for edX's upcoming transition to python 3. (The change to having internal unicode literals is the biggest internal backward-compatability-breaking issue from version 1.2.)\n\n\nIntroduced \nCorrelatedComparer\ns, which compare multiple samples at once.\n\n\nIntegralGrader\n has been promoted from a plug-in to a core component of the library.\n\n\nSpecifyDomain\n has been expanded to allow for functions with any number of arguments.\n\n\nJavascript preprocessor was tidied up, and further options for customization were included.\n\n\nAll documentation examples are now run as doctests.\n\n\nUpgraded voluptuous to version 0.11.5.\n\n\nUpgraded testing infrastructure.\n\n\n\n\nBug fixes:\n\n\n\n\nFixed a bug in assigning partial credit in \nListGrader\ns when multiple lists of answers were included.\n\n\n\n\nVersion 1\n # \n\n\nVersion 1.2\n # \n\n\nVersion 1.2.3\n # \n\n\n\n\nAdded new custom comparers \nvector_span_comparer\n and \nvector_phase_comparer\n.\n\n\nUpdated AsciiMath preprocessor to handle lonely \nmover\n (math-over) entries.\n\n\n\n\nVersion 1.2.2\n # \n\n\n\n\nAdded \naccept_any\n and \naccept_nonempty\n options to \nStringGrader\n.\n\n\nIf only a single text input is present, the \nanswers\n key is inferred from the \nexpect\n attribute of the \ncustomresponse\n tag (does not work for \nSingleListInput\n however).\n\n\nUpdated AsciiMath preprocessor to handle variable names and user-defined functions properly.\n\n\nVarious small bug fixes.\n\n\n\n\nVersion 1.2.1\n # \n\n\n\n\nAdded \narctan2(x, y)\n function that returns angle between +x axis and the point (x, y); available by default for students to use in FormulaGrader problems.\n\n\nRewrote the expression parser and evaluator. Among other things, new parser provides better error messages when explicit multiplication is forgotten in expressions like \n'5x + 3'\n. Also validates curly brace balancing, which may be used in tensor variable names.\n\n\n\n\nVersion 1.2.0\n # \n\n\nThis version includes a number of new features and documentation updates.\n\n\n\n\nA new \ndocumentation website\n\n\nMath parser now supports multivariable functions and array input (vector, matrix, etc).\n\n\nMany improvements to our mathjax preprocessor\n\n\nImprovements to balanced bracket validator.\n\n\nAdded new class \nMatrixGrader\n (see \nMatrixGrader documentation\n) along with supporting sampling classes \nRealMatrices\n and \nRealVectors\n\n\nWhen \nFormulaGrader\n (and its subclasses) are used inside an ordered \nListGrader\n, authors can now grade multiple student inputs in comparison to each other by specifying answers in terms of \nsibling variables\n\n\nFormulaGrader\n (and its subclasses) now support \ncomparer functions\n that can be used to grade student input more flexibly. For example, rather than checking checking that the student input and author input are equal, check that they are equal modulo a certain number. Built-in comparers:\n\n\nequality_comparer\n\n\ncongruence_comparer\n\n\nbetween_comparer\n\n\neigenvector_comparer\n\n\n\n\n\n\n\n\nVersion 1.1\n # \n\n\nVersion 1.1.2\n # \n\n\n\n\nThis version includes an internal change to the way that errors are handled during check.\n\n\nIf you only use builtin graders (FormulaGrader, ListGrader...) or public plugins (IntegralGrader) you should not notice any difference.\n\n\nIf you have previously written your own grading class, this change could affect what errors messages are displayed to students. In particular, only exceptions inheriting from \nMITxError\n will display their messages to students; other errors will be replaced with a generic error message.\n\n\n\n\nVersion 1.1.1\n # \n\n\n\n\nAdded AsciiMath renderer definitions\n\n\nWe now check for naming collisions in your configuration\n\n\nCleaned up voluptuous incorporation\n\n\nExtend domain of factorial function to all complex, except negative integers\n\n\nRemoved .pyc files from the zip file\n\n\nMinor bug fixes\n\n\n\n\nVersion 1.1.0\n # \n\n\n\n\nAdded numbered variables to FormulaGrader\n\n\n\n\nRemoved case-insensitive comparisons from FormulaGrader and IntegralGrader.\n\n\n\n\nWarning\n\n\nThis is a departure from edX and is a breaking change for authors who used case-insensitive FormulaGraders. However:\n\n\n\n\nCase-sensitive has always been the default for FormulaGrader and we are not aware of authors using case-insensitive FormulaGraders.\n\n\nPedagogically, we believe that students should think of \nM\n and \nm\n are different variables.\n\n\nRemoving case-insensitive comparison fixes a number of ambiguous situations.\n\n\n\n\n\n\n\n\n\n\nVersion 1.0\n # \n\n\nVersion 1.0.5\n # \n\n\n\n\nImproved debugging information for FormulaGrader\n\n\nFormulaGrader and IntegralGrader perform whitelist, blacklist, and forbidden_string checks after determining answer correctness. Incorrect answers using forbidden strings / functions are now marked incorrect, while correct answers using forbidden strings / functions raise errors.\n\n\nMinor improvements to existing unit tests\n\n\n\n\nVersion 1.0.4\n # \n\n\n\n\nAuthors can now specify a custom comparer function for FormulaGrader\n\n\nIntegralGrader now handles complex integrands, and gives meaningful error messages\n  for complex limits.\n\n\nMiscellaneous bug fixes for tensor variable name parsing\n\n\n\n\nVersion 1.0.3\n # \n\n\n\n\nAdded tensor variable names\n\n\n\n\nVersion 1.0.2\n # \n\n\n\n\nAdded error messages for overflow, division-by-zero, and out-of-domain errors in formulas\n\n\nAdded tests to reach 100% coverage\n\n\nRemoved redundant code\n\n\nFixed some bugs in unused code\n\n\n\n\nVersion 1.0.1\n # \n\n\n\n\nAdded DependentSampler\n\n\nFixed issue with zip file tests\n\n\nAdded doctests to test suite\n\n\nFixed bug in FormulaGrader when given an empty string\n\n\n\n\nVersion 1.0.0\n # \n\n\n\n\nFirst release!", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#change-log", 
            "text": "", 
            "title": "Change Log"
        }, 
        {
            "location": "/changelog/#version-2", 
            "text": "This is a major new version with many new features added. We have been very careful to preserve backwards compatability of the outward-facing API of the library while adding new features. The biggest change (and the reason for the major version number) is that we are now fully compatible with python versions 2.7, 3.6 and 3.7. All typical applications of version 1.2 should be compatible with version 2.0. However, we do warn that we broke internal backwards compatability in a number of locations in order to accomodate python 3. If you previously wrote custom plugins for version 1.2, we cannot guarantee that they will continue to work in version 2.0.", 
            "title": "Version 2"
        }, 
        {
            "location": "/changelog/#version-20", 
            "text": "", 
            "title": "Version 2.0"
        }, 
        {
            "location": "/changelog/#version-200", 
            "text": "Feature updates:   Graders can now be constructed in-line in a customresponse, rather than in a python code block.  Credit awarded can now be dependent upon the attempt number.  Introduced a new plug-in to set course-wide defaults that differ from library defaults.  StringGrader  received a major overhaul, and can now require minimum character or word lengths, and also pattern match to regular expressions. Further options to treat whitespace were introduced.  The structure of  SingleListGrader  answers now uses and extends that used by  ItemGrader  answers, leading to more general ways of expressing answers and providing feedback to students.  Answers to  SingleListGrader  problems can now be inferred from the  expect  keyword.  SingleListGrader  can now warn students that they have missing entries.  Partial credit can now be turned off in  ListGrader  problems.  Partial credit can now be awarded in matrix entry problems, with messages explaining which entries are correct.  Implemented  LinearComparer , which can assign partial/full credit to formula responses that are linearly related to answers.  Comparers for math problems can now be set much more straightforwardly.  floor ,  ceil ,  min  and  max  functions were added to the math library.  In math problems, introduced an option to apply a transforming function to the answer and student input before comparing.  Completely overhauled matrix sampling to allow most typical matrix types to be sampled.  Introduced instructor variables for math problems, which authors can use in constructing the problem, but students may not use in their responses.  DependentSampler  now has access to constants and user functions, and no longer needs the  depends  key.  DiscreteSet  will now work with arrays.  All comparers are now imported when using  from mitxgraders import * .   Under the hood:   Ensured that the entire library (including tests) is compatible with python 2.7 and python 3.6/3.7, in preparation for edX's upcoming transition to python 3. (The change to having internal unicode literals is the biggest internal backward-compatability-breaking issue from version 1.2.)  Introduced  CorrelatedComparer s, which compare multiple samples at once.  IntegralGrader  has been promoted from a plug-in to a core component of the library.  SpecifyDomain  has been expanded to allow for functions with any number of arguments.  Javascript preprocessor was tidied up, and further options for customization were included.  All documentation examples are now run as doctests.  Upgraded voluptuous to version 0.11.5.  Upgraded testing infrastructure.   Bug fixes:   Fixed a bug in assigning partial credit in  ListGrader s when multiple lists of answers were included.", 
            "title": "Version 2.0.0"
        }, 
        {
            "location": "/changelog/#version-1", 
            "text": "", 
            "title": "Version 1"
        }, 
        {
            "location": "/changelog/#version-12", 
            "text": "", 
            "title": "Version 1.2"
        }, 
        {
            "location": "/changelog/#version-123", 
            "text": "Added new custom comparers  vector_span_comparer  and  vector_phase_comparer .  Updated AsciiMath preprocessor to handle lonely  mover  (math-over) entries.", 
            "title": "Version 1.2.3"
        }, 
        {
            "location": "/changelog/#version-122", 
            "text": "Added  accept_any  and  accept_nonempty  options to  StringGrader .  If only a single text input is present, the  answers  key is inferred from the  expect  attribute of the  customresponse  tag (does not work for  SingleListInput  however).  Updated AsciiMath preprocessor to handle variable names and user-defined functions properly.  Various small bug fixes.", 
            "title": "Version 1.2.2"
        }, 
        {
            "location": "/changelog/#version-121", 
            "text": "Added  arctan2(x, y)  function that returns angle between +x axis and the point (x, y); available by default for students to use in FormulaGrader problems.  Rewrote the expression parser and evaluator. Among other things, new parser provides better error messages when explicit multiplication is forgotten in expressions like  '5x + 3' . Also validates curly brace balancing, which may be used in tensor variable names.", 
            "title": "Version 1.2.1"
        }, 
        {
            "location": "/changelog/#version-120", 
            "text": "This version includes a number of new features and documentation updates.   A new  documentation website  Math parser now supports multivariable functions and array input (vector, matrix, etc).  Many improvements to our mathjax preprocessor  Improvements to balanced bracket validator.  Added new class  MatrixGrader  (see  MatrixGrader documentation ) along with supporting sampling classes  RealMatrices  and  RealVectors  When  FormulaGrader  (and its subclasses) are used inside an ordered  ListGrader , authors can now grade multiple student inputs in comparison to each other by specifying answers in terms of  sibling variables  FormulaGrader  (and its subclasses) now support  comparer functions  that can be used to grade student input more flexibly. For example, rather than checking checking that the student input and author input are equal, check that they are equal modulo a certain number. Built-in comparers:  equality_comparer  congruence_comparer  between_comparer  eigenvector_comparer", 
            "title": "Version 1.2.0"
        }, 
        {
            "location": "/changelog/#version-11", 
            "text": "", 
            "title": "Version 1.1"
        }, 
        {
            "location": "/changelog/#version-112", 
            "text": "This version includes an internal change to the way that errors are handled during check.  If you only use builtin graders (FormulaGrader, ListGrader...) or public plugins (IntegralGrader) you should not notice any difference.  If you have previously written your own grading class, this change could affect what errors messages are displayed to students. In particular, only exceptions inheriting from  MITxError  will display their messages to students; other errors will be replaced with a generic error message.", 
            "title": "Version 1.1.2"
        }, 
        {
            "location": "/changelog/#version-111", 
            "text": "Added AsciiMath renderer definitions  We now check for naming collisions in your configuration  Cleaned up voluptuous incorporation  Extend domain of factorial function to all complex, except negative integers  Removed .pyc files from the zip file  Minor bug fixes", 
            "title": "Version 1.1.1"
        }, 
        {
            "location": "/changelog/#version-110", 
            "text": "Added numbered variables to FormulaGrader   Removed case-insensitive comparisons from FormulaGrader and IntegralGrader.   Warning  This is a departure from edX and is a breaking change for authors who used case-insensitive FormulaGraders. However:   Case-sensitive has always been the default for FormulaGrader and we are not aware of authors using case-insensitive FormulaGraders.  Pedagogically, we believe that students should think of  M  and  m  are different variables.  Removing case-insensitive comparison fixes a number of ambiguous situations.", 
            "title": "Version 1.1.0"
        }, 
        {
            "location": "/changelog/#version-10", 
            "text": "", 
            "title": "Version 1.0"
        }, 
        {
            "location": "/changelog/#version-105", 
            "text": "Improved debugging information for FormulaGrader  FormulaGrader and IntegralGrader perform whitelist, blacklist, and forbidden_string checks after determining answer correctness. Incorrect answers using forbidden strings / functions are now marked incorrect, while correct answers using forbidden strings / functions raise errors.  Minor improvements to existing unit tests", 
            "title": "Version 1.0.5"
        }, 
        {
            "location": "/changelog/#version-104", 
            "text": "Authors can now specify a custom comparer function for FormulaGrader  IntegralGrader now handles complex integrands, and gives meaningful error messages\n  for complex limits.  Miscellaneous bug fixes for tensor variable name parsing", 
            "title": "Version 1.0.4"
        }, 
        {
            "location": "/changelog/#version-103", 
            "text": "Added tensor variable names", 
            "title": "Version 1.0.3"
        }, 
        {
            "location": "/changelog/#version-102", 
            "text": "Added error messages for overflow, division-by-zero, and out-of-domain errors in formulas  Added tests to reach 100% coverage  Removed redundant code  Fixed some bugs in unused code", 
            "title": "Version 1.0.2"
        }, 
        {
            "location": "/changelog/#version-101", 
            "text": "Added DependentSampler  Fixed issue with zip file tests  Added doctests to test suite  Fixed bug in FormulaGrader when given an empty string", 
            "title": "Version 1.0.1"
        }, 
        {
            "location": "/changelog/#version-100", 
            "text": "First release!", 
            "title": "Version 1.0.0"
        }
    ]
}