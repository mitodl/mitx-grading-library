{
    "docs": [
        {
            "location": "/", 
            "text": "MITx Grading Library Documentation\n\uf0c1\n\n\nThis documentation describes how to use the grading library. In particular, it goes through the syntax required to construct each of the different types of graders.\n\n\nFor information on installation and how to use the library in edX, see \nGetting Started\n.\n\n\nOverview\n\uf0c1\n\n\nThe basic idea of this library is that it contains a number of classes that can be used as the check function for an edX custom response problem. Different classes of grader are used for different inputs. We begin by presenting a brief overview on how the grading classes are used in general.\n\n\nUsing Grading Classes\n\uf0c1\n\n\nAll grading classes are instantiated by calling them. Here, \nGradingClass\n is a generic grading class (\nGradingClass\n does not actually exist).\n\n\ngrader = GradingClass(options)\n\n\n\n\nThe options provided to a grading class may be passed in directly, as\n\n\ngrader = GradingClass(name='value')\n\n\n\n\nYou can also pass in a configuration dictionary. This may be helpful if using the same configuration for multiple problems.\n\n\noptions = {'name': 'value'}\ngrader = GradingClass(options)\n\n\n\n\nYou cannot 'mix and match' these two options. If a configuration dictionary is supplied, any keyword arguments are ignored.\n\n\nOptions\n\uf0c1\n\n\nThe options passed to a grading class undergo extensive validation and graders will throw\nerrors if instantiated with invalid options.\n\n\nA few error messages serve only as warnings (e.g., that you are attempting to override a default constant like \npi\n). These warning errors can be suppressed by setting\n\n\ngrader = GradingClass(suppress_warnings=True)\n\n\n\n\nEvery grading class also has a debug option. By default, \ndebug=False\n. To receive debug information from a given grader, specify \ndebug=True\n. Some graders will provide more debug information than others.\n\n\ngrader = GradingClass(debug=True)\n\n\n\n\nAll other options are specific to the grading class in question.\n\n\nGrading Classes\n\uf0c1\n\n\nGrading classes generally fall into two categories: single-input graders and multi-input graders.\n\n\nAll graders that grade a single input are built on a framework we call an ItemGrader. We recommend understanding how ItemGraders work before diving into more specifics. We provide a number of graders built off ItemGrader. A special type of ItemGrader is SingleListGrader, which lets you grade a delimiter-separated list of inputs in a single response.\n\n\nMulti-input graders that are just composed of single-input graders working in concert can be handled by the general ListGrader class. At this stage, ListGrader is the only multi-input grader included in the library, although plugins can be used to construct further examples.\n\n\n\n\nItemGrader\n\n\nStringGrader\n\n\nFormulaGrader\n\n\nNumericalGrader\n\n\nSingleListGrader\n\n\nListGrader\n\n\n\n\nPlugins\n\uf0c1\n\n\nAny .py file stored in the \nplugins\n folder will be automatically loaded. All variables in the \nall\n list will be made available when doing \nfrom mitxgraders import *\n. See \ntemplate.py\n for an example.\n\n\nYou can define custom grading classes in your plugin. To learn how this works, we recommend copying the code from \nstringgrader.py\n, renaming the class, and building a simple plugin based on \nStringGrader\n.\n\n\nWe are happy to include user-contributed plugins in the repository for this library. If you have built a plugin that you would like to see combined into this library, please contact the authors through \ngithub\n. We are also willing to consider incorporating good plugins into the library itself.", 
            "title": "Home"
        }, 
        {
            "location": "/#mitx-grading-library-documentation", 
            "text": "This documentation describes how to use the grading library. In particular, it goes through the syntax required to construct each of the different types of graders.  For information on installation and how to use the library in edX, see  Getting Started .", 
            "title": "MITx Grading Library Documentation"
        }, 
        {
            "location": "/#overview", 
            "text": "The basic idea of this library is that it contains a number of classes that can be used as the check function for an edX custom response problem. Different classes of grader are used for different inputs. We begin by presenting a brief overview on how the grading classes are used in general.", 
            "title": "Overview"
        }, 
        {
            "location": "/#using-grading-classes", 
            "text": "All grading classes are instantiated by calling them. Here,  GradingClass  is a generic grading class ( GradingClass  does not actually exist).  grader = GradingClass(options)  The options provided to a grading class may be passed in directly, as  grader = GradingClass(name='value')  You can also pass in a configuration dictionary. This may be helpful if using the same configuration for multiple problems.  options = {'name': 'value'}\ngrader = GradingClass(options)  You cannot 'mix and match' these two options. If a configuration dictionary is supplied, any keyword arguments are ignored.", 
            "title": "Using Grading Classes"
        }, 
        {
            "location": "/#options", 
            "text": "The options passed to a grading class undergo extensive validation and graders will throw\nerrors if instantiated with invalid options.  A few error messages serve only as warnings (e.g., that you are attempting to override a default constant like  pi ). These warning errors can be suppressed by setting  grader = GradingClass(suppress_warnings=True)  Every grading class also has a debug option. By default,  debug=False . To receive debug information from a given grader, specify  debug=True . Some graders will provide more debug information than others.  grader = GradingClass(debug=True)  All other options are specific to the grading class in question.", 
            "title": "Options"
        }, 
        {
            "location": "/#grading-classes", 
            "text": "Grading classes generally fall into two categories: single-input graders and multi-input graders.  All graders that grade a single input are built on a framework we call an ItemGrader. We recommend understanding how ItemGraders work before diving into more specifics. We provide a number of graders built off ItemGrader. A special type of ItemGrader is SingleListGrader, which lets you grade a delimiter-separated list of inputs in a single response.  Multi-input graders that are just composed of single-input graders working in concert can be handled by the general ListGrader class. At this stage, ListGrader is the only multi-input grader included in the library, although plugins can be used to construct further examples.   ItemGrader  StringGrader  FormulaGrader  NumericalGrader  SingleListGrader  ListGrader", 
            "title": "Grading Classes"
        }, 
        {
            "location": "/#plugins", 
            "text": "Any .py file stored in the  plugins  folder will be automatically loaded. All variables in the  all  list will be made available when doing  from mitxgraders import * . See  template.py  for an example.  You can define custom grading classes in your plugin. To learn how this works, we recommend copying the code from  stringgrader.py , renaming the class, and building a simple plugin based on  StringGrader .  We are happy to include user-contributed plugins in the repository for this library. If you have built a plugin that you would like to see combined into this library, please contact the authors through  github . We are also willing to consider incorporating good plugins into the library itself.", 
            "title": "Plugins"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Getting Started\n\uf0c1\n\n\nUsage in edX\n\uf0c1\n\n\nDownload \npython_lib.zip\n and place it in your static folder (XML workflow) or upload it as a file asset (Studio workflow). If you already have a python_lib.zip, you'll need to merge ours with yours and re-zip. If you want to use our AsciiMath renderer definitions, place the \nMjxPrep.js\n file in your static folder (XML) or upload the file to your course (Studio).\n\n\nMITxGraders: Reusable CustomResponse Check Functions\n\uf0c1\n\n\nA custom response problem is defined using the \ncustomresponse\n tag. It needs to be supplied with a particular type of Python function that edX calls a check function (or \"cfn\"). The mitxgraders library provides reusable check functions. The basic usage pattern is:\n\n\nscript type=\ntext/python\n system_path=\npython_lib\n\nfrom mitxgraders import *\ngrader = GraderType(\n    [configuration]\n)\n\n/script\n\n\n\ncustomresponse cfn=\ngrader\n\n    \ntextline/\n\n\n/customresponse\n\n\n\n\n\nThe configuration depends on the type of grader that you're using. Note that all answers must be passed through the configuration. In particular, the \nexpect\n  attribute on \ncustomresponse\n tag is ignored by our graders (but can be used to display an answer string to students).\n\n\nHere is an example where we use a StringGrader with answer \ncat\n.\n\n\nscript type=\ntext/python\n system_path=\npython_lib\n\nfrom mitxgraders import *\ngrader = StringGrader(\n    answers='cat'\n)\n\n/script\n\n\n\ncustomresponse cfn=\ngrader\n\n    \ntextline correct_answer=\ncat\n/\n\n\n/customresponse\n\n\n\n\n\nThe \nexpect\n keyword is ignored by the grader, but is shown when students click on \"Show Answer\". This works only for single-input problems.\n\n\nHere is another example where we use a ListGrader to grade two numbers in an unordered fashion.\n\n\nscript type=\ntext/python\n system_path=\npython_lib\n\nfrom mitxgraders import *\ngrader = ListGrader(\n    answers=['1', '2'],\n    subgraders=FormulaGrader()\n)\n\n/script\n\n\n\ncustomresponse cfn=\ngrader\n\n    \ntextline correct_answer=\n1\n/\n\n    \ntextline correct_answer=\n2\n/\n\n\n/customresponse\n\n\n\n\n\nHere, the \ncorrect_answer\n entries are shown to students when they click \"Show Answer\". These values are not provided to the grader. The \ncorrect_answer\n attributes can also be used for single-input problems.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting_started/#usage-in-edx", 
            "text": "Download  python_lib.zip  and place it in your static folder (XML workflow) or upload it as a file asset (Studio workflow). If you already have a python_lib.zip, you'll need to merge ours with yours and re-zip. If you want to use our AsciiMath renderer definitions, place the  MjxPrep.js  file in your static folder (XML) or upload the file to your course (Studio).", 
            "title": "Usage in edX"
        }, 
        {
            "location": "/getting_started/#mitxgraders-reusable-customresponse-check-functions", 
            "text": "A custom response problem is defined using the  customresponse  tag. It needs to be supplied with a particular type of Python function that edX calls a check function (or \"cfn\"). The mitxgraders library provides reusable check functions. The basic usage pattern is:  script type= text/python  system_path= python_lib \nfrom mitxgraders import *\ngrader = GraderType(\n    [configuration]\n) /script  customresponse cfn= grader \n     textline/  /customresponse   The configuration depends on the type of grader that you're using. Note that all answers must be passed through the configuration. In particular, the  expect   attribute on  customresponse  tag is ignored by our graders (but can be used to display an answer string to students).  Here is an example where we use a StringGrader with answer  cat .  script type= text/python  system_path= python_lib \nfrom mitxgraders import *\ngrader = StringGrader(\n    answers='cat'\n) /script  customresponse cfn= grader \n     textline correct_answer= cat /  /customresponse   The  expect  keyword is ignored by the grader, but is shown when students click on \"Show Answer\". This works only for single-input problems.  Here is another example where we use a ListGrader to grade two numbers in an unordered fashion.  script type= text/python  system_path= python_lib \nfrom mitxgraders import *\ngrader = ListGrader(\n    answers=['1', '2'],\n    subgraders=FormulaGrader()\n) /script  customresponse cfn= grader \n     textline correct_answer= 1 / \n     textline correct_answer= 2 /  /customresponse   Here, the  correct_answer  entries are shown to students when they click \"Show Answer\". These values are not provided to the grader. The  correct_answer  attributes can also be used for single-input problems.", 
            "title": "MITxGraders: Reusable CustomResponse Check Functions"
        }, 
        {
            "location": "/item_grader/", 
            "text": "ItemGrader\n\uf0c1\n\n\nWhen an individual input needs to be graded, it is graded by an item grader. All item graders work by specifying answers and their corresponding points/messages, as well as an optional message for wrong answers. In these examples, we use \nStringGrader\n as an example of how to use a generic ItemGrader. You cannot use a generic ItemGrader by itself.\n\n\ngrader = StringGrader(\n    answers='cat',\n    wrong_msg='Try again!'\n)\n\n\n\n\nThe \nanswers\n can be used to specify correct answers, specific feedback messages, and to assign partial credit. The \nanswers\n key accepts a few formats:\n\n\n\n\nA single dictionary can be used to specify an answer, feedback, correctness, and partial credit:\n\n\n\n\ngrader = StringGrader(\n    answers={'expect': 'zebra', 'ok': True, 'grade_decimal': 1, 'msg': 'Yay!'},\n    wrong_msg='Try again!'\n)\n\n\n\n\nThe answers dictionary keys are:\n  - \n'expect'\n (required): compared against student answer. Most ItemGraders use strings to specify the \n'expect'\n value.\n  - \n'grade_decimal'\n (a number between \n0\n and \n1\n): The partial credit associated with this answer; default value is \n1\n.\n  - \n'ok'\n (\nTrue\n, \nFalse\n, or \n'partial'\n): The answer's correctness; determines icon used by edX. The default value is inferred from \ngrade_decimal\n.\n  - \n'msg'\n (string): A feedback message associated with this answer.\n\n\n\n\nA single \n'expect'\n value: can be used to specify the correct answer. For example,\n\n\n\n\ngrader = StringGrader(\n    answers='cat',\n    # Equivalent to:\n    # answers={'expect': 'cat', 'msg': '', 'grade_decimal': 1, 'ok': True}\n    wrong_msg='Try again!'\n)\n\n\n\n\nAgain, most ItemGraders use strings to store \n'expect'\n values.\n\n\n\n\nA tuple of dictionaries or strings:\n\n\n\n\ngrader = StringGrader(\n    answers=(\n        # the correct answer\n        'wolf',\n        # an alternative correct answer\n        'canis lupus',\n        # a partially correct answer\n        {'expect': 'dog', 'grade_decimal': 0.5, 'msg': 'No, not dog!'},\n        # a wrong answer with specific feedback\n        {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'No, not unicorn!'}\n    ),\n    wrong_msg='Try again!'\n)\n\n\n\n\nInternally, the ItemGrader converts the answers entry into a tuple of dictionaries. When grading, it asks the specific grading class to grade the response against each possible answer, and selects the best outcome for the student.\n\n\nThe \nwrong_msg\n is only displayed if the score is zero, and there are no other messages.\n\n\nOption Listing\n\uf0c1\n\n\nHere is the full list of options specific to an \nItemGrader\n.\n\n\ngrader = ItemGrader(\n    answers=answer or tuple of answers,\n    wrong_msg=string (default '')\n)", 
            "title": "ItemGrader"
        }, 
        {
            "location": "/item_grader/#itemgrader", 
            "text": "When an individual input needs to be graded, it is graded by an item grader. All item graders work by specifying answers and their corresponding points/messages, as well as an optional message for wrong answers. In these examples, we use  StringGrader  as an example of how to use a generic ItemGrader. You cannot use a generic ItemGrader by itself.  grader = StringGrader(\n    answers='cat',\n    wrong_msg='Try again!'\n)  The  answers  can be used to specify correct answers, specific feedback messages, and to assign partial credit. The  answers  key accepts a few formats:   A single dictionary can be used to specify an answer, feedback, correctness, and partial credit:   grader = StringGrader(\n    answers={'expect': 'zebra', 'ok': True, 'grade_decimal': 1, 'msg': 'Yay!'},\n    wrong_msg='Try again!'\n)  The answers dictionary keys are:\n  -  'expect'  (required): compared against student answer. Most ItemGraders use strings to specify the  'expect'  value.\n  -  'grade_decimal'  (a number between  0  and  1 ): The partial credit associated with this answer; default value is  1 .\n  -  'ok'  ( True ,  False , or  'partial' ): The answer's correctness; determines icon used by edX. The default value is inferred from  grade_decimal .\n  -  'msg'  (string): A feedback message associated with this answer.   A single  'expect'  value: can be used to specify the correct answer. For example,   grader = StringGrader(\n    answers='cat',\n    # Equivalent to:\n    # answers={'expect': 'cat', 'msg': '', 'grade_decimal': 1, 'ok': True}\n    wrong_msg='Try again!'\n)  Again, most ItemGraders use strings to store  'expect'  values.   A tuple of dictionaries or strings:   grader = StringGrader(\n    answers=(\n        # the correct answer\n        'wolf',\n        # an alternative correct answer\n        'canis lupus',\n        # a partially correct answer\n        {'expect': 'dog', 'grade_decimal': 0.5, 'msg': 'No, not dog!'},\n        # a wrong answer with specific feedback\n        {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'No, not unicorn!'}\n    ),\n    wrong_msg='Try again!'\n)  Internally, the ItemGrader converts the answers entry into a tuple of dictionaries. When grading, it asks the specific grading class to grade the response against each possible answer, and selects the best outcome for the student.  The  wrong_msg  is only displayed if the score is zero, and there are no other messages.", 
            "title": "ItemGrader"
        }, 
        {
            "location": "/item_grader/#option-listing", 
            "text": "Here is the full list of options specific to an  ItemGrader .  grader = ItemGrader(\n    answers=answer or tuple of answers,\n    wrong_msg=string (default '')\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/string_grader/", 
            "text": "StringGrader\n\uf0c1\n\n\nThe StringGrader class does a letter-for-letter comparison of the student's answer with the expected answer. It is the simplest grading class, both in code and in usage.\n\n\nTo use a StringGrader, simply pass in the set of answers you want to grade, as described in the \nItemGrader documentation\n.\n\n\ngrader = StringGrader(\n    answers='cat'\n)\n\n\n\n\nThis will accept the answer of \ncat\n, but not \nCAT\n or \nCat\n, as grading is case-sensitive by default.\n\n\nCase Sensitive\n\uf0c1\n\n\nTo perform case-insensitive grading, pass in the appropriate flag as follows.\n\n\ngrader = StringGrader(\n    answers='Cat',\n    case_sensitive=False\n)\n\n\n\n\nThis will accept \nCat\n, \ncat\n and \nCAT\n. By default, \ncase_sensitive=True\n.\n\n\nStripping Input\n\uf0c1\n\n\nLeading or trailing spaces in an answer rarely change the meaning of the answer. Hence, by default, we strip all leading and trailing spaces from the student input and author-specified answers before comparison. If you want to keep those spaces around for the comparison, you need to disable strip.\n\n\ngrader = StringGrader(\n    answers='cat',\n    strip=False\n)\n\n\n\n\nThis will accept \ncat\n, but will reject answers with leading or trailing spaces. By default, \nstrip=True\n.\n\n\nOption Listing\n\uf0c1\n\n\nHere is the full list of options specific to a \nStringGrader\n.\n\n\ngrader = SingleListGrader(\n    case_sensitive=bool (default True),\n    strip=bool (default False)\n)", 
            "title": "StringGrader"
        }, 
        {
            "location": "/string_grader/#stringgrader", 
            "text": "The StringGrader class does a letter-for-letter comparison of the student's answer with the expected answer. It is the simplest grading class, both in code and in usage.  To use a StringGrader, simply pass in the set of answers you want to grade, as described in the  ItemGrader documentation .  grader = StringGrader(\n    answers='cat'\n)  This will accept the answer of  cat , but not  CAT  or  Cat , as grading is case-sensitive by default.", 
            "title": "StringGrader"
        }, 
        {
            "location": "/string_grader/#case-sensitive", 
            "text": "To perform case-insensitive grading, pass in the appropriate flag as follows.  grader = StringGrader(\n    answers='Cat',\n    case_sensitive=False\n)  This will accept  Cat ,  cat  and  CAT . By default,  case_sensitive=True .", 
            "title": "Case Sensitive"
        }, 
        {
            "location": "/string_grader/#stripping-input", 
            "text": "Leading or trailing spaces in an answer rarely change the meaning of the answer. Hence, by default, we strip all leading and trailing spaces from the student input and author-specified answers before comparison. If you want to keep those spaces around for the comparison, you need to disable strip.  grader = StringGrader(\n    answers='cat',\n    strip=False\n)  This will accept  cat , but will reject answers with leading or trailing spaces. By default,  strip=True .", 
            "title": "Stripping Input"
        }, 
        {
            "location": "/string_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  StringGrader .  grader = SingleListGrader(\n    case_sensitive=bool (default True),\n    strip=bool (default False)\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/grading_math/formula_grader/", 
            "text": "FormulaGrader\n\uf0c1\n\n\nFormulaGrader is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's \nformularesponse /\n tag, but with much more versatility.\n\n\n\n\nNote\n\n\n\n\nAll expressions are treated in a case sensitive manner. This means that variables \n'm'\n and \n'M'\n are distinct. Case-insensitive FormulaGraders were deprecated in \nVersion 1.1.0\n\n\nAll whitespace is stripped from formulas that are entered. So, \n1 + x ^ 2\n is equivalent to \n1+x^2\n.\n\n\n\n\n\n\nVariables and Sampling\n\uf0c1\n\n\nFormulaGrader grades a formula by numerical sampling. That is, random values are  assigned to each of the unknown variables and unknown functions, then the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct.\n\n\nVariables are configured by including a list of strings of each variable name as follows.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2+y',\n    variables=['x', 'y']\n)\n\n\n\n\nNote that the \nanswers\n parameter follows all of the usual allowances from ItemGrader.\n\n\nThe variables need to have numbers randomly assigned to them. Each is sampled from a \nsampling set\n, which is RealInterval() by default (random numbers from 1 to 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the \nsample_from\n key.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2+y+z/2',\n    variables=['x', 'y', 'z'],\n    sample_from={\n        'x': ComplexRectangle(),\n        'y': [2, 6],\n        'z': (1, 3, 4, 8)\n    }\n)\n\n\n\n\nThe \nsample_from\n key must be a dictionary of 'variable_name': sampling_set pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.\n\n\nNumbered Variables\n\uf0c1\n\n\nYou can also specify special variables that are numbered. For example, if you specify that \na\n is a numbered variable, students can include \na_{0}\n, \na_{5}\n, \na_{-2}\n, etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name.\n\n\ngrader = FormulaGrader(\n    answers='a_{0} + a_{1}*x + 1/2*a_{2}*x^2',\n    variables=['x'],\n    numbered_vars=['a'],\n    sample_from={\n        'x': [-5, 5],\n        'a': [-10, 10]\n    }\n)\n\n\n\n\nIf you have a variable name that would clash with a numbered variable (say, you defined \na_{0}\n and also a numbered variable \na\n), then the specific variable has precedence.\n\n\nSamples and Failable Evaluations\n\uf0c1\n\n\nTo control the number of samples that are checked to ensure correctness, you can modify the \nsamples\n key.\n\n\ngrader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10\n)\n\n\n\n\nThe default for \nsamples\n is 5.\n\n\nYou may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set \nfailable_evals\n. This should be used very sparingly!\n\n\ngrader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10,\n    failable_evals=1\n)\n\n\n\n\nFunctions\n\uf0c1\n\n\nBy default, a large array of mathematical functions are available for use. See the full list \nhere\n. Note that functions for manipulating complex variables are available, which allows you to grade complex expressions. In the following example, \nz*z\n is recognized to be different from \nabs(z)^2\n.\n\n\ngrader = FormulaGrader(\n    answers='abs(z)^2',\n    variables=['z'],\n    sample_from={\n        'z': ComplexRectangle()\n    }\n)\n\n\n\n\nUser Functions\n\uf0c1\n\n\nYou can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the \nuser_functions\n key as follows.\n\n\ngrader = FormulaGrader(\n    answers='x*x',\n    variables=['x'],\n    user_functions={'f': lambda x: x*x}\n)\n\n\n\n\nThis defines a function \nf(x) = x^2\n. User-defined function names must start with a letter, and can use numbers and underscores, such as \nmy_func2\n. They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg, \nf''\n. Be careful about using quotation marks appropriately when using primes in function names!\n\n\ngrader = FormulaGrader(\n    answers=\nf''(x)\n,\n    variables=['x'],\n    user_functions={\nf''\n: lambda x: x*x}\n)\n\n\n\n\nYou can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows.\n\n\ngrader = FormulaGrader(\n    answers=\nf(x)\n,\n    variables=['x'],\n    user_functions={\nf\n: [np.sin, np.cos]}\n)\n\n\n\n\nEach time this formula is checked, the function \nf\n will be sampled from the list of available functions.\n\n\nYou can also specify a random well-behaved function by using the RandomFunction() sampling set.\n\n\ngrader = FormulaGrader(\n    answers=\nf''(x) + omega^2*f(x)\n,\n    variables=['x', 'omega'],\n    user_functions={\n        \nf\n: RandomFunction(),\n        \nf''\n: RandomFunction()\n    }\n)\n\n\n\n\nThis allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example.\n\n\nConstants\n\uf0c1\n\n\nBy default, four constants are defined: \ne\n, \npi\n, and \ni=j=sqrt(-1)\n. You can define new constants by passing in a dictionary to \nuser_constants\n as follows.\n\n\ngrader = FormulaGrader(\n    answers='1/sqrt(1-v^2/c^2)',\n    variables=['v'],\n    user_constants={\n        'c': 3e8\n    }\n)\n\n\n\n\nConstants are like variables that only ever have one value.\n\n\nOverriding Default Functions and Constants\n\uf0c1\n\n\nYou can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with \nsuppress_warnings=True\n. The grader\n\n\ngrader = FormulaGrader(\n    answers='x^2',\n    variables=['x'],\n    user_functions={'sin': lambda x: x*x},\n)\n\n\n\n\nwill raise an error\n\n\n\n\nConfigError: Warning: 'user_functions' contains entries '['sin']' which will override default values. If you intend to override to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.\n\n\n\n\nThe error can be suppressed by setting \nsuppress_warnings=True\n.\n\n\nRestricting Student Input\n\uf0c1\n\n\nFor some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand \nsin(2*theta)\n, then you don't want students to be able to just write \nsin(2*theta)\n and be graded correct.\n\n\nFormulaGrader offers a few ways to restrict what sort of answers will be marked correct.\n\n\nForbidden Strings\n\uf0c1\n\n\nYou can forbid students from entering certain strings using the \nforbidden_strings\n key:\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    forbidden_strings=['*theta', 'theta*', 'theta/', '+theta', 'theta+', '-theta', 'theta-'],\n    forbidden_message=\nYour answer should only use trigonometric functions acting on theta, not multiples of theta\n\n)\n\n\n\n\nIf a student tries to use one of these strings, then they receive the \nforbidden_message\n, without giving away what the forbidden string is. We recommend using this sparingly, as students will find it confusing. The default \nforbidden_message\n is \"Invalid Input: This particular answer is forbidden\".\n\n\nForbidden strings and student answers are stripped of whitespace before being compared. Thus, if \nx + y\n is forbidden, then answers containing \nx+y\n or \nx   +   y\n will be rejected.\n\n\nBlacklists and Whitelists\n\uf0c1\n\n\nYou can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example, \nsin\n is disallowed in correct answers.\n\n\ngrader = FormulaGrader(\n    answers='sqrt(1 - cos(x)^2)',\n    variables=['x'],\n    sample_from={'x': [0, np.pi]},\n    blacklist=['sin']\n)\n\n\n\n\nIf you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are sin and cos.\n\n\ngrader = FormulaGrader(\n    answers='sin(x)/cos(x)',\n    variables=['x'],\n    whitelist=['sin', 'cos']\n)\n\n\n\n\nIf you want to exclude all functions, use \nwhitelist=[None]\n:\n\n\ngrader = FormulaGrader(\n    answers='pi/2-x',\n    variables=['x'],\n    whitelist=[None] # no functions are allowed\n)\n\n\n\n\nYou cannot use a whitelist and a blacklist at the same time.\n\n\nRequired Functions\n\uf0c1\n\n\nYou can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required.\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    required_functions=['sin', 'cos']\n)\n\n\n\n\nTolerance\n\uf0c1\n\n\nStudent inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg, \n0.1\n) or a percentage (eg, \n\"0.01%\"\n, which is the default tolerance).  Tolerances must be nonnegative numbers or percentages.\n\n\ngrader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    tolerance=0.00001\n)\n\n\n\n\nTolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers.\n\n\nSuffixes\n\uf0c1\n\n\nNumbers with a % at the end will be treated as percentages, and converted to the appropriate decimals.\n\n\nedX also defines a number of metric suffixes (k, M, G, T, m, u, n, and p) that modify a number appropriately. However, in our experience, these metric suffixes lead to more confusion than use. For example, \n2M\n, which one would expect should be rejected as an error when \n2*M\n was intended, is accepted by edX, interpreted as \n2*10^6\n, marked incorrect, and eats a student's attempt. Similarly for all of the other metric suffixes.\n\n\nWe have therefore made the decision to disable metric suffixes by default. If you want to enable them, you can do so using the following.\n\n\ngrader = FormulaGrader(\n    answers='2*m',\n    variables=['m'],\n    metric_suffixes=True\n)\n\n\n\n\nWe strongly recommend \nnot\n doing this when using the following variable names: k, M, G, T, m, u, n, and p.\n\n\nComparer Functions\n\uf0c1\n\n\nBy default, FormulaGrader compares the numerically sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. For example, if grading angles in degrees, it may be useful to compare formulas modulo 360.\n\n\nTo use an alternate comparer, specify the \nanswers\n key as a dictionary with keys \ncomparer\n and \ncomparer_params\n rather than a single string. For example, to compare formulas modulo 360:\n\n\ndef is_coterminal(comparer_params_evals, student_eval, utils):\n    answer = comparer_params_evals[0]\n    reduced = student_eval % (360)\n    return utils.within_tolerance(answer, reduced)\n\ngrader = FormulaGrader(\n    answers={\n        'comparer': is_coterminal,\n        'comparer_params': ['b^2/a'],\n    },\n    variables=['a', 'b'],\n    tolerance='1%'\n)\n\n\n\n\nThis grader would accept \n'b^2/a'\n as well as \n'b^2/a + 360'\n, \n'b^2/a + 720'\n, etc.\n\n\nIn the grader configuration, \ncomparer_params\n is a list of strings that are numerically evaluated and passed to the comparer function. The \ncomparer\n function is a user-specified function with signature \ncomparer(comparer_params_evals, student_eval, utils)\n. When \nFormulaGrader\n calls the comparer function, \ncomparer\n the argument values are:\n- \ncomparer_params_evals\n: The \ncomparer_params\n list, numerically evaluated according to variable and function sampling.\n- \nstudent_eval\n: The student's input, numerically evaluated according to variable and function sampling\n- \nutils\n: A convenience object that may be helpful when writing custom comparer functions. Has properties:\n  - \nutils.tolerance\n: The tolerance specified in grader configuration, \n0.01%\n by default\n  - \nutils.within_tolerance:\n A function with signature \nwithin_tolerance(x, y)\n which checks that \ny\n is within specified tolerance of \nx\n. Can handle scalars, vectors, and matrices. If tolerance was specified as a percentage, then checks that \n|x-y| \n tolerance * x\n.\n\n\nOther Improvements\n\uf0c1\n\n\nWe have made a number of other improvements over the edX formula graders, including:\n\n\n\n\nSquare roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like \nsqrt(x-1)\n or \n(x-1)^0.5\n always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases.\n\n\nOur parser uses a parsing cache, and hence runs much more efficiently than the edX graders.\n\n\nIf students input an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue.\n\n\nWhen students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable.\n\n\nSimilarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing.\n\n\nIf an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the \ndebug\n flag to True, and a more technical message will usually be displayed.\n\n\nFull sampling details are included when the \ndebug\n flag is set to True.\n\n\nEnhancements to the AsciiMath renderer (the preview that students see when using \ntextline\n inputs) are available using our \nAsciiMath renderer definitions\n.", 
            "title": "FormulaGrader"
        }, 
        {
            "location": "/grading_math/formula_grader/#formulagrader", 
            "text": "FormulaGrader is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's  formularesponse /  tag, but with much more versatility.   Note   All expressions are treated in a case sensitive manner. This means that variables  'm'  and  'M'  are distinct. Case-insensitive FormulaGraders were deprecated in  Version 1.1.0  All whitespace is stripped from formulas that are entered. So,  1 + x ^ 2  is equivalent to  1+x^2 .", 
            "title": "FormulaGrader"
        }, 
        {
            "location": "/grading_math/formula_grader/#variables-and-sampling", 
            "text": "FormulaGrader grades a formula by numerical sampling. That is, random values are  assigned to each of the unknown variables and unknown functions, then the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct.  Variables are configured by including a list of strings of each variable name as follows.  grader = FormulaGrader(\n    answers='1+x^2+y',\n    variables=['x', 'y']\n)  Note that the  answers  parameter follows all of the usual allowances from ItemGrader.  The variables need to have numbers randomly assigned to them. Each is sampled from a  sampling set , which is RealInterval() by default (random numbers from 1 to 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the  sample_from  key.  grader = FormulaGrader(\n    answers='1+x^2+y+z/2',\n    variables=['x', 'y', 'z'],\n    sample_from={\n        'x': ComplexRectangle(),\n        'y': [2, 6],\n        'z': (1, 3, 4, 8)\n    }\n)  The  sample_from  key must be a dictionary of 'variable_name': sampling_set pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.", 
            "title": "Variables and Sampling"
        }, 
        {
            "location": "/grading_math/formula_grader/#numbered-variables", 
            "text": "You can also specify special variables that are numbered. For example, if you specify that  a  is a numbered variable, students can include  a_{0} ,  a_{5} ,  a_{-2} , etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name.  grader = FormulaGrader(\n    answers='a_{0} + a_{1}*x + 1/2*a_{2}*x^2',\n    variables=['x'],\n    numbered_vars=['a'],\n    sample_from={\n        'x': [-5, 5],\n        'a': [-10, 10]\n    }\n)  If you have a variable name that would clash with a numbered variable (say, you defined  a_{0}  and also a numbered variable  a ), then the specific variable has precedence.", 
            "title": "Numbered Variables"
        }, 
        {
            "location": "/grading_math/formula_grader/#samples-and-failable-evaluations", 
            "text": "To control the number of samples that are checked to ensure correctness, you can modify the  samples  key.  grader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10\n)  The default for  samples  is 5.  You may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set  failable_evals . This should be used very sparingly!  grader = FormulaGrader(\n    answers='1+x^2',\n    variables=['x'],\n    samples=10,\n    failable_evals=1\n)", 
            "title": "Samples and Failable Evaluations"
        }, 
        {
            "location": "/grading_math/formula_grader/#functions", 
            "text": "By default, a large array of mathematical functions are available for use. See the full list  here . Note that functions for manipulating complex variables are available, which allows you to grade complex expressions. In the following example,  z*z  is recognized to be different from  abs(z)^2 .  grader = FormulaGrader(\n    answers='abs(z)^2',\n    variables=['z'],\n    sample_from={\n        'z': ComplexRectangle()\n    }\n)", 
            "title": "Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#user-functions", 
            "text": "You can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the  user_functions  key as follows.  grader = FormulaGrader(\n    answers='x*x',\n    variables=['x'],\n    user_functions={'f': lambda x: x*x}\n)  This defines a function  f(x) = x^2 . User-defined function names must start with a letter, and can use numbers and underscores, such as  my_func2 . They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg,  f'' . Be careful about using quotation marks appropriately when using primes in function names!  grader = FormulaGrader(\n    answers= f''(x) ,\n    variables=['x'],\n    user_functions={ f'' : lambda x: x*x}\n)  You can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows.  grader = FormulaGrader(\n    answers= f(x) ,\n    variables=['x'],\n    user_functions={ f : [np.sin, np.cos]}\n)  Each time this formula is checked, the function  f  will be sampled from the list of available functions.  You can also specify a random well-behaved function by using the RandomFunction() sampling set.  grader = FormulaGrader(\n    answers= f''(x) + omega^2*f(x) ,\n    variables=['x', 'omega'],\n    user_functions={\n         f : RandomFunction(),\n         f'' : RandomFunction()\n    }\n)  This allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example.", 
            "title": "User Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#constants", 
            "text": "By default, four constants are defined:  e ,  pi , and  i=j=sqrt(-1) . You can define new constants by passing in a dictionary to  user_constants  as follows.  grader = FormulaGrader(\n    answers='1/sqrt(1-v^2/c^2)',\n    variables=['v'],\n    user_constants={\n        'c': 3e8\n    }\n)  Constants are like variables that only ever have one value.", 
            "title": "Constants"
        }, 
        {
            "location": "/grading_math/formula_grader/#overriding-default-functions-and-constants", 
            "text": "You can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with  suppress_warnings=True . The grader  grader = FormulaGrader(\n    answers='x^2',\n    variables=['x'],\n    user_functions={'sin': lambda x: x*x},\n)  will raise an error   ConfigError: Warning: 'user_functions' contains entries '['sin']' which will override default values. If you intend to override to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration.   The error can be suppressed by setting  suppress_warnings=True .", 
            "title": "Overriding Default Functions and Constants"
        }, 
        {
            "location": "/grading_math/formula_grader/#restricting-student-input", 
            "text": "For some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand  sin(2*theta) , then you don't want students to be able to just write  sin(2*theta)  and be graded correct.  FormulaGrader offers a few ways to restrict what sort of answers will be marked correct.", 
            "title": "Restricting Student Input"
        }, 
        {
            "location": "/grading_math/formula_grader/#forbidden-strings", 
            "text": "You can forbid students from entering certain strings using the  forbidden_strings  key:  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    forbidden_strings=['*theta', 'theta*', 'theta/', '+theta', 'theta+', '-theta', 'theta-'],\n    forbidden_message= Your answer should only use trigonometric functions acting on theta, not multiples of theta \n)  If a student tries to use one of these strings, then they receive the  forbidden_message , without giving away what the forbidden string is. We recommend using this sparingly, as students will find it confusing. The default  forbidden_message  is \"Invalid Input: This particular answer is forbidden\".  Forbidden strings and student answers are stripped of whitespace before being compared. Thus, if  x + y  is forbidden, then answers containing  x+y  or  x   +   y  will be rejected.", 
            "title": "Forbidden Strings"
        }, 
        {
            "location": "/grading_math/formula_grader/#blacklists-and-whitelists", 
            "text": "You can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example,  sin  is disallowed in correct answers.  grader = FormulaGrader(\n    answers='sqrt(1 - cos(x)^2)',\n    variables=['x'],\n    sample_from={'x': [0, np.pi]},\n    blacklist=['sin']\n)  If you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are sin and cos.  grader = FormulaGrader(\n    answers='sin(x)/cos(x)',\n    variables=['x'],\n    whitelist=['sin', 'cos']\n)  If you want to exclude all functions, use  whitelist=[None] :  grader = FormulaGrader(\n    answers='pi/2-x',\n    variables=['x'],\n    whitelist=[None] # no functions are allowed\n)  You cannot use a whitelist and a blacklist at the same time.", 
            "title": "Blacklists and Whitelists"
        }, 
        {
            "location": "/grading_math/formula_grader/#required-functions", 
            "text": "You can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required.  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    required_functions=['sin', 'cos']\n)", 
            "title": "Required Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#tolerance", 
            "text": "Student inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg,  0.1 ) or a percentage (eg,  \"0.01%\" , which is the default tolerance).  Tolerances must be nonnegative numbers or percentages.  grader = FormulaGrader(\n    answers='2*sin(theta)*cos(theta)',\n    variables=['theta'],\n    tolerance=0.00001\n)  Tolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers.", 
            "title": "Tolerance"
        }, 
        {
            "location": "/grading_math/formula_grader/#suffixes", 
            "text": "Numbers with a % at the end will be treated as percentages, and converted to the appropriate decimals.  edX also defines a number of metric suffixes (k, M, G, T, m, u, n, and p) that modify a number appropriately. However, in our experience, these metric suffixes lead to more confusion than use. For example,  2M , which one would expect should be rejected as an error when  2*M  was intended, is accepted by edX, interpreted as  2*10^6 , marked incorrect, and eats a student's attempt. Similarly for all of the other metric suffixes.  We have therefore made the decision to disable metric suffixes by default. If you want to enable them, you can do so using the following.  grader = FormulaGrader(\n    answers='2*m',\n    variables=['m'],\n    metric_suffixes=True\n)  We strongly recommend  not  doing this when using the following variable names: k, M, G, T, m, u, n, and p.", 
            "title": "Suffixes"
        }, 
        {
            "location": "/grading_math/formula_grader/#comparer-functions", 
            "text": "By default, FormulaGrader compares the numerically sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. For example, if grading angles in degrees, it may be useful to compare formulas modulo 360.  To use an alternate comparer, specify the  answers  key as a dictionary with keys  comparer  and  comparer_params  rather than a single string. For example, to compare formulas modulo 360:  def is_coterminal(comparer_params_evals, student_eval, utils):\n    answer = comparer_params_evals[0]\n    reduced = student_eval % (360)\n    return utils.within_tolerance(answer, reduced)\n\ngrader = FormulaGrader(\n    answers={\n        'comparer': is_coterminal,\n        'comparer_params': ['b^2/a'],\n    },\n    variables=['a', 'b'],\n    tolerance='1%'\n)  This grader would accept  'b^2/a'  as well as  'b^2/a + 360' ,  'b^2/a + 720' , etc.  In the grader configuration,  comparer_params  is a list of strings that are numerically evaluated and passed to the comparer function. The  comparer  function is a user-specified function with signature  comparer(comparer_params_evals, student_eval, utils) . When  FormulaGrader  calls the comparer function,  comparer  the argument values are:\n-  comparer_params_evals : The  comparer_params  list, numerically evaluated according to variable and function sampling.\n-  student_eval : The student's input, numerically evaluated according to variable and function sampling\n-  utils : A convenience object that may be helpful when writing custom comparer functions. Has properties:\n  -  utils.tolerance : The tolerance specified in grader configuration,  0.01%  by default\n  -  utils.within_tolerance:  A function with signature  within_tolerance(x, y)  which checks that  y  is within specified tolerance of  x . Can handle scalars, vectors, and matrices. If tolerance was specified as a percentage, then checks that  |x-y|   tolerance * x .", 
            "title": "Comparer Functions"
        }, 
        {
            "location": "/grading_math/formula_grader/#other-improvements", 
            "text": "We have made a number of other improvements over the edX formula graders, including:   Square roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like  sqrt(x-1)  or  (x-1)^0.5  always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases.  Our parser uses a parsing cache, and hence runs much more efficiently than the edX graders.  If students input an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue.  When students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable.  Similarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing.  If an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the  debug  flag to True, and a more technical message will usually be displayed.  Full sampling details are included when the  debug  flag is set to True.  Enhancements to the AsciiMath renderer (the preview that students see when using  textline  inputs) are available using our  AsciiMath renderer definitions .", 
            "title": "Other Improvements"
        }, 
        {
            "location": "/grading_math/numerical_grader/", 
            "text": "NumericalGrader\n\uf0c1\n\n\nWhen grading math expressions without functions or variables, you can use NumericalGrader instead of FormulaGrader. NumericalGrader is a specialized version of FormulaGrader whose behavior resembles the edX \nnumericalresponse/\n tag.\n\n\nConfiguration\n\uf0c1\n\n\nNumericalGrader has all of the same options as FormulaGrader except:\n\n\n\n\ntolerance\n: has a higher default value of \n'5%'\n\n\nfailable_evals\n is always set to 0\n\n\nsamples\n is always set to 1\n\n\nvariables\n is always set to \n[]\n (no variables allowed)\n\n\nsample_from\n is always set to \n{}\n (no variables allowed)\n\n\nuser_functions\n can only define specific functions, with no random functions\n\n\n\n\nIf you are grading simple integers (such as 0, 1, 2, -1, etc), you may want to consider using StringGrader instead of NumericalGrader.", 
            "title": "NumericalGrader"
        }, 
        {
            "location": "/grading_math/numerical_grader/#numericalgrader", 
            "text": "When grading math expressions without functions or variables, you can use NumericalGrader instead of FormulaGrader. NumericalGrader is a specialized version of FormulaGrader whose behavior resembles the edX  numericalresponse/  tag.", 
            "title": "NumericalGrader"
        }, 
        {
            "location": "/grading_math/numerical_grader/#configuration", 
            "text": "NumericalGrader has all of the same options as FormulaGrader except:   tolerance : has a higher default value of  '5%'  failable_evals  is always set to 0  samples  is always set to 1  variables  is always set to  []  (no variables allowed)  sample_from  is always set to  {}  (no variables allowed)  user_functions  can only define specific functions, with no random functions   If you are grading simple integers (such as 0, 1, 2, -1, etc), you may want to consider using StringGrader instead of NumericalGrader.", 
            "title": "Configuration"
        }, 
        {
            "location": "/grading_math/sampling/", 
            "text": "Sampling\n\uf0c1\n\n\nWhenever random variables/functions are involved, they need to be sampled from an appropriate distribution. In this library, distributions are defined in classes that are called \nsampling sets\n. We have defined a number of sampling sets for various common situations, but you can also create your own by using plugins.\n\n\nThese sampling classes are available for use in FormulaGrader.\n\n\nTable of Contents\n\n\n\n\nVariable Names\n\n\nVariable Sampling\n\n\nRealInterval\n\n\nIntegerRange\n\n\nDiscreteSet\n\n\nComplexRectangle\n\n\nComplexSector\n\n\nDependentSampler\n\n\nFunction Sampling\n\n\nSpecificFunctions\n\n\nRandomFunction\n\n\n\n\nVariable Names\n\uf0c1\n\n\nVariable names must start with a letter, and can continue with letters, numbers, and underscores. Variable names may conclude with an arbitrary number of apostrophes. The same naming conventions apply to user-defined constants.\n\n\nIt is also possible to have tensor variable names. The following three forms are available:\n\n\n\n\nT^{ijk}\n\n\nT_{ijk}\n\n\nT_{ijk}^{123} (note that lowered indices must come first)\n\n\n\n\nThe tensor name itself must start with a letter, and may continue with letters and numbers. The indices may be any combination of letters and numbers. After the indices, you may have apostrophes, such as T^{ijk}'' (tensors can be differentiated too!).\n\n\nVariable Sampling\n\uf0c1\n\n\nThese sampling sets generate a random number on demand. It may be real or complex.\n\n\nRealInterval\n\uf0c1\n\n\nSample from a real interval defined by a \nstart\n and a \nstop\n value. RealInterval can be initialized using explicit values, or an interval.\n\n\n# Generate random real numbers between 3 and 7\nsampler = RealInterval(start=3, stop=7)\n# This is equivalent to\nsampler = RealInterval([3, 7])\n# The default is [1, 5]\nsampler = RealInterval()\n\n\n\n\nIntegerRange\n\uf0c1\n\n\nSample from an integer defined by a \nstart\n and a \nstop\n value (both start and stop are included in the range). IntegerRange can be initialized using explicit values, or an interval.\n\n\n# Generate random integers between 3 and 7 inclusive\nsampler = IntegerRange(start=3, stop=7)\n# This is equivalent to\nsampler = IntegerRange([3, 7])\n# The default is [1, 5]\nsampler = IntegerRange()\n\n\n\n\nDiscreteSet\n\uf0c1\n\n\nSample from a discrete set of values, specified in a tuple. A single value may also be provided, but this case should usually be specified as a constant instead of as a sampling set.\n\n\n# Select random numbers from (1, 3, 5, 7, 9)\nsampler = DiscreteSet((1, 3, 5, 7, 9))\n# Always select 3.5\nsampler = DiscreteSet(3.5)\n\n\n\n\nComplexRectangle\n\uf0c1\n\n\nSample complex numbers from a rectangle in the complex plane, specified by a real range and an imaginary range.\n\n\n# Select random complex numbers from 0 to 1 + i\nsampler = ComplexRectangle(re=[0, 1], im=[0, 1])\n# The default is re=[1, 3], im=[1, 3]\nsampler = ComplexRectangle()\n\n\n\n\nComplexSector\n\uf0c1\n\n\nSample complex numbers from an annular sector in the complex plane, specified by a modulus range and an argument range.\n\n\n# Select random complex numbers from inside the unit circle\nsampler = ComplexSector(modulus=[0, 1], argument=[-np.pi, np.pi])\n# The default is modulus=[1, 3], argument=[0, pi/2]\nsampler = ComplexSector()\n\n\n\n\nDependentSampler\n\uf0c1\n\n\nCompute a value for a variable based on the values of other variables. The sampler must be initialized with a list of variables that it depends on, as well as the formula used to perform the computation. The formula can use any base functions, but no user-defined functions. DependentSamplers can depend on other dependent variables. If you construct a self-referential chain, an error will occur.\n\n\n# Set radius based on the random values of x, y and z\nsampler = DependentSampler(depends=[\nx\n, \ny\n, \nz\n], formula=\nsqrt(x^2+y^2+z^2)\n)\n\n\n\n\nFunction Sampling\n\uf0c1\n\n\nWhen a random function can be specified, we need a sampling set that returns a random function on demand.\n\n\nSpecificFunctions\n\uf0c1\n\n\nSamples functions from a specific list of functions. You can also specify just a single function, but usually this shouldn't be done as a sampling set.\n\n\n# Select either sin or cos randomly\nfunctionsampler = SpecificFunctions([np.cos, np.sin])\n# Always select a single lambda function\nfunctionsampler = SpecificFunctions(lambda x: x*x)\n\n\n\n\nRandomFunction\n\uf0c1\n\n\nGenerate a random well-behaved function. The function is constructed from the sum of sinusoids with random amplitudes, frequencies and phases. It oscillates about a specified center value with up to a specified amplitude.\n\n\n# Generate a random function\nfunctionsampler = RandomFunction(center=1, amplitude=2)\n# The default is center=0, amplitude=10\nfunctionsampler = RandomFunction()\n\n\n\n\nYou can control how many random sinusoids are added together by specifying \nnum_terms\n.\n\n\n# Generate a random sinusoid\nfunctionsampler = RandomFunction(num_terms=1)\n\n\n\n\nYou can also generate a non-unary function by specifying the input dimension, and generate vector output by specifying the output dimension.\n\n\n# Generate a function that takes in two values and outputs a 3D vector\nfunctionsampler = RandomFunction(input_dim=2, output_dim=3)", 
            "title": "Sampling Sets"
        }, 
        {
            "location": "/grading_math/sampling/#sampling", 
            "text": "Whenever random variables/functions are involved, they need to be sampled from an appropriate distribution. In this library, distributions are defined in classes that are called  sampling sets . We have defined a number of sampling sets for various common situations, but you can also create your own by using plugins.  These sampling classes are available for use in FormulaGrader.  Table of Contents   Variable Names  Variable Sampling  RealInterval  IntegerRange  DiscreteSet  ComplexRectangle  ComplexSector  DependentSampler  Function Sampling  SpecificFunctions  RandomFunction", 
            "title": "Sampling"
        }, 
        {
            "location": "/grading_math/sampling/#variable-names", 
            "text": "Variable names must start with a letter, and can continue with letters, numbers, and underscores. Variable names may conclude with an arbitrary number of apostrophes. The same naming conventions apply to user-defined constants.  It is also possible to have tensor variable names. The following three forms are available:   T^{ijk}  T_{ijk}  T_{ijk}^{123} (note that lowered indices must come first)   The tensor name itself must start with a letter, and may continue with letters and numbers. The indices may be any combination of letters and numbers. After the indices, you may have apostrophes, such as T^{ijk}'' (tensors can be differentiated too!).", 
            "title": "Variable Names"
        }, 
        {
            "location": "/grading_math/sampling/#variable-sampling", 
            "text": "These sampling sets generate a random number on demand. It may be real or complex.", 
            "title": "Variable Sampling"
        }, 
        {
            "location": "/grading_math/sampling/#realinterval", 
            "text": "Sample from a real interval defined by a  start  and a  stop  value. RealInterval can be initialized using explicit values, or an interval.  # Generate random real numbers between 3 and 7\nsampler = RealInterval(start=3, stop=7)\n# This is equivalent to\nsampler = RealInterval([3, 7])\n# The default is [1, 5]\nsampler = RealInterval()", 
            "title": "RealInterval"
        }, 
        {
            "location": "/grading_math/sampling/#integerrange", 
            "text": "Sample from an integer defined by a  start  and a  stop  value (both start and stop are included in the range). IntegerRange can be initialized using explicit values, or an interval.  # Generate random integers between 3 and 7 inclusive\nsampler = IntegerRange(start=3, stop=7)\n# This is equivalent to\nsampler = IntegerRange([3, 7])\n# The default is [1, 5]\nsampler = IntegerRange()", 
            "title": "IntegerRange"
        }, 
        {
            "location": "/grading_math/sampling/#discreteset", 
            "text": "Sample from a discrete set of values, specified in a tuple. A single value may also be provided, but this case should usually be specified as a constant instead of as a sampling set.  # Select random numbers from (1, 3, 5, 7, 9)\nsampler = DiscreteSet((1, 3, 5, 7, 9))\n# Always select 3.5\nsampler = DiscreteSet(3.5)", 
            "title": "DiscreteSet"
        }, 
        {
            "location": "/grading_math/sampling/#complexrectangle", 
            "text": "Sample complex numbers from a rectangle in the complex plane, specified by a real range and an imaginary range.  # Select random complex numbers from 0 to 1 + i\nsampler = ComplexRectangle(re=[0, 1], im=[0, 1])\n# The default is re=[1, 3], im=[1, 3]\nsampler = ComplexRectangle()", 
            "title": "ComplexRectangle"
        }, 
        {
            "location": "/grading_math/sampling/#complexsector", 
            "text": "Sample complex numbers from an annular sector in the complex plane, specified by a modulus range and an argument range.  # Select random complex numbers from inside the unit circle\nsampler = ComplexSector(modulus=[0, 1], argument=[-np.pi, np.pi])\n# The default is modulus=[1, 3], argument=[0, pi/2]\nsampler = ComplexSector()", 
            "title": "ComplexSector"
        }, 
        {
            "location": "/grading_math/sampling/#dependentsampler", 
            "text": "Compute a value for a variable based on the values of other variables. The sampler must be initialized with a list of variables that it depends on, as well as the formula used to perform the computation. The formula can use any base functions, but no user-defined functions. DependentSamplers can depend on other dependent variables. If you construct a self-referential chain, an error will occur.  # Set radius based on the random values of x, y and z\nsampler = DependentSampler(depends=[ x ,  y ,  z ], formula= sqrt(x^2+y^2+z^2) )", 
            "title": "DependentSampler"
        }, 
        {
            "location": "/grading_math/sampling/#function-sampling", 
            "text": "When a random function can be specified, we need a sampling set that returns a random function on demand.", 
            "title": "Function Sampling"
        }, 
        {
            "location": "/grading_math/sampling/#specificfunctions", 
            "text": "Samples functions from a specific list of functions. You can also specify just a single function, but usually this shouldn't be done as a sampling set.  # Select either sin or cos randomly\nfunctionsampler = SpecificFunctions([np.cos, np.sin])\n# Always select a single lambda function\nfunctionsampler = SpecificFunctions(lambda x: x*x)", 
            "title": "SpecificFunctions"
        }, 
        {
            "location": "/grading_math/sampling/#randomfunction", 
            "text": "Generate a random well-behaved function. The function is constructed from the sum of sinusoids with random amplitudes, frequencies and phases. It oscillates about a specified center value with up to a specified amplitude.  # Generate a random function\nfunctionsampler = RandomFunction(center=1, amplitude=2)\n# The default is center=0, amplitude=10\nfunctionsampler = RandomFunction()  You can control how many random sinusoids are added together by specifying  num_terms .  # Generate a random sinusoid\nfunctionsampler = RandomFunction(num_terms=1)  You can also generate a non-unary function by specifying the input dimension, and generate vector output by specifying the output dimension.  # Generate a function that takes in two values and outputs a 3D vector\nfunctionsampler = RandomFunction(input_dim=2, output_dim=3)", 
            "title": "RandomFunction"
        }, 
        {
            "location": "/grading_math/function_list/", 
            "text": "Function Listing\n\uf0c1\n\n\nBy default, all of the following functions are made available to students.\n\n\n\n\nsin()\n Sine\n\n\ncos()\n Cosine\n\n\ntan()\n Tangent\n\n\nsec()\n Secant\n\n\ncsc()\n Cosecant\n\n\ncot()\n Cotangent\n\n\nsqrt()\n Square Root\n\n\nlog10()\n Log (base 10)*\n\n\nlog2()\n Log (base 2)*\n\n\nln()\n Natural logarithm\n\n\nexp()\n Exponential\n\n\narccos()\n Inverse Cosine\n\n\narcsin()\n Inverse Sine\n\n\narctan()\n Inverse Tangent\n\n\narcsec()\n Inverse Secant*\n\n\narccsc()\n Inverse Cosecant*\n\n\narccot()\n Inverse Cotangent*\n\n\nabs()\n Absolute value (real) or modulus (complex)\n\n\nfactorial()\n and \nfact()\n Factorial (only applies to integers)*\n\n\nsinh()\n Hyperbolic Sine\n\n\ncosh()\n Hyperbolic Cosine\n\n\ntanh()\n Hyperbolic Tangent\n\n\nsech()\n Hyperbolic Secant\n\n\ncsch()\n Hyperbolic Cosecant\n\n\ncoth()\n Hyperbolic Cotangent\n\n\narcsinh()\n Inverse Hyperbolic Sine*\n\n\narccosh()\n Inverse Hyperbolic Cosine*\n\n\narctanh()\n Inverse Hyperbolic Tangent*\n\n\narcsech()\n Inverse Hyperbolic Secant*\n\n\narccsch()\n Inverse Hyperbolic Cosecant*\n\n\narccoth()\n Inverse Hyperbolic Cotangent*\n\n\nre()\n Real part of a complex expression*\n\n\nim()\n Imaginary part of a complex expression*\n\n\nconj()\n Complex conjugate of a complex expression*\n\n\n\n\nExpressions marked with a * may require our \nAsciiMath renderer definitions\n to display properly in edX.", 
            "title": "Function List"
        }, 
        {
            "location": "/grading_math/function_list/#function-listing", 
            "text": "By default, all of the following functions are made available to students.   sin()  Sine  cos()  Cosine  tan()  Tangent  sec()  Secant  csc()  Cosecant  cot()  Cotangent  sqrt()  Square Root  log10()  Log (base 10)*  log2()  Log (base 2)*  ln()  Natural logarithm  exp()  Exponential  arccos()  Inverse Cosine  arcsin()  Inverse Sine  arctan()  Inverse Tangent  arcsec()  Inverse Secant*  arccsc()  Inverse Cosecant*  arccot()  Inverse Cotangent*  abs()  Absolute value (real) or modulus (complex)  factorial()  and  fact()  Factorial (only applies to integers)*  sinh()  Hyperbolic Sine  cosh()  Hyperbolic Cosine  tanh()  Hyperbolic Tangent  sech()  Hyperbolic Secant  csch()  Hyperbolic Cosecant  coth()  Hyperbolic Cotangent  arcsinh()  Inverse Hyperbolic Sine*  arccosh()  Inverse Hyperbolic Cosine*  arctanh()  Inverse Hyperbolic Tangent*  arcsech()  Inverse Hyperbolic Secant*  arccsch()  Inverse Hyperbolic Cosecant*  arccoth()  Inverse Hyperbolic Cotangent*  re()  Real part of a complex expression*  im()  Imaginary part of a complex expression*  conj()  Complex conjugate of a complex expression*   Expressions marked with a * may require our  AsciiMath renderer definitions  to display properly in edX.", 
            "title": "Function Listing"
        }, 
        {
            "location": "/grading_math/renderer/", 
            "text": "AsciiMath Renderer Definitions\n\uf0c1\n\n\nWhen math input is expected from students, edX offers a math preview that attempts to show their expression in normal mathematical notation. There are two ways to provide this preview:\n\n\nformulaequationinput/\n\nor\n\ntextline math=\n1\n/\n\n\n\n\n\nThe \nformulaequationinput\n tag uses server-side parsing and rendering to display the preview to the student. By and large, the preview from \nformulaequationinput\n is better than that of \ntextline\n, as it treats functions correctly, and displays a number of LaTeX symbols natively. The downsides to \nformulaequationinput\n are that it doesn't recognize vectors such as \nvecx\n or \nhatx\n, the factorial and conjugation functions just apply as \nfact(x)\n and \nconj(x)\n, and because the processing is done server-side, we are unable to enhance the display at all.\n\n\nThe \ntextline\n tag treats the student input as AsciiMath for the purpose of generating a preview, using MathJax to render it. While the preview does a reasonably good job, there are many situations where it falls down, even for standard edX functions (for example, try typing in \n1/arctanh(x)\n in textline box!). Because this is done client-side through javascript, it's possible to supplement the AsciiMath definitions to handle new situations. We have constructed a series of renderer definitions to supplement the standard AsciiMath definitions in order to provide better previews.\n\n\nThis article describes how to use our new AsciiMath renderer definitions with a \ntextline\n tag.\n\n\nHow it works\n\uf0c1\n\n\nThe renderer definitions are located in a javascript file, \nMJxPrep.js\n, which should be uploaded to the static assets folder for your course. This javascript file loads two components: symbol definitions and a preprocessor.\n\n\nThe symbol definitions are used to teach AsciiMath how to display various functions properly, such as \nre\n, \nim\n, \narctanh\n etc. To load the symbol definitions in a problem, place the following HTML code somewhere in the problem.\n\n\nscript type=\ntext/javascript\n src=\n/static/MJxPrep.js\n/script\n\n\n\n\n\nSome functions are too complex for a symbol definition, and need the student's input to be preprocessed into AsciiMath before rendering. These functions are \nlog10\n, \nlog2\n, \nfact\n and \nfactorial\n. To use these, you need to add \npreprocessorClassName\n and \npreprocessorSrc\n properties to any textline tags that use the preprocessor.\n\n\ncustomresponse cfn=\ngrader\n\n    \ntextline correct_answer=\n1/fact(5)\n math=\n1\n preprocessorClassName=\nMJxPrep\n preprocessorSrc=\n/static/MJxPrep.js\n/\n\n\n/customresponse\n\n\n\n\n\nIf you use the preprocessor in your problem, you get the symbol definitions as well (you don't need to load them separately).\n\n\nNotes\n\uf0c1\n\n\n\n\n\n\nNote that you don't need to use the grading library to take advantage of the symbol definitions and/or the preprocessor; they work just as well for the normal edX \nformularesponse\n problems!\n\n\n\n\n\n\nThe javascript is constructed to only load its definitions once, no matter how many times the file is loaded. It's safe to use the preprocessor in as many \ntextline\n boxes as you like.\n\n\n\n\n\n\nIf you have a display issue with AsciiMath, it's likely that you can extend the symbol definitions and preprocessor to make your expressions display nicely for students.\n\n\n\n\n\n\nThe \nfunction listing\n article provides the complete list of functions that are corrected by the new AsciiMath renderer definitions.", 
            "title": "AsciiMath Renderer Definitions"
        }, 
        {
            "location": "/grading_math/renderer/#asciimath-renderer-definitions", 
            "text": "When math input is expected from students, edX offers a math preview that attempts to show their expression in normal mathematical notation. There are two ways to provide this preview:  formulaequationinput/ \nor textline math= 1 /   The  formulaequationinput  tag uses server-side parsing and rendering to display the preview to the student. By and large, the preview from  formulaequationinput  is better than that of  textline , as it treats functions correctly, and displays a number of LaTeX symbols natively. The downsides to  formulaequationinput  are that it doesn't recognize vectors such as  vecx  or  hatx , the factorial and conjugation functions just apply as  fact(x)  and  conj(x) , and because the processing is done server-side, we are unable to enhance the display at all.  The  textline  tag treats the student input as AsciiMath for the purpose of generating a preview, using MathJax to render it. While the preview does a reasonably good job, there are many situations where it falls down, even for standard edX functions (for example, try typing in  1/arctanh(x)  in textline box!). Because this is done client-side through javascript, it's possible to supplement the AsciiMath definitions to handle new situations. We have constructed a series of renderer definitions to supplement the standard AsciiMath definitions in order to provide better previews.  This article describes how to use our new AsciiMath renderer definitions with a  textline  tag.", 
            "title": "AsciiMath Renderer Definitions"
        }, 
        {
            "location": "/grading_math/renderer/#how-it-works", 
            "text": "The renderer definitions are located in a javascript file,  MJxPrep.js , which should be uploaded to the static assets folder for your course. This javascript file loads two components: symbol definitions and a preprocessor.  The symbol definitions are used to teach AsciiMath how to display various functions properly, such as  re ,  im ,  arctanh  etc. To load the symbol definitions in a problem, place the following HTML code somewhere in the problem.  script type= text/javascript  src= /static/MJxPrep.js /script   Some functions are too complex for a symbol definition, and need the student's input to be preprocessed into AsciiMath before rendering. These functions are  log10 ,  log2 ,  fact  and  factorial . To use these, you need to add  preprocessorClassName  and  preprocessorSrc  properties to any textline tags that use the preprocessor.  customresponse cfn= grader \n     textline correct_answer= 1/fact(5)  math= 1  preprocessorClassName= MJxPrep  preprocessorSrc= /static/MJxPrep.js /  /customresponse   If you use the preprocessor in your problem, you get the symbol definitions as well (you don't need to load them separately).", 
            "title": "How it works"
        }, 
        {
            "location": "/grading_math/renderer/#notes", 
            "text": "Note that you don't need to use the grading library to take advantage of the symbol definitions and/or the preprocessor; they work just as well for the normal edX  formularesponse  problems!    The javascript is constructed to only load its definitions once, no matter how many times the file is loaded. It's safe to use the preprocessor in as many  textline  boxes as you like.    If you have a display issue with AsciiMath, it's likely that you can extend the symbol definitions and preprocessor to make your expressions display nicely for students.    The  function listing  article provides the complete list of functions that are corrected by the new AsciiMath renderer definitions.", 
            "title": "Notes"
        }, 
        {
            "location": "/grading_lists/list_grader/", 
            "text": "ListGrader\n\uf0c1\n\n\nA \nListGrader\n is used to grade a list of student inputs wherein each input is entered in a separate answer box. (In contrast, \nSingleListGrader\n can be used to grade a list of items entered all at once into a single answer box.) ListGraders work by farming out individual items to subgraders, and then collecting the results and working out the optimal farming scheme for the student.\n\n\nBasic usage\n\uf0c1\n\n\nIn this example, each input is checked against the corresponding answer, using \nStringGrader\n as the subgrader.\n\n\ngrader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader()\n)\n\n\n\n\nEach element of answers is set as an answer that is passed as the answers key into the subgrader. This should be set up as two input boxes that the student types in.\n\n\nIn the above example, the item grader just sees single strings as the answer. You can do more complicated things though, like the following.\n\n\nanswer1 = (\n    {'expect': 'zebra', 'grade_decimal': 1},\n    {'expect': 'horse', 'grade_decimal': 0.45},\n    {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'Unicorn? Really?'}\n)\nanswer2 = (\n    {'expect': 'cat', 'grade_decimal': 1},\n    {'expect': 'feline', 'grade_decimal': 0.5}\n)\ngrader = ListGrader(\n    answers=[answer1, answer2],\n    subgraders=StringGrader()\n)\n\n\n\n\nIn this example, the grader will try assigning the first input to answer1 and the second to answer2, and computing the total score. Then it will repeat, with the inputs switched. The student will receive the highest grade. So, note that while \ncat\n and \nunicorn\n will get the unicorn message (and 1/2 points), \nzebra\n and \nunicorn\n will not (and also get 1/2 points).\n\n\nOrdered Input\n\uf0c1\n\n\nBy default, the ListGrader doesn't care what order the inputs are given in, so \"cat\" and \"dog\" is equivalent to \"dog\" and \"cat\". If you want the inputs to be ordered, simply set ordered to True.\n\n\ngrader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader(),\n    ordered=True\n)\n\n\n\n\nNow, \"cat\" and \"dog\" will receive full credit, but \"dog\" and \"cat\" will receive none.\n\n\nMultiple Graders\n\uf0c1\n\n\nIf you have inhomogeneous inputs, you can grade them using different graders. Simply give a list of subgraders, and the data will be passed into the graders in that order. Note that the length of answers must be the same as the number of subgraders in this case. Further note that you must set ordered to True when using a list of subgraders.\n\n\ngrader = ListGrader(\n    answers=['cat', 'x^2+1'],\n    subgraders=[StringGrader(), FormulaGrader(variables=[\nx\n])],\n    ordered=True\n)\n\n\n\n\nSingleListGraders in ListGrader\n\uf0c1\n\n\nSome questions will require nested list graders. Simple versions can make use of a \nSingleListGrader\n subgrader, as in the following example.\n\n\nConsider two input boxes, where the first should be a comma-separated list of even numbers beneath 5, and the second should be a comma-separated list of odd numbers beneath 5. The order of the boxes is important, but within each box, the order becomes unimportant. Here's how you can encode this type of problem.\n\n\ngrader = ListGrader(\n    answers=[\n        ['2', '4'],\n        ['1', '3']\n    ],\n    subgraders=SingleListGrader(\n        subgrader=NumericalGrader()\n    ),\n    ordered=True\n)\n\n\n\n\nThe nested \nSingleListGrader\n will be used to grade the first input box against an unordered answer of 2 and 4, and then the second input box against an unordered answer of 1 and 3.\n\n\nGrouped Inputs\n\uf0c1\n\n\nIf you find yourself wanting to nest ListGraders, then you will need to specify how the inputs should be grouped together to be passed to the subgraders. A simple example would be to ask for the name and number of each animal in a picture. Each name/number group needs to be graded together. Here is an example of such a question.\n\n\ngrader = ListGrader(\n    answers=[\n        ['cat', '1'],\n        ['dog', '2'],\n        ['tiger', '3']\n    ],\n    subgraders=ListGrader(\n        subgraders=[StringGrader(), NumericalGrader()],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2, 3, 3]\n)\n\n\n\n\nIn this case, the second level of grader is receiving multiple inputs, and so itself needs to be a ListGrader. The grouping key specifies which group each input belongs to. In this case, answers 1 and 2 will be combined into a list and fed to the subgrader as group 1, as will 3 and 4 as group 2, and 5 and 6 as group 3. The third level of grader (StringGrader and NumericalGrader) will then receive a list of two inputs, and each of the items in the answers. Because this is an unordered list, the \nListGrader\n will find the optimal ordering of (animal, number) pairs.\n\n\nThe grouping keys must be integers starting at 1 and increasing. If you have N groups, then all numbers from 1 to N must be present in the grouping, but they need not be in monotonic order. So for example, [1, 2, 1, 2] is a valid grouping. For unordered groups, the groupings must each have the same number of elements.\n\n\nHere is another example. In this case, we have ordered entry, so we can specify a list of subgraders. We have three items in the first grouping and one item in the second, so we use a \nListGrader\n for the first grouping, and a \nStringGrader\n for the second. Note that the first entry in answers is a list that is passed directly into the \nListGrader\n, while the second entry is just a string. This second-level \nListGrader\n is unordered.\n\n\ngrader = ListGrader(\n    answers=[\n        ['bat', 'ghost', 'pumpkin'],\n        'Halloween'\n    ],\n    subgraders=[\n        ListGrader(\n            subgraders=StringGrader()\n        ),\n        StringGrader()\n    ],\n    ordered=True,\n    grouping=[1, 1, 1, 2]\n)\n\n\n\n\nOur last pair of examples are for a math class, where we have a matrix that has two eigenvalues, and each eigenvalue has a corresponding eigenvector. We start by grouping the eigenvalue and eigenvector boxes together, and then grade the groups in an unordered fashion. The eigenvectors are normalized, but have a sign ambiguity. A tuple contains both possible answers, and the grader will accept either of them.\n\n\ngrader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            SingleListGrader(\n                subgrader=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2]\n)\n\n\n\n\nThis example has four input boxes, with the first and third being graded by a \nNumericalGrader\n, and the second and fourth being graded by a \nSingleListGrader\n.\n\n\nIt is possible to specify a grouping on a nested \nListGrader\n. The outer \nListGrader\n must also have a grouping specified if doing so. Here is the same grader as above, where instead of taking the eigenvectors in a single input box list, there are four boxes to input each of the four vector components.\n\n\ngrader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            ListGrader(\n                subgraders=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True,\n        grouping=[1, 2, 2]\n    ),\n    grouping=[1, 1, 1, 2, 2, 2]\n)\n\n\n\n\nOption Listing\n\uf0c1\n\n\nHere is the full list of options specific to a \nListGrader\n.\n\n\ngrader = ListGrader(\n    answers=list,\n    subgraders=AbstractGrader or list of AbstractGraders,\n    ordered=bool, (default False)\n    grouping=list\n)", 
            "title": "ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#listgrader", 
            "text": "A  ListGrader  is used to grade a list of student inputs wherein each input is entered in a separate answer box. (In contrast,  SingleListGrader  can be used to grade a list of items entered all at once into a single answer box.) ListGraders work by farming out individual items to subgraders, and then collecting the results and working out the optimal farming scheme for the student.", 
            "title": "ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#basic-usage", 
            "text": "In this example, each input is checked against the corresponding answer, using  StringGrader  as the subgrader.  grader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader()\n)  Each element of answers is set as an answer that is passed as the answers key into the subgrader. This should be set up as two input boxes that the student types in.  In the above example, the item grader just sees single strings as the answer. You can do more complicated things though, like the following.  answer1 = (\n    {'expect': 'zebra', 'grade_decimal': 1},\n    {'expect': 'horse', 'grade_decimal': 0.45},\n    {'expect': 'unicorn', 'grade_decimal': 0, 'msg': 'Unicorn? Really?'}\n)\nanswer2 = (\n    {'expect': 'cat', 'grade_decimal': 1},\n    {'expect': 'feline', 'grade_decimal': 0.5}\n)\ngrader = ListGrader(\n    answers=[answer1, answer2],\n    subgraders=StringGrader()\n)  In this example, the grader will try assigning the first input to answer1 and the second to answer2, and computing the total score. Then it will repeat, with the inputs switched. The student will receive the highest grade. So, note that while  cat  and  unicorn  will get the unicorn message (and 1/2 points),  zebra  and  unicorn  will not (and also get 1/2 points).", 
            "title": "Basic usage"
        }, 
        {
            "location": "/grading_lists/list_grader/#ordered-input", 
            "text": "By default, the ListGrader doesn't care what order the inputs are given in, so \"cat\" and \"dog\" is equivalent to \"dog\" and \"cat\". If you want the inputs to be ordered, simply set ordered to True.  grader = ListGrader(\n    answers=['cat', 'dog'],\n    subgraders=StringGrader(),\n    ordered=True\n)  Now, \"cat\" and \"dog\" will receive full credit, but \"dog\" and \"cat\" will receive none.", 
            "title": "Ordered Input"
        }, 
        {
            "location": "/grading_lists/list_grader/#multiple-graders", 
            "text": "If you have inhomogeneous inputs, you can grade them using different graders. Simply give a list of subgraders, and the data will be passed into the graders in that order. Note that the length of answers must be the same as the number of subgraders in this case. Further note that you must set ordered to True when using a list of subgraders.  grader = ListGrader(\n    answers=['cat', 'x^2+1'],\n    subgraders=[StringGrader(), FormulaGrader(variables=[ x ])],\n    ordered=True\n)", 
            "title": "Multiple Graders"
        }, 
        {
            "location": "/grading_lists/list_grader/#singlelistgraders-in-listgrader", 
            "text": "Some questions will require nested list graders. Simple versions can make use of a  SingleListGrader  subgrader, as in the following example.  Consider two input boxes, where the first should be a comma-separated list of even numbers beneath 5, and the second should be a comma-separated list of odd numbers beneath 5. The order of the boxes is important, but within each box, the order becomes unimportant. Here's how you can encode this type of problem.  grader = ListGrader(\n    answers=[\n        ['2', '4'],\n        ['1', '3']\n    ],\n    subgraders=SingleListGrader(\n        subgrader=NumericalGrader()\n    ),\n    ordered=True\n)  The nested  SingleListGrader  will be used to grade the first input box against an unordered answer of 2 and 4, and then the second input box against an unordered answer of 1 and 3.", 
            "title": "SingleListGraders in ListGrader"
        }, 
        {
            "location": "/grading_lists/list_grader/#grouped-inputs", 
            "text": "If you find yourself wanting to nest ListGraders, then you will need to specify how the inputs should be grouped together to be passed to the subgraders. A simple example would be to ask for the name and number of each animal in a picture. Each name/number group needs to be graded together. Here is an example of such a question.  grader = ListGrader(\n    answers=[\n        ['cat', '1'],\n        ['dog', '2'],\n        ['tiger', '3']\n    ],\n    subgraders=ListGrader(\n        subgraders=[StringGrader(), NumericalGrader()],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2, 3, 3]\n)  In this case, the second level of grader is receiving multiple inputs, and so itself needs to be a ListGrader. The grouping key specifies which group each input belongs to. In this case, answers 1 and 2 will be combined into a list and fed to the subgrader as group 1, as will 3 and 4 as group 2, and 5 and 6 as group 3. The third level of grader (StringGrader and NumericalGrader) will then receive a list of two inputs, and each of the items in the answers. Because this is an unordered list, the  ListGrader  will find the optimal ordering of (animal, number) pairs.  The grouping keys must be integers starting at 1 and increasing. If you have N groups, then all numbers from 1 to N must be present in the grouping, but they need not be in monotonic order. So for example, [1, 2, 1, 2] is a valid grouping. For unordered groups, the groupings must each have the same number of elements.  Here is another example. In this case, we have ordered entry, so we can specify a list of subgraders. We have three items in the first grouping and one item in the second, so we use a  ListGrader  for the first grouping, and a  StringGrader  for the second. Note that the first entry in answers is a list that is passed directly into the  ListGrader , while the second entry is just a string. This second-level  ListGrader  is unordered.  grader = ListGrader(\n    answers=[\n        ['bat', 'ghost', 'pumpkin'],\n        'Halloween'\n    ],\n    subgraders=[\n        ListGrader(\n            subgraders=StringGrader()\n        ),\n        StringGrader()\n    ],\n    ordered=True,\n    grouping=[1, 1, 1, 2]\n)  Our last pair of examples are for a math class, where we have a matrix that has two eigenvalues, and each eigenvalue has a corresponding eigenvector. We start by grouping the eigenvalue and eigenvector boxes together, and then grade the groups in an unordered fashion. The eigenvectors are normalized, but have a sign ambiguity. A tuple contains both possible answers, and the grader will accept either of them.  grader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            SingleListGrader(\n                subgrader=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True\n    ),\n    grouping=[1, 1, 2, 2]\n)  This example has four input boxes, with the first and third being graded by a  NumericalGrader , and the second and fourth being graded by a  SingleListGrader .  It is possible to specify a grouping on a nested  ListGrader . The outer  ListGrader  must also have a grouping specified if doing so. Here is the same grader as above, where instead of taking the eigenvectors in a single input box list, there are four boxes to input each of the four vector components.  grader = ListGrader(\n    answers=[\n        ['1', (['1', '0'], ['-1', '0'])],\n        ['-1', (['0', '1'], ['0', '-1'])],\n    ],\n    subgraders=ListGrader(\n        subgraders=[\n            NumericalGrader(),\n            ListGrader(\n                subgraders=NumericalGrader(),\n                ordered=True\n            )\n        ],\n        ordered=True,\n        grouping=[1, 2, 2]\n    ),\n    grouping=[1, 1, 1, 2, 2, 2]\n)", 
            "title": "Grouped Inputs"
        }, 
        {
            "location": "/grading_lists/list_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  ListGrader .  grader = ListGrader(\n    answers=list,\n    subgraders=AbstractGrader or list of AbstractGraders,\n    ordered=bool, (default False)\n    grouping=list\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/grading_lists/single_list_grader/", 
            "text": "SingleListGrader\n\uf0c1\n\n\nIf you want a response to be a delimiter-separated list of items, you can use a special ItemGrader called \nSingleListGrader\n to perform the grading. You need to specify a subgrader (which must be an ItemGrader, and could even be another SingleListGrader) to evaluate each individual item. The basic usage is as follows.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader()\n)\n\n\n\n\nTo receive full points for this problem, a student would enter \ncat, dog\n or \ndog, cat\n into the input box. Entering \ncat, octopus\n or just \ncat\n will receive half points.\n\n\nYou can use a tuple of lists to specify multiple lists of answers, just like normal ItemGraders.\n\n\ngrader = SingleListGrader(\n    answers=(\n        [('cat', 'feline'), 'dog'],\n        ['goat', 'vole'],\n    ),\n    subgrader=StringGrader()\n)\n\n\n\n\nNow, \ncat, dog\n and \ngoat, vole\n will get full grades. But mixes won't: \ncat, vole\n will score half credit.\n\n\nOrdered Input\n\uf0c1\n\n\nBy default a SingleListGrader doesn't care which order the input is given in. If you want the answers and the student input to be compared in order, set \nordered=True\n.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    ordered=True\n)\n\n\n\n\nNow \ncat, dog\n will receive full grades, but \ndog, cat\n will be marked wrong. Note that \ncat\n will receive half credit, but \ndog\n will receive zero, as dog is incorrect in the first position. Ordered is false by default.\n\n\nLength Checking\n\uf0c1\n\n\nIf students are asked to enter a list of three items but only enter two, should this use up an attempt, or present an error message? If you want to present an error message, turn on length checking.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    length_error=True\n)\n\n\n\n\nIf you give this \ncat\n, it will tell you that you've got the wrong length, and won't use up an attempt.\n\n\nLength_error is false by default. If you set length_error to True, then all answers in a tuple of lists (rather than a single answer list) must have the same length.\n\n\nChoosing Delimiters\n\uf0c1\n\n\nYou can use whatever delimiter you like. The default is a comma (\n,\n). The following uses a semicolon as a delimiter. We recommend not using multi-character delimiters, but do not disallow it.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    delimiter=';'\n)\n\n\n\n\nBy using different delimiters, it is possible to nest SingleListGraders:\n\n\ngrader = SingleListGrader(\n    answers=[['a', 'b'], ['c', 'd']],\n    subgrader=SingleListGrader(\n        subgrader=StringGrader()\n    ),\n    delimiter=';'\n)\n\n\n\n\nHere the expected student input is \na, b; c, d\n. It will also take \nb, a; d, c\n or \nc, d; a, b\n due to the unordered nature of both lists. However, \na, c; d, b\n is only worth half points.\n\n\nTurning Partial Credit Off\n\uf0c1\n\n\nBy default, partial credit is awarded to partially correct answers. Answers that have insufficient items lose points, as do answers that have too many items. To turn off partial credit, set partial_credit to False. It is True by default.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    partial_credit=False\n)\n\n\n\n\nNow \ncat, octopus\n will receive a grade of zero.\n\n\nMessages\n\uf0c1\n\n\nMessages from the individual items are all concatenated together and presented to the student. It is also possible to have a \nwrong_msg\n on the \nSingleListGrader\n, which is presented to the student if the score is zero and there are no other messages, just like on an \nItemGrader\n.\n\n\ngrader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    wrong_msg='Try again!'\n)\n\n\n\n\nOption Listing\n\uf0c1\n\n\nHere is the full list of options specific to a \nSingleListGrader\n.\n\n\ngrader = SingleListGrader(\n    answers=list or tuple of lists,\n    subgrader=ItemGrader(),\n    partial_credit=bool (default True),\n    ordered=bool (default False),\n    length_error=bool (default False),\n    delimiter=string (default ',')\n)", 
            "title": "SingleListGrader"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#singlelistgrader", 
            "text": "If you want a response to be a delimiter-separated list of items, you can use a special ItemGrader called  SingleListGrader  to perform the grading. You need to specify a subgrader (which must be an ItemGrader, and could even be another SingleListGrader) to evaluate each individual item. The basic usage is as follows.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader()\n)  To receive full points for this problem, a student would enter  cat, dog  or  dog, cat  into the input box. Entering  cat, octopus  or just  cat  will receive half points.  You can use a tuple of lists to specify multiple lists of answers, just like normal ItemGraders.  grader = SingleListGrader(\n    answers=(\n        [('cat', 'feline'), 'dog'],\n        ['goat', 'vole'],\n    ),\n    subgrader=StringGrader()\n)  Now,  cat, dog  and  goat, vole  will get full grades. But mixes won't:  cat, vole  will score half credit.", 
            "title": "SingleListGrader"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#ordered-input", 
            "text": "By default a SingleListGrader doesn't care which order the input is given in. If you want the answers and the student input to be compared in order, set  ordered=True .  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    ordered=True\n)  Now  cat, dog  will receive full grades, but  dog, cat  will be marked wrong. Note that  cat  will receive half credit, but  dog  will receive zero, as dog is incorrect in the first position. Ordered is false by default.", 
            "title": "Ordered Input"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#length-checking", 
            "text": "If students are asked to enter a list of three items but only enter two, should this use up an attempt, or present an error message? If you want to present an error message, turn on length checking.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    length_error=True\n)  If you give this  cat , it will tell you that you've got the wrong length, and won't use up an attempt.  Length_error is false by default. If you set length_error to True, then all answers in a tuple of lists (rather than a single answer list) must have the same length.", 
            "title": "Length Checking"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#choosing-delimiters", 
            "text": "You can use whatever delimiter you like. The default is a comma ( , ). The following uses a semicolon as a delimiter. We recommend not using multi-character delimiters, but do not disallow it.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    delimiter=';'\n)  By using different delimiters, it is possible to nest SingleListGraders:  grader = SingleListGrader(\n    answers=[['a', 'b'], ['c', 'd']],\n    subgrader=SingleListGrader(\n        subgrader=StringGrader()\n    ),\n    delimiter=';'\n)  Here the expected student input is  a, b; c, d . It will also take  b, a; d, c  or  c, d; a, b  due to the unordered nature of both lists. However,  a, c; d, b  is only worth half points.", 
            "title": "Choosing Delimiters"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#turning-partial-credit-off", 
            "text": "By default, partial credit is awarded to partially correct answers. Answers that have insufficient items lose points, as do answers that have too many items. To turn off partial credit, set partial_credit to False. It is True by default.  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    partial_credit=False\n)  Now  cat, octopus  will receive a grade of zero.", 
            "title": "Turning Partial Credit Off"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#messages", 
            "text": "Messages from the individual items are all concatenated together and presented to the student. It is also possible to have a  wrong_msg  on the  SingleListGrader , which is presented to the student if the score is zero and there are no other messages, just like on an  ItemGrader .  grader = SingleListGrader(\n    answers=['cat', 'dog'],\n    subgrader=StringGrader(),\n    wrong_msg='Try again!'\n)", 
            "title": "Messages"
        }, 
        {
            "location": "/grading_lists/single_list_grader/#option-listing", 
            "text": "Here is the full list of options specific to a  SingleListGrader .  grader = SingleListGrader(\n    answers=list or tuple of lists,\n    subgrader=ItemGrader(),\n    partial_credit=bool (default True),\n    ordered=bool (default False),\n    length_error=bool (default False),\n    delimiter=string (default ',')\n)", 
            "title": "Option Listing"
        }, 
        {
            "location": "/changelog/", 
            "text": "Change Log\n\uf0c1\n\n\nVersion 1.1.x\n\uf0c1\n\n\nVersion 1.1.2\n\uf0c1\n\n\n\n\nThis version includes an internal change to the way that errors are handled during check.\n\n\nIf you only use builtin graders (FormulaGrader, ListGrader...) or public plugins (IntegralGrader) you should not notice any difference.\n\n\nIf you have previously written your own grading class, this change could affect what errors messages are displayed to students. In particular, only exceptions inheriting from \nMITxError\n will display their messages to students; other errors will be replaced with a generic error message.\n\n\n\n\nVersion 1.1.1\n\uf0c1\n\n\n\n\nAdded AsciiMath renderer definitions\n\n\nWe now check for naming collisions in your configuration\n\n\nCleaned up voluptuous incorporation\n\n\nExtend domain of factorial function to all complex, except negative integers\n\n\nRemoved .pyc files from the zip file\n\n\nMinor bug fixes\n\n\n\n\nVersion 1.1.0\n\uf0c1\n\n\n\n\nAdded numbered variables to FormulaGrader\n\n\n\n\nRemoved case-insensitive comparisons from FormulaGrader and IntegralGrader.\n\n\n\n\nWarning\n\n\nThis is a departure from edX and is a breaking change for authors who used case-insensitive FormulaGraders. However:\n\n\n\n\nCase-sensitive has always been the default for FormulaGrader and we are not aware of authors using case-insensitive FormulaGraders.\n\n\nPedagogically, we believe that students should think of \nM\n and \nm\n are different variables.\n\n\nRemoving case-insensitive comparison fixes a number of ambiguous situations.\n\n\n\n\n\n\n\n\n\n\nVersion 1.0.x\n\uf0c1\n\n\nVersion 1.0.5\n\uf0c1\n\n\n\n\nImproved debugging information for FormulaGrader\n\n\nFormulaGrader and IntegralGrader perform whitelist, blacklist, and forbidden_string checks after determining answer correctness. Incorrect answers using forbidden strings / functions are now marked incorrect, while correct answers using forbidden strings / functions raise errors.\n\n\nMinor improvements to existing unit tests\n\n\n\n\nVersion 1.0.4\n\uf0c1\n\n\n\n\nAuthors can now specify a custom comparer function for FormulaGrader\n\n\nIntegralGrader now handles complex integrands, and gives meaningful error messages\n  for complex limits.\n\n\nMiscellaneous bug fixes for tensor variable name parsing\n\n\n\n\nVersion 1.0.3\n\uf0c1\n\n\n\n\nAdded tensor variable names\n\n\n\n\nVersion 1.0.2\n\uf0c1\n\n\n\n\nAdded error messages for overflow, division-by-zero, and out-of-domain errors in formulas\n\n\nAdded tests to reach 100% coverage\n\n\nRemoved redundant code\n\n\nFixed some bugs in unused code\n\n\n\n\nVersion 1.0.1\n\uf0c1\n\n\n\n\nAdded DependentSampler\n\n\nFixed issue with zip file tests\n\n\nAdded doctests to test suite\n\n\nFixed bug in FormulaGrader when given an empty string", 
            "title": "Changelog"
        }, 
        {
            "location": "/changelog/#change-log", 
            "text": "", 
            "title": "Change Log"
        }, 
        {
            "location": "/changelog/#version-11x", 
            "text": "", 
            "title": "Version 1.1.x"
        }, 
        {
            "location": "/changelog/#version-112", 
            "text": "This version includes an internal change to the way that errors are handled during check.  If you only use builtin graders (FormulaGrader, ListGrader...) or public plugins (IntegralGrader) you should not notice any difference.  If you have previously written your own grading class, this change could affect what errors messages are displayed to students. In particular, only exceptions inheriting from  MITxError  will display their messages to students; other errors will be replaced with a generic error message.", 
            "title": "Version 1.1.2"
        }, 
        {
            "location": "/changelog/#version-111", 
            "text": "Added AsciiMath renderer definitions  We now check for naming collisions in your configuration  Cleaned up voluptuous incorporation  Extend domain of factorial function to all complex, except negative integers  Removed .pyc files from the zip file  Minor bug fixes", 
            "title": "Version 1.1.1"
        }, 
        {
            "location": "/changelog/#version-110", 
            "text": "Added numbered variables to FormulaGrader   Removed case-insensitive comparisons from FormulaGrader and IntegralGrader.   Warning  This is a departure from edX and is a breaking change for authors who used case-insensitive FormulaGraders. However:   Case-sensitive has always been the default for FormulaGrader and we are not aware of authors using case-insensitive FormulaGraders.  Pedagogically, we believe that students should think of  M  and  m  are different variables.  Removing case-insensitive comparison fixes a number of ambiguous situations.", 
            "title": "Version 1.1.0"
        }, 
        {
            "location": "/changelog/#version-10x", 
            "text": "", 
            "title": "Version 1.0.x"
        }, 
        {
            "location": "/changelog/#version-105", 
            "text": "Improved debugging information for FormulaGrader  FormulaGrader and IntegralGrader perform whitelist, blacklist, and forbidden_string checks after determining answer correctness. Incorrect answers using forbidden strings / functions are now marked incorrect, while correct answers using forbidden strings / functions raise errors.  Minor improvements to existing unit tests", 
            "title": "Version 1.0.5"
        }, 
        {
            "location": "/changelog/#version-104", 
            "text": "Authors can now specify a custom comparer function for FormulaGrader  IntegralGrader now handles complex integrands, and gives meaningful error messages\n  for complex limits.  Miscellaneous bug fixes for tensor variable name parsing", 
            "title": "Version 1.0.4"
        }, 
        {
            "location": "/changelog/#version-103", 
            "text": "Added tensor variable names", 
            "title": "Version 1.0.3"
        }, 
        {
            "location": "/changelog/#version-102", 
            "text": "Added error messages for overflow, division-by-zero, and out-of-domain errors in formulas  Added tests to reach 100% coverage  Removed redundant code  Fixed some bugs in unused code", 
            "title": "Version 1.0.2"
        }, 
        {
            "location": "/changelog/#version-101", 
            "text": "Added DependentSampler  Fixed issue with zip file tests  Added doctests to test suite  Fixed bug in FormulaGrader when given an empty string", 
            "title": "Version 1.0.1"
        }
    ]
}