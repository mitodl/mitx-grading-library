{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MITx Grading Library: An Overview # The mitxgraders Python library provides a number of configurable Python classes that can be used as graders in edX custom response problems. Relevant Links # A complete example course that demonstrates most of the features of this library is available on edX edge Complete source code for the library and the aforementioned example course is available on github Why use MITxGraders # Use MITxGraders because it: has many capabilities beyond the standard edX options is highly configurable but with sensible defaults provides useful error messages to students (when submitting answers \u2014 for example, formula parsing errors) to problem authors (when configuring a grader) is reliable (extensively tested) is open source (BSD-3 license, our Github repo ) has an excellent example edX course is ready for the future of edX by being compatible with Python 3.8 and 3.11 is actively maintained Two Typical Examples # Typical usage in an edX course looks like: <problem> <script type= \"text/python\" > from mitxgraders import * grader = FormulaGrader( variables=[\"x\"], # allows students to use generic functions f and f' in their input user_functions={\"f\": RandomFunction(), \"f'\": RandomFunction()} ) </script> <p> Enter the derivative of \\(g(x) = e^{f(x^2)} \\). </p> <!-- answer is provided to the grader when using single inputs --> <customresponse cfn= \"grader\" answer= \"e^(f(x)) * f'(x^2) * 2*x\" > <textline math= \"true\" /> </customresponse> </problem> The resulting problem would be similar to an edX <formularesponse /> problem, but allows students to use additional generic functions f(x) and f'(x) in their submissions. The next example grader would grade an unordered list of mathematical expressions. <problem> <script type= \"text/python\" > from mitxgraders import * grader = ListGrader( answers=['x-2', 'x+2'], subgraders=FormulaGrader(variables=['x']) ) </script> <p> What are the linear factors of \\((x^2 - 4)\\)? Enter your answers in any order. </p> <customresponse cfn= \"grader\" > <!-- correct_answer is shown to student when they press [Show Answer]. Its value is not used for grading purposes --> <textline math= \"true\" correct_answer= \"x - 2\" /> <textline math= \"true\" correct_answer= \"x + 2\" /> </customresponse> </problem> Loading in edX # Download python_lib.zip and place it in your static folder (XML workflow) or upload it as a file asset (Studio workflow). If you already have a python_lib.zip, you'll need to merge ours with yours and re-zip. If you want to use our AsciiMath renderer definitions (if you have math problems, you'll really want this!), place the MJxPrep.js file in your static folder (XML) or upload the file to your course assets (Studio). The basic idea of this library is that it contains a number of classes that can be used as the check function for an edX custom response problem. Different classes of grader are used for different inputs. We begin by presenting a brief overview on how the grading classes are used in general. How to Zip Correctly # EdX expects packages to be at the top level of the ZIP file. If you zip an entire folder named python_lib , the paths end up as python_lib/mitxgraders/ , python_lib/voluptuous/ , etc., and edX will fail to locate them. Option A (Command Line) # Go inside your local python_lib folder that holds mitxgraders/ , voluptuous/ , etc. Run: bash zip -r ../python_lib.zip * This ensures the zip file contains only the contents of python_lib/ at the top level. Option B (Windows Explorer) # Open the python_lib folder in File Explorer. Select all its contents (e.g. mitxgraders , voluptuous , etc.). Right-click \u2192 Send to \u2192 Compressed (zipped) folder . Name the resulting zip file python_lib.zip . Do not right-click on the python_lib folder itself; you want to zip just its contents . Option C (macOS Finder) # Open the python_lib folder in Finder. Select all its contents. Right-click (or Control-click) \u2192 Compress X Items (where X is the number of selected items). Rename the resulting Archive.zip file to python_lib.zip . Again, ensure you\u2019re zipping the contents rather than the entire python_lib folder. Checking Your Zip File # Rename and Unzip Rename your python_lib.zip to test.zip . Unzip test.zip into a folder named test . If you see a folder python_lib inside test , you zipped incorrectly. If you see folders like mitxgraders/ or voluptuous/ directly inside test , the zip is correct. Using a Command (Optional) If you have a command line available, run: bash zipinfo python_lib.zip Incorrect (extra directory): python_lib/ python_lib/mitxgraders/ python_lib/voluptuous/ Correct (no extra folder at the top): mitxgraders/ voluptuous/ Grading Classes # Grading classes generally fall into two categories: single-input graders and multi-input graders. Single-input graders grade a single input. All single-input graders are built on a framework we call an ItemGrader . We recommend understanding how ItemGrader s work before diving into more specifics. ItemGrader StringGrader for grading text input (includes pattern matching) FormulaGrader for grading general formulas NumericalGrader for grading numbers MatrixGrader for grading formulas with vectors and matrices SingleListGrader for grading a delimited (default: comma-separated) list of inputs in a single response box Multi-input graders are for grading multiple input boxes at once. They are composed of single-input graders working in concert, handled by the general ListGrader class. ListGrader is the only multi-input grader included in the library, but is incredibly general. ListGrader for grading a list of inputs. Examples: grade an ordered list of text inputs grade an unordered list of mathematical expressions grade a list of eigenvalue-eigenvector pairs Specialized graders are used to grade very specific situations. The only specialized grader we presently have is IntegralGrader , although plugins can be used to construct further examples. IntegralGrader for grading the construction of integrals. Questions? Bugs? Issues? Suggestions? # Please contact us by making an issue on github . What should I read next? # If you haven't already done so, we recommend looking at our example course to get an idea of the type of things that the library is capable of. It's probably a good idea to start by looking at how to invoke the grading library in edX . Next, we recommend looking at the Introduction to Graders and the overview of ItemGraders . After that, choose a grader that you're interested in, look at source code for examples for that grader , and read up on the relevant documentation. Enjoy!","title":"Overview"},{"location":"#mitx-grading-library-an-overview","text":"The mitxgraders Python library provides a number of configurable Python classes that can be used as graders in edX custom response problems.","title":"MITx Grading Library: An Overview"},{"location":"#relevant-links","text":"A complete example course that demonstrates most of the features of this library is available on edX edge Complete source code for the library and the aforementioned example course is available on github","title":"Relevant Links"},{"location":"#why-use-mitxgraders","text":"Use MITxGraders because it: has many capabilities beyond the standard edX options is highly configurable but with sensible defaults provides useful error messages to students (when submitting answers \u2014 for example, formula parsing errors) to problem authors (when configuring a grader) is reliable (extensively tested) is open source (BSD-3 license, our Github repo ) has an excellent example edX course is ready for the future of edX by being compatible with Python 3.8 and 3.11 is actively maintained","title":"Why use MITxGraders"},{"location":"#two-typical-examples","text":"Typical usage in an edX course looks like: <problem> <script type= \"text/python\" > from mitxgraders import * grader = FormulaGrader( variables=[\"x\"], # allows students to use generic functions f and f' in their input user_functions={\"f\": RandomFunction(), \"f'\": RandomFunction()} ) </script> <p> Enter the derivative of \\(g(x) = e^{f(x^2)} \\). </p> <!-- answer is provided to the grader when using single inputs --> <customresponse cfn= \"grader\" answer= \"e^(f(x)) * f'(x^2) * 2*x\" > <textline math= \"true\" /> </customresponse> </problem> The resulting problem would be similar to an edX <formularesponse /> problem, but allows students to use additional generic functions f(x) and f'(x) in their submissions. The next example grader would grade an unordered list of mathematical expressions. <problem> <script type= \"text/python\" > from mitxgraders import * grader = ListGrader( answers=['x-2', 'x+2'], subgraders=FormulaGrader(variables=['x']) ) </script> <p> What are the linear factors of \\((x^2 - 4)\\)? Enter your answers in any order. </p> <customresponse cfn= \"grader\" > <!-- correct_answer is shown to student when they press [Show Answer]. Its value is not used for grading purposes --> <textline math= \"true\" correct_answer= \"x - 2\" /> <textline math= \"true\" correct_answer= \"x + 2\" /> </customresponse> </problem>","title":"Two Typical Examples"},{"location":"#loading-in-edx","text":"Download python_lib.zip and place it in your static folder (XML workflow) or upload it as a file asset (Studio workflow). If you already have a python_lib.zip, you'll need to merge ours with yours and re-zip. If you want to use our AsciiMath renderer definitions (if you have math problems, you'll really want this!), place the MJxPrep.js file in your static folder (XML) or upload the file to your course assets (Studio). The basic idea of this library is that it contains a number of classes that can be used as the check function for an edX custom response problem. Different classes of grader are used for different inputs. We begin by presenting a brief overview on how the grading classes are used in general.","title":"Loading in edX"},{"location":"#how-to-zip-correctly","text":"EdX expects packages to be at the top level of the ZIP file. If you zip an entire folder named python_lib , the paths end up as python_lib/mitxgraders/ , python_lib/voluptuous/ , etc., and edX will fail to locate them.","title":"How to Zip Correctly"},{"location":"#option-a-command-line","text":"Go inside your local python_lib folder that holds mitxgraders/ , voluptuous/ , etc. Run: bash zip -r ../python_lib.zip * This ensures the zip file contains only the contents of python_lib/ at the top level.","title":"Option A (Command Line)"},{"location":"#option-b-windows-explorer","text":"Open the python_lib folder in File Explorer. Select all its contents (e.g. mitxgraders , voluptuous , etc.). Right-click \u2192 Send to \u2192 Compressed (zipped) folder . Name the resulting zip file python_lib.zip . Do not right-click on the python_lib folder itself; you want to zip just its contents .","title":"Option B (Windows Explorer)"},{"location":"#option-c-macos-finder","text":"Open the python_lib folder in Finder. Select all its contents. Right-click (or Control-click) \u2192 Compress X Items (where X is the number of selected items). Rename the resulting Archive.zip file to python_lib.zip . Again, ensure you\u2019re zipping the contents rather than the entire python_lib folder.","title":"Option C (macOS Finder)"},{"location":"#checking-your-zip-file","text":"Rename and Unzip Rename your python_lib.zip to test.zip . Unzip test.zip into a folder named test . If you see a folder python_lib inside test , you zipped incorrectly. If you see folders like mitxgraders/ or voluptuous/ directly inside test , the zip is correct. Using a Command (Optional) If you have a command line available, run: bash zipinfo python_lib.zip Incorrect (extra directory): python_lib/ python_lib/mitxgraders/ python_lib/voluptuous/ Correct (no extra folder at the top): mitxgraders/ voluptuous/","title":"Checking Your Zip File"},{"location":"#grading-classes","text":"Grading classes generally fall into two categories: single-input graders and multi-input graders. Single-input graders grade a single input. All single-input graders are built on a framework we call an ItemGrader . We recommend understanding how ItemGrader s work before diving into more specifics. ItemGrader StringGrader for grading text input (includes pattern matching) FormulaGrader for grading general formulas NumericalGrader for grading numbers MatrixGrader for grading formulas with vectors and matrices SingleListGrader for grading a delimited (default: comma-separated) list of inputs in a single response box Multi-input graders are for grading multiple input boxes at once. They are composed of single-input graders working in concert, handled by the general ListGrader class. ListGrader is the only multi-input grader included in the library, but is incredibly general. ListGrader for grading a list of inputs. Examples: grade an ordered list of text inputs grade an unordered list of mathematical expressions grade a list of eigenvalue-eigenvector pairs Specialized graders are used to grade very specific situations. The only specialized grader we presently have is IntegralGrader , although plugins can be used to construct further examples. IntegralGrader for grading the construction of integrals.","title":"Grading Classes"},{"location":"#questions-bugs-issues-suggestions","text":"Please contact us by making an issue on github .","title":"Questions? Bugs? Issues? Suggestions?"},{"location":"#what-should-i-read-next","text":"If you haven't already done so, we recommend looking at our example course to get an idea of the type of things that the library is capable of. It's probably a good idea to start by looking at how to invoke the grading library in edX . Next, we recommend looking at the Introduction to Graders and the overview of ItemGraders . After that, choose a grader that you're interested in, look at source code for examples for that grader , and read up on the relevant documentation. Enjoy!","title":"What should I read next?"},{"location":"changelog/","text":"Change Log # Version 3 # This major release removes support for Python 2 and older versions of Python 3 and adds support for Python 3.8 and 3.11. Version 3.0 # Version 3.0.0 # Add Python 3.8 and 3.11 support Drop Python 2 support Remove six package Version 2 # This is a major new version with many new features added. We have been very careful to preserve backwards compatibility of the outward-facing API of the library while adding new features. The biggest change (and the reason for the major version number) is that we are now fully compatible with python versions 2.7, 3.6 and 3.7. All typical applications of version 1.2 should be compatible with version 2. However, we do warn that we broke internal backwards compatibility in a number of locations in order to accommodate python 3. If you previously wrote custom plugins for version 1.2, we cannot guarantee that they will continue to work in version 2. Version 2.4 # Version 2.4.1 # Implemented the option to specify a tuple of multiple possible answers in an 'expect' keyword when supplying specific messages and grades. Version 2.4.0 # Refactored loading of scipy to only occur when required. This should make the library load significantly faster, which will resolve a lot of codejail timeout errors (we hope!). Version 2.3 # Version 2.3.3 # Refactored sampling to allow sibling variables to be used in DependentSampler s. Version 2.3.2 # Fixed a bug where long integers passed in as a variable (via DiscreteSet ) or user-defined constant would cause an error in evaluation (such numbers are now cast as floats). Version 2.3.1 # Added a feature to math graders to remove default constants such as pi or i . Updated math parser to treat emdash unicode characters as minus signs (thanks Derek Rhodes!). Updated pytest version to last version supporting python 2. Version 2.3.0 # Updated unit tests to use python and library versions consistent with edx.org. Updated documentation to reflect edX usage of python 3. Added python version to debug output. Fixed a bug in LinearComparer that caused a crash when a student provided a constant answer. Fixed a bug in debug output for math graders that caused output not to show. Version 2.2 # Version 2.2.0 # Rewrote IntegralGrader and FormulaGrader to leverage the same underlying functions, which allows all of the options in FormulaGrader to also apply to IntegralGrader . Constructed SumGrader , which operates like IntegralGrader , but grades sums instead of integrals. Version 2.1 # Version 2.1.1 # Fixed a bug in LinearComparer when a student's answer was constant. Version 2.1.0 # Added a new grader IntervalGrader , which grades expressions for mathematical intervals. Added allow_inf option to FormulaGrader and NumericalGrader , which allow for infty (infinity) to appear in expressions. SingleListGrader can now be provided answers as a single string. It can also infer answers from the expect keyword of a customresponse tag. Version 2.0 # Version 2.0.2 # Fix a bug with custom AsciiMath preprocessor where lonely square roots (e.g., x + sqrt + y ) rendered badly. Version 2.0.1 # Fixed a bug in StringGrader regex validation that only required the start of student input to match the pattern. Version 2.0.0 # Feature updates: Graders can now be constructed in-line in a customresponse, rather than in a python code block. Credit awarded can now be dependent upon the attempt number. Introduced a new plug-in to set course-wide defaults that differ from library defaults. StringGrader received a major overhaul, and can now require minimum character or word lengths, and also pattern match to regular expressions. Further options to treat whitespace were introduced. The structure of SingleListGrader answers now uses and extends that used by ItemGrader answers, leading to more general ways of expressing answers and providing feedback to students. Answers to SingleListGrader problems can now be inferred from the expect keyword. SingleListGrader can now warn students that they have missing entries. Partial credit can now be turned off in ListGrader problems. Partial credit can now be awarded in matrix entry problems, with messages explaining which entries are correct. Implemented LinearComparer , which can assign partial/full credit to formula responses that are linearly related to answers. Comparers for math problems can now be set much more straightforwardly. floor , ceil , min and max functions were added to the math library. In math problems, introduced an option to apply a transforming function to the answer and student input before comparing. Completely overhauled matrix sampling to allow most typical matrix types to be sampled. Introduced instructor variables for math problems, which authors can use in constructing the problem, but students may not use in their responses. DependentSampler now has access to constants and user functions, and no longer needs the depends key. DiscreteSet will now work with arrays. All comparers are now imported when using from mitxgraders import * . Under the hood: Ensured that the entire library (including tests) is compatible with python 2.7 and python 3.6/3.7, in preparation for edX's upcoming transition to python 3. (The change to having internal unicode literals is the biggest internal backward-compatability-breaking issue from version 1.2.) Introduced CorrelatedComparer s, which compare multiple samples at once. IntegralGrader has been promoted from a plug-in to a core component of the library. SpecifyDomain has been expanded to allow for functions with any number of arguments. Javascript preprocessor was tidied up, and further options for customization were included. All documentation examples are now run as doctests. Upgraded voluptuous to version 0.11.5. Upgraded testing infrastructure. Bug fixes: Fixed a bug in assigning partial credit in ListGrader s when multiple lists of answers were included. Version 1 # Version 1.2 # Version 1.2.3 # Added new custom comparers vector_span_comparer and vector_phase_comparer . Updated AsciiMath preprocessor to handle lonely mover (math-over) entries. Version 1.2.2 # Added accept_any and accept_nonempty options to StringGrader . If only a single text input is present, the answers key is inferred from the expect attribute of the customresponse tag (does not work for SingleListInput however). Updated AsciiMath preprocessor to handle variable names and user-defined functions properly. Various small bug fixes. Version 1.2.1 # Added arctan2(x, y) function that returns angle between +x axis and the point (x, y); available by default for students to use in FormulaGrader problems. Rewrote the expression parser and evaluator. Among other things, new parser provides better error messages when explicit multiplication is forgotten in expressions like '5x + 3' . Also validates curly brace balancing, which may be used in tensor variable names. Version 1.2.0 # This version includes a number of new features and documentation updates. A new documentation website Math parser now supports multivariable functions and array input (vector, matrix, etc). Many improvements to our mathjax preprocessor Improvements to balanced bracket validator. Added new class MatrixGrader (see MatrixGrader documentation ) along with supporting sampling classes RealMatrices and RealVectors When FormulaGrader (and its subclasses) are used inside an ordered ListGrader , authors can now grade multiple student inputs in comparison to each other by specifying answers in terms of sibling variables FormulaGrader (and its subclasses) now support comparer functions that can be used to grade student input more flexibly. For example, rather than checking checking that the student input and author input are equal, check that they are equal modulo a certain number. Built-in comparers: equality_comparer congruence_comparer between_comparer eigenvector_comparer Version 1.1 # Version 1.1.2 # This version includes an internal change to the way that errors are handled during check. If you only use builtin graders (FormulaGrader, ListGrader...) or public plugins (IntegralGrader) you should not notice any difference. If you have previously written your own grading class, this change could affect what errors messages are displayed to students. In particular, only exceptions inheriting from MITxError will display their messages to students; other errors will be replaced with a generic error message. Version 1.1.1 # Added AsciiMath renderer definitions We now check for naming collisions in your configuration Cleaned up voluptuous incorporation Extend domain of factorial function to all complex, except negative integers Removed .pyc files from the zip file Minor bug fixes Version 1.1.0 # Added numbered variables to FormulaGrader Removed case-insensitive comparisons from FormulaGrader and IntegralGrader. Warning This is a departure from edX and is a breaking change for authors who used case-insensitive FormulaGraders. However: Case-sensitive has always been the default for FormulaGrader and we are not aware of authors using case-insensitive FormulaGraders. Pedagogically, we believe that students should think of M and m are different variables. Removing case-insensitive comparison fixes a number of ambiguous situations. Version 1.0 # Version 1.0.5 # Improved debugging information for FormulaGrader FormulaGrader and IntegralGrader perform whitelist, blacklist, and forbidden_string checks after determining answer correctness. Incorrect answers using forbidden strings / functions are now marked incorrect, while correct answers using forbidden strings / functions raise errors. Minor improvements to existing unit tests Version 1.0.4 # Authors can now specify a custom comparer function for FormulaGrader IntegralGrader now handles complex integrands, and gives meaningful error messages for complex limits. Miscellaneous bug fixes for tensor variable name parsing Version 1.0.3 # Added tensor variable names Version 1.0.2 # Added error messages for overflow, division-by-zero, and out-of-domain errors in formulas Added tests to reach 100% coverage Removed redundant code Fixed some bugs in unused code Version 1.0.1 # Added DependentSampler Fixed issue with zip file tests Added doctests to test suite Fixed bug in FormulaGrader when given an empty string Version 1.0.0 # First release!","title":"Changelog"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-3","text":"This major release removes support for Python 2 and older versions of Python 3 and adds support for Python 3.8 and 3.11.","title":"Version 3"},{"location":"changelog/#version-30","text":"","title":"Version 3.0"},{"location":"changelog/#version-300","text":"Add Python 3.8 and 3.11 support Drop Python 2 support Remove six package","title":"Version 3.0.0"},{"location":"changelog/#version-2","text":"This is a major new version with many new features added. We have been very careful to preserve backwards compatibility of the outward-facing API of the library while adding new features. The biggest change (and the reason for the major version number) is that we are now fully compatible with python versions 2.7, 3.6 and 3.7. All typical applications of version 1.2 should be compatible with version 2. However, we do warn that we broke internal backwards compatibility in a number of locations in order to accommodate python 3. If you previously wrote custom plugins for version 1.2, we cannot guarantee that they will continue to work in version 2.","title":"Version 2"},{"location":"changelog/#version-24","text":"","title":"Version 2.4"},{"location":"changelog/#version-241","text":"Implemented the option to specify a tuple of multiple possible answers in an 'expect' keyword when supplying specific messages and grades.","title":"Version 2.4.1"},{"location":"changelog/#version-240","text":"Refactored loading of scipy to only occur when required. This should make the library load significantly faster, which will resolve a lot of codejail timeout errors (we hope!).","title":"Version 2.4.0"},{"location":"changelog/#version-23","text":"","title":"Version 2.3"},{"location":"changelog/#version-233","text":"Refactored sampling to allow sibling variables to be used in DependentSampler s.","title":"Version 2.3.3"},{"location":"changelog/#version-232","text":"Fixed a bug where long integers passed in as a variable (via DiscreteSet ) or user-defined constant would cause an error in evaluation (such numbers are now cast as floats).","title":"Version 2.3.2"},{"location":"changelog/#version-231","text":"Added a feature to math graders to remove default constants such as pi or i . Updated math parser to treat emdash unicode characters as minus signs (thanks Derek Rhodes!). Updated pytest version to last version supporting python 2.","title":"Version 2.3.1"},{"location":"changelog/#version-230","text":"Updated unit tests to use python and library versions consistent with edx.org. Updated documentation to reflect edX usage of python 3. Added python version to debug output. Fixed a bug in LinearComparer that caused a crash when a student provided a constant answer. Fixed a bug in debug output for math graders that caused output not to show.","title":"Version 2.3.0"},{"location":"changelog/#version-22","text":"","title":"Version 2.2"},{"location":"changelog/#version-220","text":"Rewrote IntegralGrader and FormulaGrader to leverage the same underlying functions, which allows all of the options in FormulaGrader to also apply to IntegralGrader . Constructed SumGrader , which operates like IntegralGrader , but grades sums instead of integrals.","title":"Version 2.2.0"},{"location":"changelog/#version-21","text":"","title":"Version 2.1"},{"location":"changelog/#version-211","text":"Fixed a bug in LinearComparer when a student's answer was constant.","title":"Version 2.1.1"},{"location":"changelog/#version-210","text":"Added a new grader IntervalGrader , which grades expressions for mathematical intervals. Added allow_inf option to FormulaGrader and NumericalGrader , which allow for infty (infinity) to appear in expressions. SingleListGrader can now be provided answers as a single string. It can also infer answers from the expect keyword of a customresponse tag.","title":"Version 2.1.0"},{"location":"changelog/#version-20","text":"","title":"Version 2.0"},{"location":"changelog/#version-202","text":"Fix a bug with custom AsciiMath preprocessor where lonely square roots (e.g., x + sqrt + y ) rendered badly.","title":"Version 2.0.2"},{"location":"changelog/#version-201","text":"Fixed a bug in StringGrader regex validation that only required the start of student input to match the pattern.","title":"Version 2.0.1"},{"location":"changelog/#version-200","text":"Feature updates: Graders can now be constructed in-line in a customresponse, rather than in a python code block. Credit awarded can now be dependent upon the attempt number. Introduced a new plug-in to set course-wide defaults that differ from library defaults. StringGrader received a major overhaul, and can now require minimum character or word lengths, and also pattern match to regular expressions. Further options to treat whitespace were introduced. The structure of SingleListGrader answers now uses and extends that used by ItemGrader answers, leading to more general ways of expressing answers and providing feedback to students. Answers to SingleListGrader problems can now be inferred from the expect keyword. SingleListGrader can now warn students that they have missing entries. Partial credit can now be turned off in ListGrader problems. Partial credit can now be awarded in matrix entry problems, with messages explaining which entries are correct. Implemented LinearComparer , which can assign partial/full credit to formula responses that are linearly related to answers. Comparers for math problems can now be set much more straightforwardly. floor , ceil , min and max functions were added to the math library. In math problems, introduced an option to apply a transforming function to the answer and student input before comparing. Completely overhauled matrix sampling to allow most typical matrix types to be sampled. Introduced instructor variables for math problems, which authors can use in constructing the problem, but students may not use in their responses. DependentSampler now has access to constants and user functions, and no longer needs the depends key. DiscreteSet will now work with arrays. All comparers are now imported when using from mitxgraders import * . Under the hood: Ensured that the entire library (including tests) is compatible with python 2.7 and python 3.6/3.7, in preparation for edX's upcoming transition to python 3. (The change to having internal unicode literals is the biggest internal backward-compatability-breaking issue from version 1.2.) Introduced CorrelatedComparer s, which compare multiple samples at once. IntegralGrader has been promoted from a plug-in to a core component of the library. SpecifyDomain has been expanded to allow for functions with any number of arguments. Javascript preprocessor was tidied up, and further options for customization were included. All documentation examples are now run as doctests. Upgraded voluptuous to version 0.11.5. Upgraded testing infrastructure. Bug fixes: Fixed a bug in assigning partial credit in ListGrader s when multiple lists of answers were included.","title":"Version 2.0.0"},{"location":"changelog/#version-1","text":"","title":"Version 1"},{"location":"changelog/#version-12","text":"","title":"Version 1.2"},{"location":"changelog/#version-123","text":"Added new custom comparers vector_span_comparer and vector_phase_comparer . Updated AsciiMath preprocessor to handle lonely mover (math-over) entries.","title":"Version 1.2.3"},{"location":"changelog/#version-122","text":"Added accept_any and accept_nonempty options to StringGrader . If only a single text input is present, the answers key is inferred from the expect attribute of the customresponse tag (does not work for SingleListInput however). Updated AsciiMath preprocessor to handle variable names and user-defined functions properly. Various small bug fixes.","title":"Version 1.2.2"},{"location":"changelog/#version-121","text":"Added arctan2(x, y) function that returns angle between +x axis and the point (x, y); available by default for students to use in FormulaGrader problems. Rewrote the expression parser and evaluator. Among other things, new parser provides better error messages when explicit multiplication is forgotten in expressions like '5x + 3' . Also validates curly brace balancing, which may be used in tensor variable names.","title":"Version 1.2.1"},{"location":"changelog/#version-120","text":"This version includes a number of new features and documentation updates. A new documentation website Math parser now supports multivariable functions and array input (vector, matrix, etc). Many improvements to our mathjax preprocessor Improvements to balanced bracket validator. Added new class MatrixGrader (see MatrixGrader documentation ) along with supporting sampling classes RealMatrices and RealVectors When FormulaGrader (and its subclasses) are used inside an ordered ListGrader , authors can now grade multiple student inputs in comparison to each other by specifying answers in terms of sibling variables FormulaGrader (and its subclasses) now support comparer functions that can be used to grade student input more flexibly. For example, rather than checking checking that the student input and author input are equal, check that they are equal modulo a certain number. Built-in comparers: equality_comparer congruence_comparer between_comparer eigenvector_comparer","title":"Version 1.2.0"},{"location":"changelog/#version-11","text":"","title":"Version 1.1"},{"location":"changelog/#version-112","text":"This version includes an internal change to the way that errors are handled during check. If you only use builtin graders (FormulaGrader, ListGrader...) or public plugins (IntegralGrader) you should not notice any difference. If you have previously written your own grading class, this change could affect what errors messages are displayed to students. In particular, only exceptions inheriting from MITxError will display their messages to students; other errors will be replaced with a generic error message.","title":"Version 1.1.2"},{"location":"changelog/#version-111","text":"Added AsciiMath renderer definitions We now check for naming collisions in your configuration Cleaned up voluptuous incorporation Extend domain of factorial function to all complex, except negative integers Removed .pyc files from the zip file Minor bug fixes","title":"Version 1.1.1"},{"location":"changelog/#version-110","text":"Added numbered variables to FormulaGrader Removed case-insensitive comparisons from FormulaGrader and IntegralGrader. Warning This is a departure from edX and is a breaking change for authors who used case-insensitive FormulaGraders. However: Case-sensitive has always been the default for FormulaGrader and we are not aware of authors using case-insensitive FormulaGraders. Pedagogically, we believe that students should think of M and m are different variables. Removing case-insensitive comparison fixes a number of ambiguous situations.","title":"Version 1.1.0"},{"location":"changelog/#version-10","text":"","title":"Version 1.0"},{"location":"changelog/#version-105","text":"Improved debugging information for FormulaGrader FormulaGrader and IntegralGrader perform whitelist, blacklist, and forbidden_string checks after determining answer correctness. Incorrect answers using forbidden strings / functions are now marked incorrect, while correct answers using forbidden strings / functions raise errors. Minor improvements to existing unit tests","title":"Version 1.0.5"},{"location":"changelog/#version-104","text":"Authors can now specify a custom comparer function for FormulaGrader IntegralGrader now handles complex integrands, and gives meaningful error messages for complex limits. Miscellaneous bug fixes for tensor variable name parsing","title":"Version 1.0.4"},{"location":"changelog/#version-103","text":"Added tensor variable names","title":"Version 1.0.3"},{"location":"changelog/#version-102","text":"Added error messages for overflow, division-by-zero, and out-of-domain errors in formulas Added tests to reach 100% coverage Removed redundant code Fixed some bugs in unused code","title":"Version 1.0.2"},{"location":"changelog/#version-101","text":"Added DependentSampler Fixed issue with zip file tests Added doctests to test suite Fixed bug in FormulaGrader when given an empty string","title":"Version 1.0.1"},{"location":"changelog/#version-100","text":"First release!","title":"Version 1.0.0"},{"location":"edx/","text":"edX Syntax # To create an edX problem using the MITx Grading Library, you need to create a \"Blank Advanced Problem\", which allows you to construct the problem description via XML. The library is used in customresponse problems, which means that there are two parts to setting up the problem: defining the input that the student sees, and defining the grader that will grade the result. Here is an example. <problem> <!-- Define the grader --> <script type= \"text/python\" > from mitxgraders import * grader = FormulaGrader(variables=[\"x\"]) </script> <!-- Ask the question --> <p> Enter the derivative of \\(x^2\\). </p> <!-- Define the problem --> <customresponse cfn= \"grader\" answer= \"2*x\" > <textline math= \"true\" /> </customresponse> <!-- Ask another question --> <p> Enter the derivative of \\(5x^2\\). </p> <!-- Define the problem. Note that the grader is reused --> <customresponse cfn= \"grader\" answer= \"10*x\" > <textline math= \"true\" /> </customresponse> </problem> Note that the customresponse tag contains the answer that is passed to the grader. You can also use expect=\"2*x\" instead of answer=\"2*x\" ; edX treats these parameters indistinguishably (although we strongly suggest not using both!). Also note that a grader can be used multiple times if desired. Using an answers key to a grader # If you provide an answers key to the grader, it will ignore whatever is specified in the customresponse tag. Here is an example. <problem> <script type= \"text/python\" > from mitxgraders import * mygrader = FormulaGrader( answers={'expect': '2*x', 'msg': 'Good job!'}, variables=['x'] ) </script> <p> Enter the derivative of \\(x^2\\). </p> <customresponse cfn= \"mygrader\" answer= \"2*x\" > <textline math= \"true\" /> </customresponse> </problem> The answers key is provided to the grader explicitly, and so it ignores whatever is in the customresponse tag. However, the answer key in the customresponse tag is still important, because it is what the students see when they click on \"Show Answer\". Also worth noting is that the grader is stored in a python variable, which in this example, we've called mygrader (the previous example just called it grader ). The cfn key in the customresponse tag needs to tell edX which variable stores the grader you want to use for that problem. If you have multiple customresponse tags, you can provide a different grader to each one. Using correct_answer for multiple inputs # If you are using multiple inputs (such as when using a ListGrader ), you must provide the answers key to the grader explicitly, as the expect or answer parameters in the customresponse tag are ignored by both edX and the grader. When using multiple inputs, it's recommended to provide a correct_answer parameter on the textline tags, which is what is used to show students the correct answer. Here is an example. <problem> <script type= \"text/python\" > from mitxgraders import * grader = ListGrader( answers=['x-2', 'x+2'], subgraders=FormulaGrader(variables=['x']) ) </script> <p> What are the linear factors of \\((x^2 - 4)\\)? Enter your answers in any order. </p> <!-- Note there is no 'expect' or 'answer' parameter in the customresponse tag --> <customresponse cfn= \"grader\" > <!-- correct_answer is shown to student when they press [Show Answer]. Its value is not used for grading purposes --> <textline math= \"true\" correct_answer= \"x - 2\" /> <textline math= \"true\" correct_answer= \"x + 2\" /> </customresponse> </problem> Note that the correct_answer parameters are never sent to the grader, which is why you must provide them independently. When using lists, such as with a ListGrader or a SingleListGrader , you only need to provide an answers key to the top-level grader (the one that is specified in the cfn key). Passing a grader directly # Because the cfn parameter of the customresponse tag is executed as python code, it is possible to provide the definition of the grader in-line, as the following example shows. <problem> <!-- Make sure to remember to import the library! --> <script type= \"text/python\" > from mitxgraders import * </script> <p> Enter the derivative of \\(x^2\\). </p> <customresponse cfn= \"FormulaGrader(variables=['x'])\" answer= \"2*x\" > <textline math= \"true\" /> </customresponse> </problem> We want to stress the simplicity of this example compared to implementing the same problem using standard edX problem types! This method of defining a grader is very handy for simple grader constructions such as this one. For more complex graders, we recommend the previous style. One must be careful to make sure that quotation marks ' and \" do not conflict if using the in-line method. Note on Python Version # The Python version is automatically selected by the edX server. No changes to the XML code are required.","title":"edX Syntax"},{"location":"edx/#edx-syntax","text":"To create an edX problem using the MITx Grading Library, you need to create a \"Blank Advanced Problem\", which allows you to construct the problem description via XML. The library is used in customresponse problems, which means that there are two parts to setting up the problem: defining the input that the student sees, and defining the grader that will grade the result. Here is an example. <problem> <!-- Define the grader --> <script type= \"text/python\" > from mitxgraders import * grader = FormulaGrader(variables=[\"x\"]) </script> <!-- Ask the question --> <p> Enter the derivative of \\(x^2\\). </p> <!-- Define the problem --> <customresponse cfn= \"grader\" answer= \"2*x\" > <textline math= \"true\" /> </customresponse> <!-- Ask another question --> <p> Enter the derivative of \\(5x^2\\). </p> <!-- Define the problem. Note that the grader is reused --> <customresponse cfn= \"grader\" answer= \"10*x\" > <textline math= \"true\" /> </customresponse> </problem> Note that the customresponse tag contains the answer that is passed to the grader. You can also use expect=\"2*x\" instead of answer=\"2*x\" ; edX treats these parameters indistinguishably (although we strongly suggest not using both!). Also note that a grader can be used multiple times if desired.","title":"edX Syntax"},{"location":"edx/#using-an-answers-key-to-a-grader","text":"If you provide an answers key to the grader, it will ignore whatever is specified in the customresponse tag. Here is an example. <problem> <script type= \"text/python\" > from mitxgraders import * mygrader = FormulaGrader( answers={'expect': '2*x', 'msg': 'Good job!'}, variables=['x'] ) </script> <p> Enter the derivative of \\(x^2\\). </p> <customresponse cfn= \"mygrader\" answer= \"2*x\" > <textline math= \"true\" /> </customresponse> </problem> The answers key is provided to the grader explicitly, and so it ignores whatever is in the customresponse tag. However, the answer key in the customresponse tag is still important, because it is what the students see when they click on \"Show Answer\". Also worth noting is that the grader is stored in a python variable, which in this example, we've called mygrader (the previous example just called it grader ). The cfn key in the customresponse tag needs to tell edX which variable stores the grader you want to use for that problem. If you have multiple customresponse tags, you can provide a different grader to each one.","title":"Using an answers key to a grader"},{"location":"edx/#using-correct_answer-for-multiple-inputs","text":"If you are using multiple inputs (such as when using a ListGrader ), you must provide the answers key to the grader explicitly, as the expect or answer parameters in the customresponse tag are ignored by both edX and the grader. When using multiple inputs, it's recommended to provide a correct_answer parameter on the textline tags, which is what is used to show students the correct answer. Here is an example. <problem> <script type= \"text/python\" > from mitxgraders import * grader = ListGrader( answers=['x-2', 'x+2'], subgraders=FormulaGrader(variables=['x']) ) </script> <p> What are the linear factors of \\((x^2 - 4)\\)? Enter your answers in any order. </p> <!-- Note there is no 'expect' or 'answer' parameter in the customresponse tag --> <customresponse cfn= \"grader\" > <!-- correct_answer is shown to student when they press [Show Answer]. Its value is not used for grading purposes --> <textline math= \"true\" correct_answer= \"x - 2\" /> <textline math= \"true\" correct_answer= \"x + 2\" /> </customresponse> </problem> Note that the correct_answer parameters are never sent to the grader, which is why you must provide them independently. When using lists, such as with a ListGrader or a SingleListGrader , you only need to provide an answers key to the top-level grader (the one that is specified in the cfn key).","title":"Using correct_answer for multiple inputs"},{"location":"edx/#passing-a-grader-directly","text":"Because the cfn parameter of the customresponse tag is executed as python code, it is possible to provide the definition of the grader in-line, as the following example shows. <problem> <!-- Make sure to remember to import the library! --> <script type= \"text/python\" > from mitxgraders import * </script> <p> Enter the derivative of \\(x^2\\). </p> <customresponse cfn= \"FormulaGrader(variables=['x'])\" answer= \"2*x\" > <textline math= \"true\" /> </customresponse> </problem> We want to stress the simplicity of this example compared to implementing the same problem using standard edX problem types! This method of defining a grader is very handy for simple grader constructions such as this one. For more complex graders, we recommend the previous style. One must be careful to make sure that quotation marks ' and \" do not conflict if using the in-line method.","title":"Passing a grader directly"},{"location":"edx/#note-on-python-version","text":"The Python version is automatically selected by the edX server. No changes to the XML code are required.","title":"Note on Python Version"},{"location":"faq/","text":"Frequently Asked Questions (FAQs) # Does the grading library work with multiple choice/checkbox/dropdown lists? Unfortunately, no. Those problem types cannot be used in a customresponse problem, so we can't grade them with a python grader. Does the grader work with python 2 or python 3? It works with both! Older versions of edX ran python graders in python 2.7; newer versions use python 3.8. The library works seamlessly with both. No changes to any code are required to switch between versions. Some functionality requires python 3.5 however.","title":"FAQs"},{"location":"faq/#frequently-asked-questions-faqs","text":"Does the grading library work with multiple choice/checkbox/dropdown lists? Unfortunately, no. Those problem types cannot be used in a customresponse problem, so we can't grade them with a python grader. Does the grader work with python 2 or python 3? It works with both! Older versions of edX ran python graders in python 2.7; newer versions use python 3.8. The library works seamlessly with both. No changes to any code are required to switch between versions. Some functionality requires python 3.5 however.","title":"Frequently Asked Questions (FAQs)"},{"location":"graders/","text":"Introduction to Graders # Graders are implemented as python classes. All grading classes are instantiated by calling them. Options can be provided using keyword arguments as grader = FakeGradingClass ( option_1 = value_1 , option_2 = value2 ) # FakeGradingClass is not real! It's just a placeholder. or with a configuration dictionary: config = { 'option_1' : value_1 , 'option_2' : value_2 } grader = FakeGradingClass ( config ) Passing the configuration as a dictionary can be useful if you are using the same configuration for multiple problems. However, you cannot 'mix and match' these two options: if a configuration dictionary is supplied, any keyword arguments are ignored. Most configuration options are specific to their grading classes. For example, FormulaGrader has a variables configuration key, but NumericalGrader does not. A few configuration options are available to all grading classes. Debugging # Every grading class has a debug option. By default, debug=False . To receive debug information from a given grader, specify debug=True . Some graders will provide more debug information than others. Debug information can be used by authors to check to make sure that the graders are behaving as expected, but shouldn't be made available to students. grader = FakeGradingClass ( debug = True ) Validation # Every grading class has a suppress_warnings key. The options passed to a grading class undergo extensive validation and graders will giver error messages if instantiated with invalid options. A few error messages serve only as warnings. For example, if you attempt to configure a FormulaGrader with pi as a variable, you will receive a warning: >>> from mitxgraders import * >>> try : ... grader = FormulaGrader ( variables = [ 'pi' ]) ... except ConfigError as error : ... print ( error ) Warning: 'variables' contains entries 'pi' which will override default values. If you intend to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration. As the warning message says, if you really want to override the default value of pi (not recommended!) then you can suppress this warning by setting suppress_warnings=True . >>> from mitxgraders import * >>> grader = FormulaGrader ( variables = [ 'pi' ], suppress_warnings = True ) Attempt-Based Partial Credit # It is possible to pass a student's attempt number to a grader by explicitly requesting that edX do so in a customresponse tag as follows. <customresponse cfn= \"grader\" expect= \"answer\" cfn_extra_args= \"attempt\" > Once this is done, you can enable attempt-based partial credit for your graders. The syntax is as follows. grader = FakeGradingClass ( attempt_based_credit = ( None | function ), # default None attempt_based_credit_msg = True # default True ) Attempt-based partial credit is turned on by specifying a function to convert an attempt number into an amount of credit. We provide three functions to do this, but you can of course write your own. If a student's credit has been decreased from the maximum by attempt-based partial credit, the student can be provided with a message informing them of the maximum possible credit at that attempt number. This is controlled by the attempt_based_credit_msg setting. We recommend that this setting be left on, as it will likely lead to confusion otherwise. When using nested graders, the attempt_based_credit setting need only be applied to the grader that is provided to edX in the cfn key. Note that if attempt-based partial credit is turned on but the cfn_extra_args=\"attempt\" entry is missing from the customresponse tag, an error message results. Attempt-based partial credit can be set on a course-wide basis through the use of plugins . ReciprocalCredit # This function simply awards credit based on the reciprocal of the attempt number. There are no options to set. >>> grader = StringGrader ( attempt_based_credit = ReciprocalCredit ()) >>> grader ( 'cat' , 'cat' , attempt = 1 ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( 'cat' , 'cat' , attempt = 2 ) == { 'grade_decimal' : 0.5 , 'msg' : 'Maximum credit for attempt #2 is 50%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 3 ) == { 'grade_decimal' : 0.3333 , 'msg' : 'Maximum credit for attempt #3 is 33.3%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 4 ) == { 'grade_decimal' : 0.25 , 'msg' : 'Maximum credit for attempt #4 is 25%.' , 'ok' : 'partial' } True GeometricCredit # This function decreases the possible credit by a factor for each attempt, forming a geometric progression. You may choose the factor, which defaults to 0.5. >>> grader = StringGrader ( attempt_based_credit = GeometricCredit ( factor = 0.5 )) >>> grader ( 'cat' , 'cat' , attempt = 1 ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( 'cat' , 'cat' , attempt = 2 ) == { 'grade_decimal' : 0.5 , 'msg' : 'Maximum credit for attempt #2 is 50%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 3 ) == { 'grade_decimal' : 0.25 , 'msg' : 'Maximum credit for attempt #3 is 25%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 4 ) == { 'grade_decimal' : 0.125 , 'msg' : 'Maximum credit for attempt #4 is 12.5%.' , 'ok' : 'partial' } True LinearCredit # This function allows the first few attempts to have maximum credit, then linearly decreases credit until a minimum threshold is reached. The maximum score begins to decrease after the attempt specified in decrease_credit_after . By default, all attempts after the first will have decreasing credit. The credit decreases linearly to minimum_credit . The number of attempts the credit decreases for is specified in decrease_credit_steps . So, using the defaults, attempts 1, 2, 3, 4, 5, and 6 are eligible for maximum credits of 1, 0.8, 0.6, 0.4, 0.2 and 0.2, respectively. The following example demonstrates the default settings. >>> creditor = LinearCredit ( ... decrease_credit_after = 1 , # First attempt receives full credit ... minimum_credit = 0.2 , # Minimum credit ... decrease_credit_steps = 4 # Number of attempts on the linear slope ... ) >>> creditor == LinearCredit () True >>> grader = StringGrader ( attempt_based_credit = creditor ) >>> grader ( 'cat' , 'cat' , attempt = 1 ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( 'cat' , 'cat' , attempt = 2 ) == { 'grade_decimal' : 0.8 , 'msg' : 'Maximum credit for attempt #2 is 80%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 3 ) == { 'grade_decimal' : 0.6 , 'msg' : 'Maximum credit for attempt #3 is 60%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 4 ) == { 'grade_decimal' : 0.4 , 'msg' : 'Maximum credit for attempt #4 is 40%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 5 ) == { 'grade_decimal' : 0.2 , 'msg' : 'Maximum credit for attempt #5 is 20%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 6 ) == { 'grade_decimal' : 0.2 , 'msg' : 'Maximum credit for attempt #6 is 20%.' , 'ok' : 'partial' } True Option Listing # Here is the full list of options specific to all graders. grader = AbstractGrader ( debug = bool , # default False wrong_msg = str , # default '' attempt_based_credit = ( None | function ), # default None attempt_based_credit_msg = bool , # default True )","title":"Introduction to Graders"},{"location":"graders/#introduction-to-graders","text":"Graders are implemented as python classes. All grading classes are instantiated by calling them. Options can be provided using keyword arguments as grader = FakeGradingClass ( option_1 = value_1 , option_2 = value2 ) # FakeGradingClass is not real! It's just a placeholder. or with a configuration dictionary: config = { 'option_1' : value_1 , 'option_2' : value_2 } grader = FakeGradingClass ( config ) Passing the configuration as a dictionary can be useful if you are using the same configuration for multiple problems. However, you cannot 'mix and match' these two options: if a configuration dictionary is supplied, any keyword arguments are ignored. Most configuration options are specific to their grading classes. For example, FormulaGrader has a variables configuration key, but NumericalGrader does not. A few configuration options are available to all grading classes.","title":"Introduction to Graders"},{"location":"graders/#debugging","text":"Every grading class has a debug option. By default, debug=False . To receive debug information from a given grader, specify debug=True . Some graders will provide more debug information than others. Debug information can be used by authors to check to make sure that the graders are behaving as expected, but shouldn't be made available to students. grader = FakeGradingClass ( debug = True )","title":"Debugging"},{"location":"graders/#validation","text":"Every grading class has a suppress_warnings key. The options passed to a grading class undergo extensive validation and graders will giver error messages if instantiated with invalid options. A few error messages serve only as warnings. For example, if you attempt to configure a FormulaGrader with pi as a variable, you will receive a warning: >>> from mitxgraders import * >>> try : ... grader = FormulaGrader ( variables = [ 'pi' ]) ... except ConfigError as error : ... print ( error ) Warning: 'variables' contains entries 'pi' which will override default values. If you intend to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration. As the warning message says, if you really want to override the default value of pi (not recommended!) then you can suppress this warning by setting suppress_warnings=True . >>> from mitxgraders import * >>> grader = FormulaGrader ( variables = [ 'pi' ], suppress_warnings = True )","title":"Validation"},{"location":"graders/#attempt-based-partial-credit","text":"It is possible to pass a student's attempt number to a grader by explicitly requesting that edX do so in a customresponse tag as follows. <customresponse cfn= \"grader\" expect= \"answer\" cfn_extra_args= \"attempt\" > Once this is done, you can enable attempt-based partial credit for your graders. The syntax is as follows. grader = FakeGradingClass ( attempt_based_credit = ( None | function ), # default None attempt_based_credit_msg = True # default True ) Attempt-based partial credit is turned on by specifying a function to convert an attempt number into an amount of credit. We provide three functions to do this, but you can of course write your own. If a student's credit has been decreased from the maximum by attempt-based partial credit, the student can be provided with a message informing them of the maximum possible credit at that attempt number. This is controlled by the attempt_based_credit_msg setting. We recommend that this setting be left on, as it will likely lead to confusion otherwise. When using nested graders, the attempt_based_credit setting need only be applied to the grader that is provided to edX in the cfn key. Note that if attempt-based partial credit is turned on but the cfn_extra_args=\"attempt\" entry is missing from the customresponse tag, an error message results. Attempt-based partial credit can be set on a course-wide basis through the use of plugins .","title":"Attempt-Based Partial Credit"},{"location":"graders/#reciprocalcredit","text":"This function simply awards credit based on the reciprocal of the attempt number. There are no options to set. >>> grader = StringGrader ( attempt_based_credit = ReciprocalCredit ()) >>> grader ( 'cat' , 'cat' , attempt = 1 ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( 'cat' , 'cat' , attempt = 2 ) == { 'grade_decimal' : 0.5 , 'msg' : 'Maximum credit for attempt #2 is 50%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 3 ) == { 'grade_decimal' : 0.3333 , 'msg' : 'Maximum credit for attempt #3 is 33.3%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 4 ) == { 'grade_decimal' : 0.25 , 'msg' : 'Maximum credit for attempt #4 is 25%.' , 'ok' : 'partial' } True","title":"ReciprocalCredit"},{"location":"graders/#geometriccredit","text":"This function decreases the possible credit by a factor for each attempt, forming a geometric progression. You may choose the factor, which defaults to 0.5. >>> grader = StringGrader ( attempt_based_credit = GeometricCredit ( factor = 0.5 )) >>> grader ( 'cat' , 'cat' , attempt = 1 ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( 'cat' , 'cat' , attempt = 2 ) == { 'grade_decimal' : 0.5 , 'msg' : 'Maximum credit for attempt #2 is 50%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 3 ) == { 'grade_decimal' : 0.25 , 'msg' : 'Maximum credit for attempt #3 is 25%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 4 ) == { 'grade_decimal' : 0.125 , 'msg' : 'Maximum credit for attempt #4 is 12.5%.' , 'ok' : 'partial' } True","title":"GeometricCredit"},{"location":"graders/#linearcredit","text":"This function allows the first few attempts to have maximum credit, then linearly decreases credit until a minimum threshold is reached. The maximum score begins to decrease after the attempt specified in decrease_credit_after . By default, all attempts after the first will have decreasing credit. The credit decreases linearly to minimum_credit . The number of attempts the credit decreases for is specified in decrease_credit_steps . So, using the defaults, attempts 1, 2, 3, 4, 5, and 6 are eligible for maximum credits of 1, 0.8, 0.6, 0.4, 0.2 and 0.2, respectively. The following example demonstrates the default settings. >>> creditor = LinearCredit ( ... decrease_credit_after = 1 , # First attempt receives full credit ... minimum_credit = 0.2 , # Minimum credit ... decrease_credit_steps = 4 # Number of attempts on the linear slope ... ) >>> creditor == LinearCredit () True >>> grader = StringGrader ( attempt_based_credit = creditor ) >>> grader ( 'cat' , 'cat' , attempt = 1 ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( 'cat' , 'cat' , attempt = 2 ) == { 'grade_decimal' : 0.8 , 'msg' : 'Maximum credit for attempt #2 is 80%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 3 ) == { 'grade_decimal' : 0.6 , 'msg' : 'Maximum credit for attempt #3 is 60%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 4 ) == { 'grade_decimal' : 0.4 , 'msg' : 'Maximum credit for attempt #4 is 40%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 5 ) == { 'grade_decimal' : 0.2 , 'msg' : 'Maximum credit for attempt #5 is 20%.' , 'ok' : 'partial' } True >>> grader ( 'cat' , 'cat' , attempt = 6 ) == { 'grade_decimal' : 0.2 , 'msg' : 'Maximum credit for attempt #6 is 20%.' , 'ok' : 'partial' } True","title":"LinearCredit"},{"location":"graders/#option-listing","text":"Here is the full list of options specific to all graders. grader = AbstractGrader ( debug = bool , # default False wrong_msg = str , # default '' attempt_based_credit = ( None | function ), # default None attempt_based_credit_msg = bool , # default True )","title":"Option Listing"},{"location":"item_grader/","text":"ItemGrader # When an individual input needs to be graded, it is graded by an ItemGrader . All ItemGrader s work by specifying answers and their corresponding points/messages, as well as an optional message for wrong answers. In these examples, we use StringGrader as an example of how to use a generic ItemGrader . You cannot use a generic ItemGrader by itself. >>> from mitxgraders import * >>> grader = StringGrader ( ... answers = 'cat' , ... wrong_msg = 'Try again!' ... ) The grader is set up to grade an answer of cat as correct, and includes a message that is presented to students if they get the answer wrong. One could pass grader in as the cfn key for a customresponse tag. The following code demonstrates what happens when the grader is called using python (for example, inside a python console). Note that this is only for demonstrating the behavior of the grader, and is not required in order to use the library in edX. >>> grader ( None , 'cat' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog' ) == { 'grade_decimal' : 0 , 'msg' : 'Try again!' , 'ok' : False } True You will often see this type of demonstration in this documentation. It serves both to demonstrate how the grader works and to ensure that our examples are always syntactically correct, as these code blocks form part of our documentation testing. Note that grader accepts two arguments. This is because edX passes two arguments to all graders. The first argument is the expect or answer value associated with the customresponse tag. Here, we supply None , as the grader already has its answer specified. The second argument is the student input. If the customresponse problem has multiple inputs, the second argument is a list of the student inputs. Specifying Answers # For all ItemGrader s, the answers key can be used to specify correct answers, specific feedback messages, and to assign partial credit. It accepts a few formats: A single dictionary can be used to specify an answer, feedback, correctness, and partial credit. The dictionary keys are: 'expect' (required): compared against student answer. Most ItemGrader s use strings to specify the 'expect' value. You may also specify a tuple of values like ('option1', 'option2') if you want the same grade and message applied to all these inputs. 'grade_decimal' (optional, a number between 0 and 1 inclusive): The credit associated with this answer (default 1 ). 'msg' (optional, string): An optional feedback message associated with this answer (default '' ). >>> grader = StringGrader ( ... answers = { 'expect' : 'zebra' , 'grade_decimal' : 1 , 'msg' : 'Yay!' }, ... wrong_msg = 'Try again!' ... ) >>> grader ( None , 'zebra' ) == { 'grade_decimal' : 1 , 'msg' : 'Yay!' , 'ok' : True } True >>> grader ( None , 'cat' ) == { 'grade_decimal' : 0 , 'msg' : 'Try again!' , 'ok' : False } True A single 'expect' value: can be used to specify the correct answer. For example, >>> grader = StringGrader ( ... answers = 'zebra' , ... # Equivalent to: ... # answers={'expect': 'zebra', 'msg': '', 'grade_decimal': 1} ... wrong_msg = 'Try again!' ... ) >>> grader ( None , 'zebra' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'cat' ) == { 'grade_decimal' : 0 , 'msg' : 'Try again!' , 'ok' : False } True Again, most ItemGrader s use strings to store 'expect' values. A tuple of the afore-mentioned dictionaries/strings, which specifies multiple possible answers: >>> grader = StringGrader ( ... answers = ( ... # the correct answer ... 'wolf' , ... # an alternative correct answer ... 'canis lupus' , ... # a partially correct answer ... { 'expect' : 'dog' , 'grade_decimal' : 0.5 , 'msg' : 'No, not dog!' }, ... # a wrong answer with specific feedback ... { 'expect' : 'unicorn' , 'grade_decimal' : 0 , 'msg' : 'No, not unicorn!' }, ... # multiple wrong answers with specific feedback ... { 'expect' : ( 'werewolf' , 'vampire' ), 'grade_decimal' : 0 , 'msg' : 'Wrong universe!' } ... ), ... wrong_msg = 'Try again!' ... ) >>> grader ( None , 'wolf' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'canis lupus' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog' ) == { 'grade_decimal' : 0.5 , 'msg' : 'No, not dog!' , 'ok' : 'partial' } True >>> grader ( None , 'unicorn' ) == { 'grade_decimal' : 0 , 'msg' : 'No, not unicorn!' , 'ok' : False } True >>> grader ( None , 'werewolf' ) == { 'grade_decimal' : 0 , 'msg' : 'Wrong universe!' , 'ok' : False } True >>> grader ( None , 'vampire' ) == { 'grade_decimal' : 0 , 'msg' : 'Wrong universe!' , 'ok' : False } True >>> grader ( None , 'cat' ) == { 'grade_decimal' : 0 , 'msg' : 'Try again!' , 'ok' : False } True Internally, the ItemGrader converts the answers entry into a tuple of dictionaries. When grading, it asks the specific grading class to grade the response against each possible answer, and selects the best outcome for the student. The wrong_msg is only displayed if the score is zero and there are no other messages. If no answers key is provided, the grader reads from the expect or answer parameter of the customresponse tag (see edX Syntax ). Note that when using a ListGrader , the answers key is required. Option Listing # Here is the full list of options specific to ItemGrader s. grader = ItemGrader ( answers = ( str , dict , ( str , dict )), wrong_msg = str , # default '' )","title":"ItemGrader"},{"location":"item_grader/#itemgrader","text":"When an individual input needs to be graded, it is graded by an ItemGrader . All ItemGrader s work by specifying answers and their corresponding points/messages, as well as an optional message for wrong answers. In these examples, we use StringGrader as an example of how to use a generic ItemGrader . You cannot use a generic ItemGrader by itself. >>> from mitxgraders import * >>> grader = StringGrader ( ... answers = 'cat' , ... wrong_msg = 'Try again!' ... ) The grader is set up to grade an answer of cat as correct, and includes a message that is presented to students if they get the answer wrong. One could pass grader in as the cfn key for a customresponse tag. The following code demonstrates what happens when the grader is called using python (for example, inside a python console). Note that this is only for demonstrating the behavior of the grader, and is not required in order to use the library in edX. >>> grader ( None , 'cat' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog' ) == { 'grade_decimal' : 0 , 'msg' : 'Try again!' , 'ok' : False } True You will often see this type of demonstration in this documentation. It serves both to demonstrate how the grader works and to ensure that our examples are always syntactically correct, as these code blocks form part of our documentation testing. Note that grader accepts two arguments. This is because edX passes two arguments to all graders. The first argument is the expect or answer value associated with the customresponse tag. Here, we supply None , as the grader already has its answer specified. The second argument is the student input. If the customresponse problem has multiple inputs, the second argument is a list of the student inputs.","title":"ItemGrader"},{"location":"item_grader/#specifying-answers","text":"For all ItemGrader s, the answers key can be used to specify correct answers, specific feedback messages, and to assign partial credit. It accepts a few formats: A single dictionary can be used to specify an answer, feedback, correctness, and partial credit. The dictionary keys are: 'expect' (required): compared against student answer. Most ItemGrader s use strings to specify the 'expect' value. You may also specify a tuple of values like ('option1', 'option2') if you want the same grade and message applied to all these inputs. 'grade_decimal' (optional, a number between 0 and 1 inclusive): The credit associated with this answer (default 1 ). 'msg' (optional, string): An optional feedback message associated with this answer (default '' ). >>> grader = StringGrader ( ... answers = { 'expect' : 'zebra' , 'grade_decimal' : 1 , 'msg' : 'Yay!' }, ... wrong_msg = 'Try again!' ... ) >>> grader ( None , 'zebra' ) == { 'grade_decimal' : 1 , 'msg' : 'Yay!' , 'ok' : True } True >>> grader ( None , 'cat' ) == { 'grade_decimal' : 0 , 'msg' : 'Try again!' , 'ok' : False } True A single 'expect' value: can be used to specify the correct answer. For example, >>> grader = StringGrader ( ... answers = 'zebra' , ... # Equivalent to: ... # answers={'expect': 'zebra', 'msg': '', 'grade_decimal': 1} ... wrong_msg = 'Try again!' ... ) >>> grader ( None , 'zebra' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'cat' ) == { 'grade_decimal' : 0 , 'msg' : 'Try again!' , 'ok' : False } True Again, most ItemGrader s use strings to store 'expect' values. A tuple of the afore-mentioned dictionaries/strings, which specifies multiple possible answers: >>> grader = StringGrader ( ... answers = ( ... # the correct answer ... 'wolf' , ... # an alternative correct answer ... 'canis lupus' , ... # a partially correct answer ... { 'expect' : 'dog' , 'grade_decimal' : 0.5 , 'msg' : 'No, not dog!' }, ... # a wrong answer with specific feedback ... { 'expect' : 'unicorn' , 'grade_decimal' : 0 , 'msg' : 'No, not unicorn!' }, ... # multiple wrong answers with specific feedback ... { 'expect' : ( 'werewolf' , 'vampire' ), 'grade_decimal' : 0 , 'msg' : 'Wrong universe!' } ... ), ... wrong_msg = 'Try again!' ... ) >>> grader ( None , 'wolf' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'canis lupus' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog' ) == { 'grade_decimal' : 0.5 , 'msg' : 'No, not dog!' , 'ok' : 'partial' } True >>> grader ( None , 'unicorn' ) == { 'grade_decimal' : 0 , 'msg' : 'No, not unicorn!' , 'ok' : False } True >>> grader ( None , 'werewolf' ) == { 'grade_decimal' : 0 , 'msg' : 'Wrong universe!' , 'ok' : False } True >>> grader ( None , 'vampire' ) == { 'grade_decimal' : 0 , 'msg' : 'Wrong universe!' , 'ok' : False } True >>> grader ( None , 'cat' ) == { 'grade_decimal' : 0 , 'msg' : 'Try again!' , 'ok' : False } True Internally, the ItemGrader converts the answers entry into a tuple of dictionaries. When grading, it asks the specific grading class to grade the response against each possible answer, and selects the best outcome for the student. The wrong_msg is only displayed if the score is zero and there are no other messages. If no answers key is provided, the grader reads from the expect or answer parameter of the customresponse tag (see edX Syntax ). Note that when using a ListGrader , the answers key is required.","title":"Specifying Answers"},{"location":"item_grader/#option-listing","text":"Here is the full list of options specific to ItemGrader s. grader = ItemGrader ( answers = ( str , dict , ( str , dict )), wrong_msg = str , # default '' )","title":"Option Listing"},{"location":"plugins/","text":"Plugins # Plugins are an advanced feature of the library that allows users to construct their own custom-built graders, built on top of the infrastructure of the library. They can also be used to allow for straightforward code re-use, and to override library defaults on a course-wide basis. Any .py file stored in the mitxgraders/plugins folder will be automatically loaded. All variables in the __all__ list will be made available when doing from mitxgraders import * . See template.py for an example. You can define custom grading classes in your plugin. To learn how this works, we recommend copying the code from stringgrader.py , renaming the class, and building a simple plugin based on StringGrader . We are happy to include user-contributed plugins in the repository for this library. If you have built a plugin that you would like to see combined into this library, please contact the authors through github . We are also willing to consider incorporating good plugins into the library itself. Overriding Library Defaults # Library defaults for any grading class can be specified by constructing the desired dictionary of defaults, and calling register_defaults(dict) on the class. For example, to specify that all StringGrader s should be case-insensitive by default, you can do the following. StringGrader.register_defaults({ 'case_sensitive': False }) When this code is included in a file in the plugins folder, it automatically runs every time the library is loaded, leading to course-wide defaults. If for some reason you need to reset to the library defaults for a specific problem, you can call clear_registered_defaults() on the class in that problem. An example plugin has been provided for you in defaults_sample.py . The code in this plugin is commented out so that it doesn't change anything by default. If you are interested in overriding library defaults on a course-wide basis, we recommend copying this file to defaults.py and setting the desired defaults using the code templates provided. This is particularly useful if you wish to use attempt-based partial credit throughout your course. Inserting Plugins into the Library # To use a plugin, you will need to download the python_lib.zip file, unzip it, put the plugin in the plugins directory, and rezip everything. Your new zip file should unzip to have the mitxgraders and voluptuous directories.","title":"Plugins"},{"location":"plugins/#plugins","text":"Plugins are an advanced feature of the library that allows users to construct their own custom-built graders, built on top of the infrastructure of the library. They can also be used to allow for straightforward code re-use, and to override library defaults on a course-wide basis. Any .py file stored in the mitxgraders/plugins folder will be automatically loaded. All variables in the __all__ list will be made available when doing from mitxgraders import * . See template.py for an example. You can define custom grading classes in your plugin. To learn how this works, we recommend copying the code from stringgrader.py , renaming the class, and building a simple plugin based on StringGrader . We are happy to include user-contributed plugins in the repository for this library. If you have built a plugin that you would like to see combined into this library, please contact the authors through github . We are also willing to consider incorporating good plugins into the library itself.","title":"Plugins"},{"location":"plugins/#overriding-library-defaults","text":"Library defaults for any grading class can be specified by constructing the desired dictionary of defaults, and calling register_defaults(dict) on the class. For example, to specify that all StringGrader s should be case-insensitive by default, you can do the following. StringGrader.register_defaults({ 'case_sensitive': False }) When this code is included in a file in the plugins folder, it automatically runs every time the library is loaded, leading to course-wide defaults. If for some reason you need to reset to the library defaults for a specific problem, you can call clear_registered_defaults() on the class in that problem. An example plugin has been provided for you in defaults_sample.py . The code in this plugin is commented out so that it doesn't change anything by default. If you are interested in overriding library defaults on a course-wide basis, we recommend copying this file to defaults.py and setting the desired defaults using the code templates provided. This is particularly useful if you wish to use attempt-based partial credit throughout your course.","title":"Overriding Library Defaults"},{"location":"plugins/#inserting-plugins-into-the-library","text":"To use a plugin, you will need to download the python_lib.zip file, unzip it, put the plugin in the plugins directory, and rezip everything. Your new zip file should unzip to have the mitxgraders and voluptuous directories.","title":"Inserting Plugins into the Library"},{"location":"string_grader/","text":"StringGrader # The StringGrader class is an ItemGrader that grades text inputs. It can perform comparisons to expected answers or patterns, and can also accept arbitrary input. It is the simplest grading class, both in code and in usage. To use a StringGrader in its simplest form, simply pass in the set of answers you want to grade, as described in the ItemGrader documentation . >>> from mitxgraders import * >>> grader = StringGrader ( ... answers = 'cat' ... ) >>> grader ( None , 'cat' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'CAT' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True >>> grader ( None , 'Cat' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True This example will accept the answer of cat , but not CAT or Cat , as grading is case-sensitive by default. Cleaning Input # Leading or trailing spaces in an answer rarely change the meaning of the answer. Hence, by default, we strip all leading and trailing spaces from the student input and author-specified answers before comparison. If you want to keep those spaces around for the comparison, you need to disable strip. >>> grader = StringGrader ( ... answers = 'cat' , ... strip = False ... ) >>> grader ( None , 'cat' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , ' cat' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True This will accept cat , but will reject answers with leading or trailing spaces. By default, strip=True . Similarly, if a student uses two (or more) spaces instead of one, that rarely changes the meaning. By default, we convert consecutive spaces into a single space before comparison (this applies to both the instructor-provided answer and the student-provided response). If you want to disable this behavior, you can set clean_spaces=False as follows. >>> grader = StringGrader ( ... answers = 'two spaces' , ... clean_spaces = False ... ) >>> grader ( None , 'two spaces' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'two spaces' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True Here, the answer is two spaces , complete with two spaces (which may not render on a webpage). A student's answer of two spaces (with a single space) would be graded incorrect. Finally, you may have a situation where spaces are completely irrelevant (e.g., when grading a mathematical expression). To instruct the grader to completely ignore all spaces, set strip_all=True . >>> grader = StringGrader ( ... answers = '(12)(34)' , ... strip_all = True ... ) >>> grader ( None , '(1 2) (3 4)' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True This grader will accept (1 2) (3 4) , ignoring all spaces in the provided answer. Case Sensitive # To perform case-insensitive grading, pass in the appropriate flag as follows. >>> grader = StringGrader ( ... answers = 'Cat' , ... case_sensitive = False ... ) >>> grader ( None , 'Cat' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'cat' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'CAT' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True This will accept Cat , cat and CAT . By default, case_sensitive=True . Accepting Anything # Sometimes you may just want to accept anything that a student provides (possibly subject to conditions). This can be useful, for example, when asking for a free response to a prompt, and can be used in conjunction with validation (see below) to accept a variety of answers that satisfy a given pattern. To do this, set the accept_any flag, which will cause the grader to literally accept anything that is entered into the textbox. >>> grader = StringGrader ( ... answers = { 'expect' : '' , 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' }, ... accept_any = True ... ) >>> grader ( None , 'cat' ) == { 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' , 'ok' : True } True >>> grader ( None , 'dog' ) == { 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' , 'ok' : True } True >>> grader ( None , '' ) == { 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' , 'ok' : True } True Note that this will even accept a blank (empty) response. To reject empty responses, you can instead use the accept_nonempty flag, which requires at least one character to be submitted (after input cleaning). >>> grader = StringGrader ( ... answers = { 'expect' : '' , 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' }, ... accept_nonempty = True , ... explain_minimums = None ... ) >>> grader ( None , 'dog' ) == { 'grade_decimal' : 1 , ... 'msg' : 'Your answer has been recorded.' , ... 'ok' : True } True >>> grader ( None , '' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True Note that when either accept_any or accept_nonempty are set to True, you do not need to provide any answer to check against. You may want students to have to write a certain amount of characters or words in order to get credit. Two flags are available to facilitate this: min_length and min_words , which set a minimum number of characters and words to be awarded credit, respectively (both default to zero). You can use both of these options together if desired. >>> grader = StringGrader ( ... answers = { 'expect' : '' , 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' }, ... accept_any = True , ... min_length = 10 , # Require at least 10 characters (after cleaning input) ... min_words = 3 , # Require at least 3 words ... explain_minimums = 'msg' ... ) >>> grader ( None , 'This is a long answer' ) == { 'grade_decimal' : 1 , ... 'msg' : 'Your answer has been recorded.' , ... 'ok' : True } True >>> grader ( None , 'too short' ) == { 'grade_decimal' : 0 , ... 'msg' : 'Your response is too short (2/3 words)' , ... 'ok' : False } True >>> grader ( None , ' a b c d ' ) == { 'grade_decimal' : 0 , ... 'msg' : 'Your response is too short (7/10 characters)' , ... 'ok' : False } True Note that punctuation doesn't break a word for the purpose of word counting, so isn't word-counting fun? will only count as three words. If accept_nonempty and min_length are both used, the longer requirement is the one that is used. When a student's answer is rejected because it doesn't meet the minimum requirements, there are three types of feedback that you can provide, controlled by the explain_minimums flag: The student receives an error message describing how many words/characters they have, compared to how many are required. This does not consume an attempt ( explain_minimums='err' , default). The student is graded incorrect, but a message is provided describing how many words/characters they have, compared to how many are required. This consumes an attempt ( explain_minimums='msg' ). The student is graded incorrect, and no explanation is given. This consumes an attempt ( explain_minimums=None ). The settings min_length , min_words and explain_minimums are all ignored if not using accept_any or accept_nonempty . Validating Input # Sometimes, you may want to validate student input against a pattern. This can be useful if the student response simply needs to follow a given pattern, or if you want to reject student responses that don't conform to the required format. Validation can be used both when comparing against an expected response, or when using accept_any (and variants). Validation is performed by constructing a python regular expressions (regex) pattern, stored in the validation_pattern flag (if you are unfamiliar with regular expressions, there are many excellent tutorials available online to get you started!). After input cleaning, the student input is checked against the pattern for a match. If no match is found, the desired response is returned. Expected answers are also checked against the pattern; if a possible answer does not conform to the pattern, then a configuration error results. When a response doesn't satisfy the given pattern, there are three types of feedback that you can provide, controlled by the explain_validation flag: The student receives an error message. This does not consume an attempt ( explain_validation='err' , default). The student is graded incorrect, but receives a message. This consumes an attempt ( explain_validation='msg' ). The student is graded incorrect, and no explanation is given. This consumes an attempt ( explain_validation=None ). In the first two cases, the message provided is given by the invalid_msg setting, which defaults to Your input is not in the expected format . Here is an example of using a validation pattern to accept inputs that look like chemical formulae for organic molecules. Note that anything that matches the pattern will be graded correct. >>> grader = StringGrader ( ... validation_pattern = r '([CNOH](_[0-9])?)+' , ... explain_validation = 'msg' , ... invalid_msg = 'Write a chemical formula containing hydrogen, oxygen, carbon and/or nitrogen' , ... strip_all = True , # Removes all spaces from the input ... accept_any = True ... ) >>> grader ( None , 'NH_3' ) == { 'grade_decimal' : 1 , ... 'msg' : '' , ... 'ok' : True } True >>> grader ( None , 'KCl' ) == { 'grade_decimal' : 0 , ... 'msg' : 'Write a chemical formula containing hydrogen, oxygen, carbon and/or nitrogen' , ... 'ok' : False } True Below, we use validation to ensure that the student input matches the desired format before comparing to the answer, and give the student an error message if their input doesn't match the specification. >>> grader = StringGrader ( ... answers = '(1)(2)' , ... validation_pattern = r '\\([0-9]\\)\\([0-9]\\)' , ... explain_validation = 'err' , ... strip_all = True # Removes all spaces from the input ... ) >>> grader ( None , '(1)(2)' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , '(2)(1)' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True >>> try : ... grader ( None , '(a)(2)' ) ... except InvalidInput as error : ... print ( error ) Your input is not in the expected format >>> try : ... grader ( None , '[1)(2)' ) ... except InvalidInput as error : ... print ( error ) Your input is not in the expected format Option Listing # Here is the full list of options specific to a StringGrader . grader = StringGrader ( case_sensitive = bool , # default True strip = bool , # default True clean_spaces = bool , # default True strip_all = bool , # default False accept_any = bool , # default False accept_nonempty = bool , # default False min_words = int >= 0 , # default 0 min_length = int >= 0 , # default 0 explain_minimums = ( 'err' , 'msg' , None ), # default 'err' validation_pattern = str , # default None explain_validation = ( 'err' , 'msg' , None ), # default 'err' invalid_msg = str , # default 'Your input is not in the expected format' )","title":"StringGrader"},{"location":"string_grader/#stringgrader","text":"The StringGrader class is an ItemGrader that grades text inputs. It can perform comparisons to expected answers or patterns, and can also accept arbitrary input. It is the simplest grading class, both in code and in usage. To use a StringGrader in its simplest form, simply pass in the set of answers you want to grade, as described in the ItemGrader documentation . >>> from mitxgraders import * >>> grader = StringGrader ( ... answers = 'cat' ... ) >>> grader ( None , 'cat' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'CAT' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True >>> grader ( None , 'Cat' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True This example will accept the answer of cat , but not CAT or Cat , as grading is case-sensitive by default.","title":"StringGrader"},{"location":"string_grader/#cleaning-input","text":"Leading or trailing spaces in an answer rarely change the meaning of the answer. Hence, by default, we strip all leading and trailing spaces from the student input and author-specified answers before comparison. If you want to keep those spaces around for the comparison, you need to disable strip. >>> grader = StringGrader ( ... answers = 'cat' , ... strip = False ... ) >>> grader ( None , 'cat' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , ' cat' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True This will accept cat , but will reject answers with leading or trailing spaces. By default, strip=True . Similarly, if a student uses two (or more) spaces instead of one, that rarely changes the meaning. By default, we convert consecutive spaces into a single space before comparison (this applies to both the instructor-provided answer and the student-provided response). If you want to disable this behavior, you can set clean_spaces=False as follows. >>> grader = StringGrader ( ... answers = 'two spaces' , ... clean_spaces = False ... ) >>> grader ( None , 'two spaces' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'two spaces' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True Here, the answer is two spaces , complete with two spaces (which may not render on a webpage). A student's answer of two spaces (with a single space) would be graded incorrect. Finally, you may have a situation where spaces are completely irrelevant (e.g., when grading a mathematical expression). To instruct the grader to completely ignore all spaces, set strip_all=True . >>> grader = StringGrader ( ... answers = '(12)(34)' , ... strip_all = True ... ) >>> grader ( None , '(1 2) (3 4)' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True This grader will accept (1 2) (3 4) , ignoring all spaces in the provided answer.","title":"Cleaning Input"},{"location":"string_grader/#case-sensitive","text":"To perform case-insensitive grading, pass in the appropriate flag as follows. >>> grader = StringGrader ( ... answers = 'Cat' , ... case_sensitive = False ... ) >>> grader ( None , 'Cat' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'cat' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'CAT' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True This will accept Cat , cat and CAT . By default, case_sensitive=True .","title":"Case Sensitive"},{"location":"string_grader/#accepting-anything","text":"Sometimes you may just want to accept anything that a student provides (possibly subject to conditions). This can be useful, for example, when asking for a free response to a prompt, and can be used in conjunction with validation (see below) to accept a variety of answers that satisfy a given pattern. To do this, set the accept_any flag, which will cause the grader to literally accept anything that is entered into the textbox. >>> grader = StringGrader ( ... answers = { 'expect' : '' , 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' }, ... accept_any = True ... ) >>> grader ( None , 'cat' ) == { 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' , 'ok' : True } True >>> grader ( None , 'dog' ) == { 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' , 'ok' : True } True >>> grader ( None , '' ) == { 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' , 'ok' : True } True Note that this will even accept a blank (empty) response. To reject empty responses, you can instead use the accept_nonempty flag, which requires at least one character to be submitted (after input cleaning). >>> grader = StringGrader ( ... answers = { 'expect' : '' , 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' }, ... accept_nonempty = True , ... explain_minimums = None ... ) >>> grader ( None , 'dog' ) == { 'grade_decimal' : 1 , ... 'msg' : 'Your answer has been recorded.' , ... 'ok' : True } True >>> grader ( None , '' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True Note that when either accept_any or accept_nonempty are set to True, you do not need to provide any answer to check against. You may want students to have to write a certain amount of characters or words in order to get credit. Two flags are available to facilitate this: min_length and min_words , which set a minimum number of characters and words to be awarded credit, respectively (both default to zero). You can use both of these options together if desired. >>> grader = StringGrader ( ... answers = { 'expect' : '' , 'grade_decimal' : 1 , 'msg' : 'Your answer has been recorded.' }, ... accept_any = True , ... min_length = 10 , # Require at least 10 characters (after cleaning input) ... min_words = 3 , # Require at least 3 words ... explain_minimums = 'msg' ... ) >>> grader ( None , 'This is a long answer' ) == { 'grade_decimal' : 1 , ... 'msg' : 'Your answer has been recorded.' , ... 'ok' : True } True >>> grader ( None , 'too short' ) == { 'grade_decimal' : 0 , ... 'msg' : 'Your response is too short (2/3 words)' , ... 'ok' : False } True >>> grader ( None , ' a b c d ' ) == { 'grade_decimal' : 0 , ... 'msg' : 'Your response is too short (7/10 characters)' , ... 'ok' : False } True Note that punctuation doesn't break a word for the purpose of word counting, so isn't word-counting fun? will only count as three words. If accept_nonempty and min_length are both used, the longer requirement is the one that is used. When a student's answer is rejected because it doesn't meet the minimum requirements, there are three types of feedback that you can provide, controlled by the explain_minimums flag: The student receives an error message describing how many words/characters they have, compared to how many are required. This does not consume an attempt ( explain_minimums='err' , default). The student is graded incorrect, but a message is provided describing how many words/characters they have, compared to how many are required. This consumes an attempt ( explain_minimums='msg' ). The student is graded incorrect, and no explanation is given. This consumes an attempt ( explain_minimums=None ). The settings min_length , min_words and explain_minimums are all ignored if not using accept_any or accept_nonempty .","title":"Accepting Anything"},{"location":"string_grader/#validating-input","text":"Sometimes, you may want to validate student input against a pattern. This can be useful if the student response simply needs to follow a given pattern, or if you want to reject student responses that don't conform to the required format. Validation can be used both when comparing against an expected response, or when using accept_any (and variants). Validation is performed by constructing a python regular expressions (regex) pattern, stored in the validation_pattern flag (if you are unfamiliar with regular expressions, there are many excellent tutorials available online to get you started!). After input cleaning, the student input is checked against the pattern for a match. If no match is found, the desired response is returned. Expected answers are also checked against the pattern; if a possible answer does not conform to the pattern, then a configuration error results. When a response doesn't satisfy the given pattern, there are three types of feedback that you can provide, controlled by the explain_validation flag: The student receives an error message. This does not consume an attempt ( explain_validation='err' , default). The student is graded incorrect, but receives a message. This consumes an attempt ( explain_validation='msg' ). The student is graded incorrect, and no explanation is given. This consumes an attempt ( explain_validation=None ). In the first two cases, the message provided is given by the invalid_msg setting, which defaults to Your input is not in the expected format . Here is an example of using a validation pattern to accept inputs that look like chemical formulae for organic molecules. Note that anything that matches the pattern will be graded correct. >>> grader = StringGrader ( ... validation_pattern = r '([CNOH](_[0-9])?)+' , ... explain_validation = 'msg' , ... invalid_msg = 'Write a chemical formula containing hydrogen, oxygen, carbon and/or nitrogen' , ... strip_all = True , # Removes all spaces from the input ... accept_any = True ... ) >>> grader ( None , 'NH_3' ) == { 'grade_decimal' : 1 , ... 'msg' : '' , ... 'ok' : True } True >>> grader ( None , 'KCl' ) == { 'grade_decimal' : 0 , ... 'msg' : 'Write a chemical formula containing hydrogen, oxygen, carbon and/or nitrogen' , ... 'ok' : False } True Below, we use validation to ensure that the student input matches the desired format before comparing to the answer, and give the student an error message if their input doesn't match the specification. >>> grader = StringGrader ( ... answers = '(1)(2)' , ... validation_pattern = r '\\([0-9]\\)\\([0-9]\\)' , ... explain_validation = 'err' , ... strip_all = True # Removes all spaces from the input ... ) >>> grader ( None , '(1)(2)' ) == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> grader ( None , '(2)(1)' ) == { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False } True >>> try : ... grader ( None , '(a)(2)' ) ... except InvalidInput as error : ... print ( error ) Your input is not in the expected format >>> try : ... grader ( None , '[1)(2)' ) ... except InvalidInput as error : ... print ( error ) Your input is not in the expected format","title":"Validating Input"},{"location":"string_grader/#option-listing","text":"Here is the full list of options specific to a StringGrader . grader = StringGrader ( case_sensitive = bool , # default True strip = bool , # default True clean_spaces = bool , # default True strip_all = bool , # default False accept_any = bool , # default False accept_nonempty = bool , # default False min_words = int >= 0 , # default 0 min_length = int >= 0 , # default 0 explain_minimums = ( 'err' , 'msg' , None ), # default 'err' validation_pattern = str , # default None explain_validation = ( 'err' , 'msg' , None ), # default 'err' invalid_msg = str , # default 'Your input is not in the expected format' )","title":"Option Listing"},{"location":"grading_lists/list_grader/","text":"ListGrader # A ListGrader is used to grade a list of student inputs wherein each input is entered in a separate answer box. (In contrast, SingleListGrader can be used to grade a list of items entered all at once into a single answer box.) ListGrader s work by farming out individual items to subgraders, and then collecting the results and working out the optimal farming scheme for the student. Note that a ListGrader is not an ItemGrader , as it handles multiple inputs at once. Basic Usage # In this example, each input is checked against the corresponding answer, using StringGrader as the subgrader. >>> from mitxgraders import * >>> grader = ListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgraders = StringGrader () ... ) >>> grader ( None , [ 'cat' , 'dog' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True Answers are provided as a python list of individual ItemGrader answers (or a tuple of such lists). Note that the individual answers may take advantage of all of the usual ItemGrader flexibility, but ListGrader requires either a list, or a tuple of lists. Each element of answers is set as an answer that is passed as the answers key into the subgrader. This particular example should be set up as two input boxes that the student types in, as follows. <problem> <p> What are the most common pets? </p> <script type= \"text/python\" > from mitxgraders import * grader = ListGrader( answers=['cat', 'dog'], subgraders=StringGrader() ) </script> <customresponse cfn= \"grader\" inline= \"1\" > <p style= \"display:inline\" > First answer: </p><textline inline= \"1\" correct_answer= \"cat\" /> <br/> <p style= \"display:inline\" > Second answer: </p><textline inline= \"1\" correct_answer= \"dog\" /> </customresponse> </problem> In the above example, the item grader just sees single strings as the answer. The full versatility of the ItemGrader answer scheme is available though, such as in the following. >>> answer1 = ( ... { 'expect' : 'zebra' , 'grade_decimal' : 1 }, ... { 'expect' : 'horse' , 'grade_decimal' : 0.45 }, ... { 'expect' : 'unicorn' , 'grade_decimal' : 0 , 'msg' : 'Unicorn? Really?' } ... ) >>> answer2 = ( ... { 'expect' : 'cat' , 'grade_decimal' : 1 }, ... { 'expect' : 'feline' , 'grade_decimal' : 0.5 } ... ) >>> grader = ListGrader ( ... answers = [ answer1 , answer2 ], ... subgraders = StringGrader () ... ) >>> grader ( None , [ 'cat' , 'unicorn' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 0 , 'msg' : 'Unicorn? Really?' , 'ok' : False }] ... } True >>> grader ( None , [ 'zebra' , 'unicorn' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }] ... } True In this example, the grader will try assigning the first input to answer1 and the second to answer2, and computing the total score. Then it will repeat, with the inputs switched. The student will receive the highest grade. So, note that while cat and unicorn will get the unicorn message (and 1/2 points), zebra and unicorn will not (and also get 1/2 points). Partial Credit # By default, every input receives its own grade. You may instead choose that all inputs are graded as incorrect unless every input is 100% correct by setting partial_credit=False . This is not a forgiving option: a single entry with a grade_decimal value of 0.99 will cause all entries to be graded as wrong. >>> from mitxgraders import * >>> grader = ListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgraders = StringGrader (), ... partial_credit = False ... ) >>> grader ( None , [ 'cat' , 'unicorn' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }] ... } True We strongly recommend informing students that there will be no partial credit for questions that use this option, as otherwise there will be confusion when correct inputs receive red crosses. Ordered Input # By default, a ListGrader doesn't care what order the inputs are given in, so \"cat\" and \"dog\" is equivalent to \"dog\" and \"cat\". If you want the inputs to be ordered, simply set ordered=True . >>> grader = ListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgraders = StringGrader (), ... ordered = True ... ) >>> grader ( None , [ 'cat' , 'dog' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True >>> grader ( None , [ 'dog' , 'cat' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }] ... } True Now, \"cat\" and \"dog\" will receive full credit, but \"dog\" and \"cat\" will receive none. Multiple Graders # If you have inhomogeneous inputs, you can grade them using different graders. Simply give a list of subgraders, and the data will be passed into the graders in that order. Note that the length of answers must be the same as the number of subgraders in this case. Further note that you must set ordered=True when using a list of subgraders. >>> grader = ListGrader ( ... answers = [ 'cat' , 'x^2+1' ], ... subgraders = [ StringGrader (), FormulaGrader ( variables = [ \"x\" ])], ... ordered = True ... ) >>> grader ( None , [ 'cat' , 'x^2+1' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True If subgraders is given a single grader rather than a list, that grader is used for all inputs. SingleListGraders in ListGrader # Some questions will require nested list graders. Simple versions can make use of a SingleListGrader subgrader, as in the following example. Consider two input boxes, where the first should be a comma-separated list of even numbers beneath 5, and the second should be a comma-separated list of odd numbers beneath 5. The order of the boxes is important, but within each box, the order becomes unimportant. Here's how you can encode this type of problem. >>> grader = ListGrader ( ... answers = [ ... [ '2' , '4' ], ... [ '1' , '3' ] ... ], ... subgraders = SingleListGrader ( ... subgrader = NumericalGrader () ... ), ... ordered = True ... ) >>> grader ( None , [ '2, 4' , '3, 1' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True The nested SingleListGrader will be used to grade the first input box against an unordered answer of 2 and 4, and then the second input box against an unordered answer of 1 and 3. Grouped Inputs # If you find yourself wanting to nest ListGrader s, then you will need to specify how the inputs should be grouped together to be passed to the subgraders. A simple example would be to ask for the name and number of each animal in a picture. Each name/number group needs to be graded together. Here is an example of such a question. >>> grader = ListGrader ( ... answers = [ ... [ 'cat' , '1' ], ... [ 'dog' , '2' ], ... [ 'tiger' , '3' ] ... ], ... subgraders = ListGrader ( ... subgraders = [ StringGrader (), NumericalGrader ()], ... ordered = True ... ), ... grouping = [ 1 , 1 , 2 , 2 , 3 , 3 ] ... ) >>> grader ( None , [ 'cat' , '1' , 'tiger' , '4' , 'dog' , '2' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True In this case, the second level of grader is receiving multiple inputs, and so itself needs to be a ListGrader . The grouping key specifies which group each input belongs to. In this case, answers 1 and 2 will be combined into a list and fed to the subgrader as group 1, as will 3 and 4 as group 2, and 5 and 6 as group 3. The third level of grader ( StringGrader and NumericalGrader ) will then receive a list of two inputs, and each of the items in the answers. Because this is an unordered list, the ListGrader will find the optimal ordering of (animal, number) pairs. The grouping keys must be integers starting at 1 and increasing. If you have N groups, then all numbers from 1 to N must be present in the grouping, but they need not be in monotonic order. So for example, [1, 2, 1, 2] is a valid grouping. For unordered groups, the groupings must each have the same number of elements. Here is another example. In this case, we have ordered entry, so we can specify a list of subgraders. We have three items in the first grouping and one item in the second, so we use a ListGrader for the first grouping, and a StringGrader for the second. Note that the first entry in answers is a list that is passed directly into the ListGrader , while the second entry is just a string. This second-level ListGrader is unordered. >>> grader = ListGrader ( ... answers = [ ... [ 'bat' , 'ghost' , 'pumpkin' ], ... 'Halloween' ... ], ... subgraders = [ ... ListGrader ( ... subgraders = StringGrader () ... ), ... StringGrader () ... ], ... ordered = True , ... grouping = [ 1 , 1 , 1 , 2 ] ... ) >>> grader ( None , [ 'ghost' , 'pumpkin' , 'bat' , 'Halloween' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True Our last pair of examples are for a math class, where we have a matrix that has two eigenvalues, and each eigenvalue has a corresponding eigenvector. We start by grouping the eigenvalue and eigenvector boxes together, and then grade the groups in an unordered fashion. The eigenvectors are normalized, but have a sign ambiguity. A tuple contains both possible answers, and the grader will accept either of them. >>> grader = ListGrader ( ... answers = [ ... [ '1' , ([ '1' , '0' ], [ '-1' , '0' ])], ... [ '-1' , ([ '0' , '1' ], [ '0' , '-1' ])], ... ], ... subgraders = ListGrader ( ... subgraders = [ ... NumericalGrader (), ... SingleListGrader ( ... subgrader = NumericalGrader (), ... ordered = True ... ) ... ], ... ordered = True , ... partial_credit = False ... ), ... grouping = [ 1 , 1 , 2 , 2 ] ... ) >>> grader ( None , [ '1' , '1, 0' , '-1' , '1, 1' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }] ... } True This example has four input boxes, with the first and third being graded by a NumericalGrader , and the second and fourth being graded by a SingleListGrader . Note that we have set partial_credit=False on the nested ListGrader . This means that both the eigenvalue and eigenvector must be correct as a pair in order to get credit. However, as partial_credit is True for the highest level ListGrader , students can get credit for each pair of eigenvalues/eigenvectors individually. It is possible to specify a grouping on a nested ListGrader . The outer ListGrader must also have a grouping specified if doing so. Here is the same grader as above, where instead of taking the eigenvectors in a single input box list, there are four boxes to input each of the four vector components. >>> grader = ListGrader ( ... answers = [ ... [ '1' , ([ '1' , '0' ], [ '-1' , '0' ])], ... [ '-1' , ([ '0' , '1' ], [ '0' , '-1' ])], ... ], ... subgraders = ListGrader ( ... subgraders = [ ... NumericalGrader (), ... ListGrader ( ... subgraders = NumericalGrader (), ... ordered = True ... ) ... ], ... ordered = True , ... grouping = [ 1 , 2 , 2 ] ... ), ... grouping = [ 1 , 1 , 1 , 2 , 2 , 2 ] ... ) >>> grader ( None , [ '1' , '1' , '0' , '-1' , '1' , '1' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True In this example, partial credit is turned on everywhere, so only the one entry is graded as incorrect. While we recommend using a MatrixGrader instead of entering components in separate boxes like this, this example illustrates how nested ListGrader s work. Option Listing # Here is the full list of options specific to a ListGrader . grader = ListGrader ( answers = list , # default [] subgraders = ( ListGrader , ItemGrader , [ ListGrader , ItemGrader ]), partial_credit = bool , # default True ordered = bool , # default False grouping = list , # default [] )","title":"ListGrader"},{"location":"grading_lists/list_grader/#listgrader","text":"A ListGrader is used to grade a list of student inputs wherein each input is entered in a separate answer box. (In contrast, SingleListGrader can be used to grade a list of items entered all at once into a single answer box.) ListGrader s work by farming out individual items to subgraders, and then collecting the results and working out the optimal farming scheme for the student. Note that a ListGrader is not an ItemGrader , as it handles multiple inputs at once.","title":"ListGrader"},{"location":"grading_lists/list_grader/#basic-usage","text":"In this example, each input is checked against the corresponding answer, using StringGrader as the subgrader. >>> from mitxgraders import * >>> grader = ListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgraders = StringGrader () ... ) >>> grader ( None , [ 'cat' , 'dog' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True Answers are provided as a python list of individual ItemGrader answers (or a tuple of such lists). Note that the individual answers may take advantage of all of the usual ItemGrader flexibility, but ListGrader requires either a list, or a tuple of lists. Each element of answers is set as an answer that is passed as the answers key into the subgrader. This particular example should be set up as two input boxes that the student types in, as follows. <problem> <p> What are the most common pets? </p> <script type= \"text/python\" > from mitxgraders import * grader = ListGrader( answers=['cat', 'dog'], subgraders=StringGrader() ) </script> <customresponse cfn= \"grader\" inline= \"1\" > <p style= \"display:inline\" > First answer: </p><textline inline= \"1\" correct_answer= \"cat\" /> <br/> <p style= \"display:inline\" > Second answer: </p><textline inline= \"1\" correct_answer= \"dog\" /> </customresponse> </problem> In the above example, the item grader just sees single strings as the answer. The full versatility of the ItemGrader answer scheme is available though, such as in the following. >>> answer1 = ( ... { 'expect' : 'zebra' , 'grade_decimal' : 1 }, ... { 'expect' : 'horse' , 'grade_decimal' : 0.45 }, ... { 'expect' : 'unicorn' , 'grade_decimal' : 0 , 'msg' : 'Unicorn? Really?' } ... ) >>> answer2 = ( ... { 'expect' : 'cat' , 'grade_decimal' : 1 }, ... { 'expect' : 'feline' , 'grade_decimal' : 0.5 } ... ) >>> grader = ListGrader ( ... answers = [ answer1 , answer2 ], ... subgraders = StringGrader () ... ) >>> grader ( None , [ 'cat' , 'unicorn' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 0 , 'msg' : 'Unicorn? Really?' , 'ok' : False }] ... } True >>> grader ( None , [ 'zebra' , 'unicorn' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }] ... } True In this example, the grader will try assigning the first input to answer1 and the second to answer2, and computing the total score. Then it will repeat, with the inputs switched. The student will receive the highest grade. So, note that while cat and unicorn will get the unicorn message (and 1/2 points), zebra and unicorn will not (and also get 1/2 points).","title":"Basic Usage"},{"location":"grading_lists/list_grader/#partial-credit","text":"By default, every input receives its own grade. You may instead choose that all inputs are graded as incorrect unless every input is 100% correct by setting partial_credit=False . This is not a forgiving option: a single entry with a grade_decimal value of 0.99 will cause all entries to be graded as wrong. >>> from mitxgraders import * >>> grader = ListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgraders = StringGrader (), ... partial_credit = False ... ) >>> grader ( None , [ 'cat' , 'unicorn' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }] ... } True We strongly recommend informing students that there will be no partial credit for questions that use this option, as otherwise there will be confusion when correct inputs receive red crosses.","title":"Partial Credit"},{"location":"grading_lists/list_grader/#ordered-input","text":"By default, a ListGrader doesn't care what order the inputs are given in, so \"cat\" and \"dog\" is equivalent to \"dog\" and \"cat\". If you want the inputs to be ordered, simply set ordered=True . >>> grader = ListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgraders = StringGrader (), ... ordered = True ... ) >>> grader ( None , [ 'cat' , 'dog' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True >>> grader ( None , [ 'dog' , 'cat' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }] ... } True Now, \"cat\" and \"dog\" will receive full credit, but \"dog\" and \"cat\" will receive none.","title":"Ordered Input"},{"location":"grading_lists/list_grader/#multiple-graders","text":"If you have inhomogeneous inputs, you can grade them using different graders. Simply give a list of subgraders, and the data will be passed into the graders in that order. Note that the length of answers must be the same as the number of subgraders in this case. Further note that you must set ordered=True when using a list of subgraders. >>> grader = ListGrader ( ... answers = [ 'cat' , 'x^2+1' ], ... subgraders = [ StringGrader (), FormulaGrader ( variables = [ \"x\" ])], ... ordered = True ... ) >>> grader ( None , [ 'cat' , 'x^2+1' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True If subgraders is given a single grader rather than a list, that grader is used for all inputs.","title":"Multiple Graders"},{"location":"grading_lists/list_grader/#singlelistgraders-in-listgrader","text":"Some questions will require nested list graders. Simple versions can make use of a SingleListGrader subgrader, as in the following example. Consider two input boxes, where the first should be a comma-separated list of even numbers beneath 5, and the second should be a comma-separated list of odd numbers beneath 5. The order of the boxes is important, but within each box, the order becomes unimportant. Here's how you can encode this type of problem. >>> grader = ListGrader ( ... answers = [ ... [ '2' , '4' ], ... [ '1' , '3' ] ... ], ... subgraders = SingleListGrader ( ... subgrader = NumericalGrader () ... ), ... ordered = True ... ) >>> grader ( None , [ '2, 4' , '3, 1' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True The nested SingleListGrader will be used to grade the first input box against an unordered answer of 2 and 4, and then the second input box against an unordered answer of 1 and 3.","title":"SingleListGraders in ListGrader"},{"location":"grading_lists/list_grader/#grouped-inputs","text":"If you find yourself wanting to nest ListGrader s, then you will need to specify how the inputs should be grouped together to be passed to the subgraders. A simple example would be to ask for the name and number of each animal in a picture. Each name/number group needs to be graded together. Here is an example of such a question. >>> grader = ListGrader ( ... answers = [ ... [ 'cat' , '1' ], ... [ 'dog' , '2' ], ... [ 'tiger' , '3' ] ... ], ... subgraders = ListGrader ( ... subgraders = [ StringGrader (), NumericalGrader ()], ... ordered = True ... ), ... grouping = [ 1 , 1 , 2 , 2 , 3 , 3 ] ... ) >>> grader ( None , [ 'cat' , '1' , 'tiger' , '4' , 'dog' , '2' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True In this case, the second level of grader is receiving multiple inputs, and so itself needs to be a ListGrader . The grouping key specifies which group each input belongs to. In this case, answers 1 and 2 will be combined into a list and fed to the subgrader as group 1, as will 3 and 4 as group 2, and 5 and 6 as group 3. The third level of grader ( StringGrader and NumericalGrader ) will then receive a list of two inputs, and each of the items in the answers. Because this is an unordered list, the ListGrader will find the optimal ordering of (animal, number) pairs. The grouping keys must be integers starting at 1 and increasing. If you have N groups, then all numbers from 1 to N must be present in the grouping, but they need not be in monotonic order. So for example, [1, 2, 1, 2] is a valid grouping. For unordered groups, the groupings must each have the same number of elements. Here is another example. In this case, we have ordered entry, so we can specify a list of subgraders. We have three items in the first grouping and one item in the second, so we use a ListGrader for the first grouping, and a StringGrader for the second. Note that the first entry in answers is a list that is passed directly into the ListGrader , while the second entry is just a string. This second-level ListGrader is unordered. >>> grader = ListGrader ( ... answers = [ ... [ 'bat' , 'ghost' , 'pumpkin' ], ... 'Halloween' ... ], ... subgraders = [ ... ListGrader ( ... subgraders = StringGrader () ... ), ... StringGrader () ... ], ... ordered = True , ... grouping = [ 1 , 1 , 1 , 2 ] ... ) >>> grader ( None , [ 'ghost' , 'pumpkin' , 'bat' , 'Halloween' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True Our last pair of examples are for a math class, where we have a matrix that has two eigenvalues, and each eigenvalue has a corresponding eigenvector. We start by grouping the eigenvalue and eigenvector boxes together, and then grade the groups in an unordered fashion. The eigenvectors are normalized, but have a sign ambiguity. A tuple contains both possible answers, and the grader will accept either of them. >>> grader = ListGrader ( ... answers = [ ... [ '1' , ([ '1' , '0' ], [ '-1' , '0' ])], ... [ '-1' , ([ '0' , '1' ], [ '0' , '-1' ])], ... ], ... subgraders = ListGrader ( ... subgraders = [ ... NumericalGrader (), ... SingleListGrader ( ... subgrader = NumericalGrader (), ... ordered = True ... ) ... ], ... ordered = True , ... partial_credit = False ... ), ... grouping = [ 1 , 1 , 2 , 2 ] ... ) >>> grader ( None , [ '1' , '1, 0' , '-1' , '1, 1' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }] ... } True This example has four input boxes, with the first and third being graded by a NumericalGrader , and the second and fourth being graded by a SingleListGrader . Note that we have set partial_credit=False on the nested ListGrader . This means that both the eigenvalue and eigenvector must be correct as a pair in order to get credit. However, as partial_credit is True for the highest level ListGrader , students can get credit for each pair of eigenvalues/eigenvectors individually. It is possible to specify a grouping on a nested ListGrader . The outer ListGrader must also have a grouping specified if doing so. Here is the same grader as above, where instead of taking the eigenvectors in a single input box list, there are four boxes to input each of the four vector components. >>> grader = ListGrader ( ... answers = [ ... [ '1' , ([ '1' , '0' ], [ '-1' , '0' ])], ... [ '-1' , ([ '0' , '1' ], [ '0' , '-1' ])], ... ], ... subgraders = ListGrader ( ... subgraders = [ ... NumericalGrader (), ... ListGrader ( ... subgraders = NumericalGrader (), ... ordered = True ... ) ... ], ... ordered = True , ... grouping = [ 1 , 2 , 2 ] ... ), ... grouping = [ 1 , 1 , 1 , 2 , 2 , 2 ] ... ) >>> grader ( None , [ '1' , '1' , '0' , '-1' , '1' , '1' ]) == { 'overall_message' : '' , ... 'input_list' : [{ 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }, ... { 'grade_decimal' : 0 , 'msg' : '' , 'ok' : False }, ... { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True }] ... } True In this example, partial credit is turned on everywhere, so only the one entry is graded as incorrect. While we recommend using a MatrixGrader instead of entering components in separate boxes like this, this example illustrates how nested ListGrader s work.","title":"Grouped Inputs"},{"location":"grading_lists/list_grader/#option-listing","text":"Here is the full list of options specific to a ListGrader . grader = ListGrader ( answers = list , # default [] subgraders = ( ListGrader , ItemGrader , [ ListGrader , ItemGrader ]), partial_credit = bool , # default True ordered = bool , # default False grouping = list , # default [] )","title":"Option Listing"},{"location":"grading_lists/single_list_grader/","text":"SingleListGrader # If you want a response to be a delimiter-separated list of items, you can use a special ItemGrader called SingleListGrader to perform the grading. You need to specify a subgrader (which must be an ItemGrader , and could even be another SingleListGrader ) to evaluate each individual item. The basic usage is as follows. >>> from mitxgraders import * >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader () ... ) >>> grader ( None , 'cat, dog' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog, cat' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'cat, octopus' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True To receive full points for this problem, a student would enter cat, dog or dog, cat into the input box. Entering cat, octopus or just cat will receive half points. The answers key follows the usual ItemGrader specification, with one change: instead of specifying individual strings or dictionaries, you need to specify lists of strings or dictionaries. Otherwise, the full scope of ItemGrader configuration is available to you, such as using tuples to specify multiple lists of answers. >>> grader = SingleListGrader ( ... answers = ( ... [( 'cat' , 'feline' ), 'dog' ], ... [ 'goat' , 'vole' ], ... ), ... subgrader = StringGrader () ... ) >>> grader ( None , 'cat, dog' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog, feline' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'cat, vole' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True Now, cat, dog and goat, vole will get full grades. But mixes won't: cat, vole will score half credit, as cat and dog are in the same answer list, while vole belongs with goat . Below is an example that uses literally all possible answer input styles. >>> grader = SingleListGrader ( ... answers = ( ... [( 'cat' , { 'expect' : 'feline' , 'msg' : 'Good enough!' }), 'dog' ], ... { ... 'expect' : [ 'unicorn' , 'lumberjack' ], ... 'msg' : \"Well, you just had to do something strange, didn't you?\" , ... 'grade_decimal' : 0.5 ... }, ... ), ... subgrader = StringGrader () ... ) >>> grader ( None , 'feline, unicorn' ) == { 'grade_decimal' : 0.5 , 'msg' : 'Good enough!' , 'ok' : 'partial' } True >>> grader ( None , 'hippo, unicorn' ) == { 'grade_decimal' : 0.25 , 'msg' : '' , 'ok' : 'partial' } True >>> grader ( None , 'lumberjack, unicorn' ) == { 'grade_decimal' : 0.5 , 'msg' : \"Well, you just had to do something strange, didn't you?\" , 'ok' : 'partial' } True Note that the list of answers can itself occur inside a dictionary that has a grade and message associated with it. In this case, the answers are evaluated as normal, and the overall grade is multiplied by grade_decimal . The message is only shown if all of the inputs received credit. So, note that feline, anything will get the \"Good enough!\" message, while the \"something strange\" message only appears if the student enters both unicorn and lumberjack . As a convenience, you can also provide an answer that is just a string, corresponding to what students would enter. Beware that spaces included after delimiters will be included in the following entry. >>> from mitxgraders import * >>> grader = SingleListGrader ( ... answers = 'cat, dog' , ... subgrader = StringGrader () ... ) >>> grader ( None , 'cat, dog' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog, cat' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'cat, octopus' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True This means that SingleListGrader s are capable of inferring answers from the expect keyword of a customresponse tag. Messages # Messages from the individual items are all concatenated together and presented to the student. Overall messages associated with a list are included at the bottom. It is also possible to have a wrong_msg on the SingleListGrader , which is presented to the student if the score is zero and there are no other messages, just like on an ItemGrader . >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... wrong_msg = 'Try again!' ... ) >>> grader ( None , 'wolf, feline' ) == { 'grade_decimal' : 0.0 , 'msg' : 'Try again!' , 'ok' : False } True Ordered Input # By default, a SingleListGrader doesn't care which order the input is given in. If you want the answers and the student input to be compared in order, set ordered=True . >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... ordered = True ... ) >>> grader ( None , 'cat, dog' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog, cat' ) == { 'grade_decimal' : 0.0 , 'msg' : '' , 'ok' : False } True Now cat, dog will receive full grades, but dog, cat will be marked wrong. Note that cat will receive half credit, but dog will receive zero, as dog is incorrect in the first position. Ordered is False by default. Length Checking # If students are asked to enter a list of three items but only enter two, should this use up an attempt, or present an error message? If you want to present an error message, turn on length checking. >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... ) >>> grader ( None , 'cat, dog, unicorn' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... length_error = True ... ) >>> try : ... grader ( None , 'cat' ) ... except MissingInput as error : ... print ( error ) List length error: Expected 2 terms in the list, but received 1. Separate items with character \",\" If you give this cat , it will tell you that you've got the wrong length, and won't use up an attempt. By default, length_error is set to False . If you set length_error to True , then all answers in a tuple of lists (rather than a single answer list) must have the same length. Empty Entries # In order to protect students from typos, the grader returns an error if a student's response has an empty entry (or an entry that just contains spaces). If you want students to be able to enter a list with an empty entry, you need to disable this behavior by setting missing_error=False . >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader () ... ) >>> try : ... grader ( None , 'cat, dog,' ) ... except MissingInput as error : ... print ( error ) List error: Empty entry detected in position 3 >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... missing_error = False ... ) >>> grader ( None , 'cat, dog,' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True Choosing Delimiters # You can use whatever delimiter you like. The default is a comma ( , ). The following uses a semicolon as a delimiter. We recommend not using multi-character delimiters, but do not disallow it. >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... delimiter = ';' ... ) >>> grader ( None , 'cat; dog' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True By using different delimiters, it is possible to nest SingleListGrader s: >>> grader = SingleListGrader ( ... answers = [[ 'a' , 'b' ], [ 'c' , 'd' ]], ... subgrader = SingleListGrader ( ... subgrader = StringGrader () ... ), ... delimiter = ';' ... ) >>> grader ( None , 'd, c; a, b' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'a, c; d, b' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True Here the expected student input is a, b; c, d . It will also take b, a; d, c or c, d; a, b due to the unordered nature of both lists. However, a, c; d, b is only worth half points. Partial Credit # By default, partial credit is awarded to partially correct answers. Answers that have insufficient items lose points, as do answers that have too many items. To turn off partial credit, set partial_credit=False . It is True by default. >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... partial_credit = False ... ) >>> grader ( None , 'cat, octopus' ) == { 'grade_decimal' : 0.0 , 'msg' : '' , 'ok' : False } True Now cat, octopus will receive a grade of zero. Inferred Answers # Just as for normal ItemGrader s, the answers key can be inferred from the expect or answer parameter in a customresponse tag. Here is an example. <problem> <script type= \"text/python\" > from mitxgraders import * </script> <!-- Define the problem --> <customresponse cfn= \"SingleListGrader(subgrader=StringGrader())\" expect= \"a, b, c, d\" > <textline /> </customresponse> </problem> Here, the grader is a SingleListGrader using StringGrader as a subgrader, and uses default values for all other options. The answers key is missing, so it is inferred to be ['a', 'b', 'c', 'd'] from the expect parameter of the customresponse tag. Answer inference will even work with nested SingleListGrader s. Option Listing # Here is the full list of options specific to a SingleListGrader . grader = SingleListGrader ( answers = ( list , { 'expect' : list }, ( list , { 'expect' : list }, )), subgrader = ItemGrader (), partial_credit = bool , # default True ordered = bool , # default False length_error = bool , # default False missing_error = bool , # default True delimiter = str , # default ',' )","title":"SingleListGrader"},{"location":"grading_lists/single_list_grader/#singlelistgrader","text":"If you want a response to be a delimiter-separated list of items, you can use a special ItemGrader called SingleListGrader to perform the grading. You need to specify a subgrader (which must be an ItemGrader , and could even be another SingleListGrader ) to evaluate each individual item. The basic usage is as follows. >>> from mitxgraders import * >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader () ... ) >>> grader ( None , 'cat, dog' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog, cat' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'cat, octopus' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True To receive full points for this problem, a student would enter cat, dog or dog, cat into the input box. Entering cat, octopus or just cat will receive half points. The answers key follows the usual ItemGrader specification, with one change: instead of specifying individual strings or dictionaries, you need to specify lists of strings or dictionaries. Otherwise, the full scope of ItemGrader configuration is available to you, such as using tuples to specify multiple lists of answers. >>> grader = SingleListGrader ( ... answers = ( ... [( 'cat' , 'feline' ), 'dog' ], ... [ 'goat' , 'vole' ], ... ), ... subgrader = StringGrader () ... ) >>> grader ( None , 'cat, dog' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog, feline' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'cat, vole' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True Now, cat, dog and goat, vole will get full grades. But mixes won't: cat, vole will score half credit, as cat and dog are in the same answer list, while vole belongs with goat . Below is an example that uses literally all possible answer input styles. >>> grader = SingleListGrader ( ... answers = ( ... [( 'cat' , { 'expect' : 'feline' , 'msg' : 'Good enough!' }), 'dog' ], ... { ... 'expect' : [ 'unicorn' , 'lumberjack' ], ... 'msg' : \"Well, you just had to do something strange, didn't you?\" , ... 'grade_decimal' : 0.5 ... }, ... ), ... subgrader = StringGrader () ... ) >>> grader ( None , 'feline, unicorn' ) == { 'grade_decimal' : 0.5 , 'msg' : 'Good enough!' , 'ok' : 'partial' } True >>> grader ( None , 'hippo, unicorn' ) == { 'grade_decimal' : 0.25 , 'msg' : '' , 'ok' : 'partial' } True >>> grader ( None , 'lumberjack, unicorn' ) == { 'grade_decimal' : 0.5 , 'msg' : \"Well, you just had to do something strange, didn't you?\" , 'ok' : 'partial' } True Note that the list of answers can itself occur inside a dictionary that has a grade and message associated with it. In this case, the answers are evaluated as normal, and the overall grade is multiplied by grade_decimal . The message is only shown if all of the inputs received credit. So, note that feline, anything will get the \"Good enough!\" message, while the \"something strange\" message only appears if the student enters both unicorn and lumberjack . As a convenience, you can also provide an answer that is just a string, corresponding to what students would enter. Beware that spaces included after delimiters will be included in the following entry. >>> from mitxgraders import * >>> grader = SingleListGrader ( ... answers = 'cat, dog' , ... subgrader = StringGrader () ... ) >>> grader ( None , 'cat, dog' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog, cat' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'cat, octopus' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True This means that SingleListGrader s are capable of inferring answers from the expect keyword of a customresponse tag.","title":"SingleListGrader"},{"location":"grading_lists/single_list_grader/#messages","text":"Messages from the individual items are all concatenated together and presented to the student. Overall messages associated with a list are included at the bottom. It is also possible to have a wrong_msg on the SingleListGrader , which is presented to the student if the score is zero and there are no other messages, just like on an ItemGrader . >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... wrong_msg = 'Try again!' ... ) >>> grader ( None , 'wolf, feline' ) == { 'grade_decimal' : 0.0 , 'msg' : 'Try again!' , 'ok' : False } True","title":"Messages"},{"location":"grading_lists/single_list_grader/#ordered-input","text":"By default, a SingleListGrader doesn't care which order the input is given in. If you want the answers and the student input to be compared in order, set ordered=True . >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... ordered = True ... ) >>> grader ( None , 'cat, dog' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'dog, cat' ) == { 'grade_decimal' : 0.0 , 'msg' : '' , 'ok' : False } True Now cat, dog will receive full grades, but dog, cat will be marked wrong. Note that cat will receive half credit, but dog will receive zero, as dog is incorrect in the first position. Ordered is False by default.","title":"Ordered Input"},{"location":"grading_lists/single_list_grader/#length-checking","text":"If students are asked to enter a list of three items but only enter two, should this use up an attempt, or present an error message? If you want to present an error message, turn on length checking. >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... ) >>> grader ( None , 'cat, dog, unicorn' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... length_error = True ... ) >>> try : ... grader ( None , 'cat' ) ... except MissingInput as error : ... print ( error ) List length error: Expected 2 terms in the list, but received 1. Separate items with character \",\" If you give this cat , it will tell you that you've got the wrong length, and won't use up an attempt. By default, length_error is set to False . If you set length_error to True , then all answers in a tuple of lists (rather than a single answer list) must have the same length.","title":"Length Checking"},{"location":"grading_lists/single_list_grader/#empty-entries","text":"In order to protect students from typos, the grader returns an error if a student's response has an empty entry (or an entry that just contains spaces). If you want students to be able to enter a list with an empty entry, you need to disable this behavior by setting missing_error=False . >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader () ... ) >>> try : ... grader ( None , 'cat, dog,' ) ... except MissingInput as error : ... print ( error ) List error: Empty entry detected in position 3 >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... missing_error = False ... ) >>> grader ( None , 'cat, dog,' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True","title":"Empty Entries"},{"location":"grading_lists/single_list_grader/#choosing-delimiters","text":"You can use whatever delimiter you like. The default is a comma ( , ). The following uses a semicolon as a delimiter. We recommend not using multi-character delimiters, but do not disallow it. >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... delimiter = ';' ... ) >>> grader ( None , 'cat; dog' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True By using different delimiters, it is possible to nest SingleListGrader s: >>> grader = SingleListGrader ( ... answers = [[ 'a' , 'b' ], [ 'c' , 'd' ]], ... subgrader = SingleListGrader ( ... subgrader = StringGrader () ... ), ... delimiter = ';' ... ) >>> grader ( None , 'd, c; a, b' ) == { 'grade_decimal' : 1.0 , 'msg' : '' , 'ok' : True } True >>> grader ( None , 'a, c; d, b' ) == { 'grade_decimal' : 0.5 , 'msg' : '' , 'ok' : 'partial' } True Here the expected student input is a, b; c, d . It will also take b, a; d, c or c, d; a, b due to the unordered nature of both lists. However, a, c; d, b is only worth half points.","title":"Choosing Delimiters"},{"location":"grading_lists/single_list_grader/#partial-credit","text":"By default, partial credit is awarded to partially correct answers. Answers that have insufficient items lose points, as do answers that have too many items. To turn off partial credit, set partial_credit=False . It is True by default. >>> grader = SingleListGrader ( ... answers = [ 'cat' , 'dog' ], ... subgrader = StringGrader (), ... partial_credit = False ... ) >>> grader ( None , 'cat, octopus' ) == { 'grade_decimal' : 0.0 , 'msg' : '' , 'ok' : False } True Now cat, octopus will receive a grade of zero.","title":"Partial Credit"},{"location":"grading_lists/single_list_grader/#inferred-answers","text":"Just as for normal ItemGrader s, the answers key can be inferred from the expect or answer parameter in a customresponse tag. Here is an example. <problem> <script type= \"text/python\" > from mitxgraders import * </script> <!-- Define the problem --> <customresponse cfn= \"SingleListGrader(subgrader=StringGrader())\" expect= \"a, b, c, d\" > <textline /> </customresponse> </problem> Here, the grader is a SingleListGrader using StringGrader as a subgrader, and uses default values for all other options. The answers key is missing, so it is inferred to be ['a', 'b', 'c', 'd'] from the expect parameter of the customresponse tag. Answer inference will even work with nested SingleListGrader s.","title":"Inferred Answers"},{"location":"grading_lists/single_list_grader/#option-listing","text":"Here is the full list of options specific to a SingleListGrader . grader = SingleListGrader ( answers = ( list , { 'expect' : list }, ( list , { 'expect' : list }, )), subgrader = ItemGrader (), partial_credit = bool , # default True ordered = bool , # default False length_error = bool , # default False missing_error = bool , # default True delimiter = str , # default ',' )","title":"Option Listing"},{"location":"grading_math/comparer_functions/","text":"Comparer Functions # By default, FormulaGrader , NumericalGrader , and MatrixGrader compare the numerically-sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. Functions that perform the actual comparison are called \"comparers\", and there are a few ways to invoke them. Employing Comparer Functions # When an answer is passed into FormulaGrader , NumericalGrader or MatrixGrader , it is automatically paired up with a comparer. For example, the default comparer is equality_comparer . When you construct a grader like the following, >>> from mitxgraders import * >>> grader1 = FormulaGrader ( ... answers = 'a+b' , ... variables = [ 'a' , 'b' ] ... ) FormulaGrader automatically converts the answers key to the following: >>> grader2 = FormulaGrader ( ... answers = { ... 'expect' : { 'comparer' : equality_comparer , 'comparer_params' : [ 'a+b' ]}, ... 'grade_decimal' : 1 , ... 'msg' : '' ... }, ... variables = [ 'a' , 'b' ] ... ) >>> grader1 == grader2 True To specify an alternate comparer, you can simply change the relevant answer to a dictionary {'comparer': comparer_func, 'comparer_params': [list, of, params]} . Different comparers use comparer_params in different ways. For example, if grading angles in degrees, it may be useful to compare formulas modulo 2\u03c0. You can write your own comparer functions, but for this we can use the pre-built congruent_modulo comparer. This grader will accept any input congruent to 'b^2/a' modulo 2*pi . >>> grader = FormulaGrader ( ... answers = { ... 'comparer' : congruence_comparer , ... # first parameter is expected value, second is the modulus ... 'comparer_params' : [ 'b^2/a' , '2*pi' ] ... }, ... variables = [ 'a' , 'b' ] ... ) >>> grader ( None , 'b^2/a + 6*pi' )[ 'ok' ] True >>> grader ( None , 'b^2/a + 5.5*pi' )[ 'ok' ] False Here, the comparer_params ( ['b^2/a', '2*pi'] ) are evaluated just like the student input, and used by the comparer function during grading. Changing Defaults # The default comparer function for each of FormulaGrader , NumericalGrader and MatrixGrader can be set by calling set_default_comparer as follows: >>> FormulaGrader . set_default_comparer ( LinearComparer ()) This sets the default comparer to LinearComparer() (see below) for all FormulaGrader s in the given problem. Comparers set in this manner must only take a single comparer parameter. Using this default set approach is typically simpler than setting comparers explicitly, and allows answers to be inferred from expect values. However, comparers that require two or more comparer_params cannot use this method. If for some reason you need to reset the default comparer, you can use >>> FormulaGrader . reset_default_comparer () which is equivalent to setting the default comparer to equality_comparer . Available Comparers # The table below lists the pre-built comparers along with the expected comparer parameters. Note that comparer_params is always a list of strings, and can use any variables available to the student. When using an ordered ListGrader , they can also use sibling values. comparer use with comparer_params (a list of strings) purpose equality_comparer FormulaGrader NumericalGrader MatrixGrader [expected] checks that student input and expected differ by less than grader's tolerance. congruence_comparer FormulaGrader NumericalGrader [expected, modulus] reduces student input modulo modulus, then checks for equality within grader's tolerance. between_comparer FormulaGrader NumericalGrader [start, stop] checks that student input is real and between start and stop . eigenvector_comparer MatrixGrader [matrix, eigenvalue] checks that student input is an eigenvector of matrix with eigenvalue eigenvalue within grader's tolerance. vector_phase_comparer MatrixGrader [comparison_vector] checks that student input is equal to comparison_vector up to a phase, within grader's tolerance. vector_span_comparer MatrixGrader [vector1, vector2, ...] checks that student input is nonzero and in the span of the given list of vectors, within grader's tolerance. If only a single vector is given, checks if the student input is equal to the given vector up to a (possibly complex) constant of proportionality. All of these comparers (as well as the ones below) are available when using from mitxgraders import * . Special Comparers # There are three special built-in comparer classes that can be used as comparers that take in a single input. EqualityComparer # The EqualityComparer class simply checks for equality up to tolerance. In fact, equality_comparer = EqualityComparer() . The reason this class exists, however, is to allow for an extra option to be used when desired. The transform option allows the author to specify a transforming function to be called on both the answer and the student input prior to comparison. Here is an example: >>> import numpy as np >>> comparer = EqualityComparer ( transform = np . real ) This comparer will take the real part of the answer and the student input before comparing the results. This is useful if only the real part of the answers need to agree. LinearComparer # The LinearComparer checks if the student's answer is linearly related to the problem's answer, and can provide partial credit as appropriate. Here are all of the options: comparer = LinearComparer ( equals = float , # default 1 proportional = ( None | float ), # default 0.5 offset = ( None | float ), # default None linear = ( None | float ), # default None equals_msg = ( None | str ), # default None proportional_msg = ( None | str ), # default 'The submitted answer differs from an expected answer by a constant factor.' offset_msg = ( None | str ), # default None linear_msg = ( None | str ), # default None ) The first four settings specify how much credit to award the different situations, while the next four describe a message to display when that credit is awarded. Note that setting credit to None means that that type of credit will never be awarded, while setting credit to 0 means that it can be awarded (usually to display the relevant message). When the grading is performed, the largest credit of the available settings is awarded. Here is an example of a LinearComparer that can be used to award partial credit if students are off from the answer by a constant multiple. >>> comparer = LinearComparer () Easy, isn't it? You can combine this with set_default_comparer to enable partial credit of this sort with one line in each problem! Here is an example of setting up a LinearComparer that doesn't care about shift offsets (useful when describing indefinite integration). >>> comparer = LinearComparer ( proportional = None , linear = 1 ) Note that LinearComparer can only perform meaningful comparisons when random variables are used. If the answer is a numerical constant, then student answers will always be proportional to that constant, which probably isn't the desired behavior. Also note that when the answer is zero or the student supplies zero as their answer, partial credit cannot be assigned. MatrixEntryComparer # This comparer is used only for MatrixGrader s. It has a transform option that is exactly equivalent to EqualityComparer , but it also has two options related to partial credit. comparer = MatrixEntryComparer ( transform = ( None | func ), # default None entry_partial_credit = ( 'proportional' | float ), # default 0 entry_partial_msg = str , # default \"Some array entries are incorrect, marked below:\\n{error_locations}\" ) When entry_partial_credit is set to a number, if at least one entry in the array is correct (but not all of them), that amount of credit is assigned. When partial credit is assigned, the message entry_partial_msg is displayed to the student, with the text {error_locations} replaced by a graphic displaying which entries are correct/incorrect. To turn off the message, simply set entry_partial_msg='' . Setting entry_partial_msg='' and entry_partial_credit=0 makes this grader equivalent to EqualityComparer . Because this ability to assign partial credit to array input is so useful, MatrixEntryComparer can be set as the grader for MatrixGrader s using configuration options. Custom Comparer Functions # In addition to using the built-in comparers, you can write your own. See comparers.py for documentation and examples.","title":"Comparer Functions"},{"location":"grading_math/comparer_functions/#comparer-functions","text":"By default, FormulaGrader , NumericalGrader , and MatrixGrader compare the numerically-sampled author formula and student formula for equality (within bounds specified by tolerance). Occasionally, it can be useful to compare author and student formulas in some other way. Functions that perform the actual comparison are called \"comparers\", and there are a few ways to invoke them.","title":"Comparer Functions"},{"location":"grading_math/comparer_functions/#employing-comparer-functions","text":"When an answer is passed into FormulaGrader , NumericalGrader or MatrixGrader , it is automatically paired up with a comparer. For example, the default comparer is equality_comparer . When you construct a grader like the following, >>> from mitxgraders import * >>> grader1 = FormulaGrader ( ... answers = 'a+b' , ... variables = [ 'a' , 'b' ] ... ) FormulaGrader automatically converts the answers key to the following: >>> grader2 = FormulaGrader ( ... answers = { ... 'expect' : { 'comparer' : equality_comparer , 'comparer_params' : [ 'a+b' ]}, ... 'grade_decimal' : 1 , ... 'msg' : '' ... }, ... variables = [ 'a' , 'b' ] ... ) >>> grader1 == grader2 True To specify an alternate comparer, you can simply change the relevant answer to a dictionary {'comparer': comparer_func, 'comparer_params': [list, of, params]} . Different comparers use comparer_params in different ways. For example, if grading angles in degrees, it may be useful to compare formulas modulo 2\u03c0. You can write your own comparer functions, but for this we can use the pre-built congruent_modulo comparer. This grader will accept any input congruent to 'b^2/a' modulo 2*pi . >>> grader = FormulaGrader ( ... answers = { ... 'comparer' : congruence_comparer , ... # first parameter is expected value, second is the modulus ... 'comparer_params' : [ 'b^2/a' , '2*pi' ] ... }, ... variables = [ 'a' , 'b' ] ... ) >>> grader ( None , 'b^2/a + 6*pi' )[ 'ok' ] True >>> grader ( None , 'b^2/a + 5.5*pi' )[ 'ok' ] False Here, the comparer_params ( ['b^2/a', '2*pi'] ) are evaluated just like the student input, and used by the comparer function during grading.","title":"Employing Comparer Functions"},{"location":"grading_math/comparer_functions/#changing-defaults","text":"The default comparer function for each of FormulaGrader , NumericalGrader and MatrixGrader can be set by calling set_default_comparer as follows: >>> FormulaGrader . set_default_comparer ( LinearComparer ()) This sets the default comparer to LinearComparer() (see below) for all FormulaGrader s in the given problem. Comparers set in this manner must only take a single comparer parameter. Using this default set approach is typically simpler than setting comparers explicitly, and allows answers to be inferred from expect values. However, comparers that require two or more comparer_params cannot use this method. If for some reason you need to reset the default comparer, you can use >>> FormulaGrader . reset_default_comparer () which is equivalent to setting the default comparer to equality_comparer .","title":"Changing Defaults"},{"location":"grading_math/comparer_functions/#available-comparers","text":"The table below lists the pre-built comparers along with the expected comparer parameters. Note that comparer_params is always a list of strings, and can use any variables available to the student. When using an ordered ListGrader , they can also use sibling values. comparer use with comparer_params (a list of strings) purpose equality_comparer FormulaGrader NumericalGrader MatrixGrader [expected] checks that student input and expected differ by less than grader's tolerance. congruence_comparer FormulaGrader NumericalGrader [expected, modulus] reduces student input modulo modulus, then checks for equality within grader's tolerance. between_comparer FormulaGrader NumericalGrader [start, stop] checks that student input is real and between start and stop . eigenvector_comparer MatrixGrader [matrix, eigenvalue] checks that student input is an eigenvector of matrix with eigenvalue eigenvalue within grader's tolerance. vector_phase_comparer MatrixGrader [comparison_vector] checks that student input is equal to comparison_vector up to a phase, within grader's tolerance. vector_span_comparer MatrixGrader [vector1, vector2, ...] checks that student input is nonzero and in the span of the given list of vectors, within grader's tolerance. If only a single vector is given, checks if the student input is equal to the given vector up to a (possibly complex) constant of proportionality. All of these comparers (as well as the ones below) are available when using from mitxgraders import * .","title":"Available Comparers"},{"location":"grading_math/comparer_functions/#special-comparers","text":"There are three special built-in comparer classes that can be used as comparers that take in a single input.","title":"Special Comparers"},{"location":"grading_math/comparer_functions/#equalitycomparer","text":"The EqualityComparer class simply checks for equality up to tolerance. In fact, equality_comparer = EqualityComparer() . The reason this class exists, however, is to allow for an extra option to be used when desired. The transform option allows the author to specify a transforming function to be called on both the answer and the student input prior to comparison. Here is an example: >>> import numpy as np >>> comparer = EqualityComparer ( transform = np . real ) This comparer will take the real part of the answer and the student input before comparing the results. This is useful if only the real part of the answers need to agree.","title":"EqualityComparer"},{"location":"grading_math/comparer_functions/#linearcomparer","text":"The LinearComparer checks if the student's answer is linearly related to the problem's answer, and can provide partial credit as appropriate. Here are all of the options: comparer = LinearComparer ( equals = float , # default 1 proportional = ( None | float ), # default 0.5 offset = ( None | float ), # default None linear = ( None | float ), # default None equals_msg = ( None | str ), # default None proportional_msg = ( None | str ), # default 'The submitted answer differs from an expected answer by a constant factor.' offset_msg = ( None | str ), # default None linear_msg = ( None | str ), # default None ) The first four settings specify how much credit to award the different situations, while the next four describe a message to display when that credit is awarded. Note that setting credit to None means that that type of credit will never be awarded, while setting credit to 0 means that it can be awarded (usually to display the relevant message). When the grading is performed, the largest credit of the available settings is awarded. Here is an example of a LinearComparer that can be used to award partial credit if students are off from the answer by a constant multiple. >>> comparer = LinearComparer () Easy, isn't it? You can combine this with set_default_comparer to enable partial credit of this sort with one line in each problem! Here is an example of setting up a LinearComparer that doesn't care about shift offsets (useful when describing indefinite integration). >>> comparer = LinearComparer ( proportional = None , linear = 1 ) Note that LinearComparer can only perform meaningful comparisons when random variables are used. If the answer is a numerical constant, then student answers will always be proportional to that constant, which probably isn't the desired behavior. Also note that when the answer is zero or the student supplies zero as their answer, partial credit cannot be assigned.","title":"LinearComparer"},{"location":"grading_math/comparer_functions/#matrixentrycomparer","text":"This comparer is used only for MatrixGrader s. It has a transform option that is exactly equivalent to EqualityComparer , but it also has two options related to partial credit. comparer = MatrixEntryComparer ( transform = ( None | func ), # default None entry_partial_credit = ( 'proportional' | float ), # default 0 entry_partial_msg = str , # default \"Some array entries are incorrect, marked below:\\n{error_locations}\" ) When entry_partial_credit is set to a number, if at least one entry in the array is correct (but not all of them), that amount of credit is assigned. When partial credit is assigned, the message entry_partial_msg is displayed to the student, with the text {error_locations} replaced by a graphic displaying which entries are correct/incorrect. To turn off the message, simply set entry_partial_msg='' . Setting entry_partial_msg='' and entry_partial_credit=0 makes this grader equivalent to EqualityComparer . Because this ability to assign partial credit to array input is so useful, MatrixEntryComparer can be set as the grader for MatrixGrader s using configuration options.","title":"MatrixEntryComparer"},{"location":"grading_math/comparer_functions/#custom-comparer-functions","text":"In addition to using the built-in comparers, you can write your own. See comparers.py for documentation and examples.","title":"Custom Comparer Functions"},{"location":"grading_math/formula_grader/","text":"FormulaGrader # FormulaGrader is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's <formularesponse /> tag, but with much more versatility. Note All expressions are treated in a case sensitive manner. This means that variables m and M are distinct. Case-insensitive FormulaGrader s were deprecated in Version 1.1.0 All whitespace is stripped from formulas that are entered. So, 1 + x ^ 2 is equivalent to 1+x^2 . Variables and Sampling # FormulaGrader grades a formula by numerical sampling. That is, random values are assigned to each of the unknown variables and unknown functions, and the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct. Variables are configured by including a list of strings of each variable name as follows. >>> from mitxgraders import * >>> grader = FormulaGrader ( ... answers = '1+x^2+y' , ... variables = [ 'x' , 'y' ] ... ) Note that the answers parameter follows all of the usual allowances from ItemGrader . The variables need to have numbers randomly assigned to them. Each is sampled from a sampling set , which is RealInterval() by default (random numbers between 1 and 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the sample_from key. >>> grader = FormulaGrader ( ... answers = '1+x^2+y+z/2' , ... variables = [ 'x' , 'y' , 'z' ], ... sample_from = { ... 'x' : ComplexRectangle (), ... 'y' : [ 2 , 6 ], ... 'z' : ( 1 , 3 , 4 , 8 ) ... } ... ) The sample_from key must be a dictionary of 'variable_name': sampling_set pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order. Variable Names # Variable names are case-sensitive. They must start with a letter, and can be proceded by any combination of letters and numbers. There are two ways to write subscripts and superscripts: Old edX style: var_123 (we also allow the use of multiple underscores for backwards compatability with edX, although it is not recommended that this be used) Tensor style: var_{123} , var_{123}^{456} (subscript first), or var^{456} Sub/superscripts can contain any combination of letters and numbers. Tensor style sub/superscripts are allowed to start with a - sign. All types of variable names are allowed to end with an arbitrary number of primes ' (apostrophes, useful to indicate differentiation or different reference frames). Students on tablets may need to disable \"smart quotes\" to enter this character. The AsciiMath renderer used in <textline> entries in edX has a number of special symbols that can help make variable names look like particular mathematical entries. A handful of these are hatx , vecx , tildex , barx , dotx and ddotx . There are also a handful of other reserved names in AsciiMath; we recommend testing your variables to ensure that they render as expected. Numbered Variables # You can also specify special variables that are numbered. For example, if you specify that a is a numbered variable, students can include a_{0} , a_{5} , a_{-2} , etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name. >>> grader = FormulaGrader ( ... answers = 'a_ {0} + a_ {1} *x + 1/2*a_ {2} *x^2' , ... variables = [ 'x' ], ... numbered_vars = [ 'a' ], ... sample_from = { ... 'x' : [ - 5 , 5 ], ... 'a' : [ - 10 , 10 ] ... } ... ) If you have a variable name that would clash with a numbered variable (say, you defined a_{0} and also a numbered variable a ), then the specific variable has precedence. Samples and Failable Evaluations # To control the number of samples that are checked to ensure correctness, you can modify the samples key. >>> grader = FormulaGrader ( ... answers = '1+x^2' , ... variables = [ 'x' ], ... samples = 10 ... ) The default for samples is 5. You may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set failable_evals . This should be used very sparingly! >>> grader = FormulaGrader ( ... answers = '1+x^2' , ... variables = [ 'x' ], ... samples = 10 , ... failable_evals = 1 ... ) Constants # By default, four constants are defined: e , pi , and i=j=sqrt(-1) . You can define new constants by passing in a dictionary to user_constants as follows. >>> grader = FormulaGrader ( ... answers = '1/sqrt(1-v^2/c^2)' , ... variables = [ 'v' ], ... user_constants = { ... 'c' : 3e8 ... } ... ) Constants are treated as variables that only ever have one value. If you want to remove a default constant, you can do so by setting it to None : >>> grader = FormulaGrader ( ... answers = 'sqrt(-1)' , ... user_constants = { ... 'i' : None , ... 'j' : None ... } ... ) Infinities # When an expression results in an infinity, students are presented with an error message asking them to check for overflow. If you actually want infinity to be an acceptable answer, then you can specify allow_inf=True . This allows expressions to evaluate to infinity (or negative infinity), and also makes the constant infty available for students to use. >>> # Without allow_inf turned on: >>> grader = FormulaGrader ( ... answers = 'infty' , ... user_constants = { ... 'infty' : float ( 'inf' ) ... } ... ) >>> try : ... grader ( None , 'infty' ) ... except CalcError as error : ... print ( error ) Numerical overflow occurred. Does your expression generate very large numbers? >>> # With allow_inf turned on: >>> grader = FormulaGrader ( ... answers = 'infty' , ... allow_inf = True ... ) >>> grader ( None , 'infty' ) == { 'ok' : True , 'msg' : '' , 'grade_decimal' : 1 } True Functions # By default, a large array of mathematical functions are available for use. See the full list here . Note that all functions are capable of handling complex expressions unless otherwise stated. In the following example, z*z is recognized to be different from abs(z)^2 . >>> grader = FormulaGrader ( ... answers = 'abs(z)^2' , ... variables = [ 'z' ], ... sample_from = { ... 'z' : ComplexRectangle () ... } ... ) >>> grader ( None , 'z*z' )[ 'ok' ] False >>> grader ( None , 'z*conj(z)' )[ 'ok' ] True User Functions # You can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the user_functions key as follows. >>> grader = FormulaGrader ( ... answers = 'x*x' , ... variables = [ 'x' ], ... user_functions = { 'f' : lambda x : x * x } ... ) This defines a function f(x) = x^2 that students may use. User-defined function names must start with a letter, and can use numbers and underscores, such as my_func2 . They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg, f'' . Be careful about using quotation marks appropriately when using primes in function names, as in the following example. >>> grader = FormulaGrader ( ... answers = \"f''(x)\" , ... variables = [ 'x' ], ... user_functions = { \"f''\" : lambda x : x * x } ... ) Choosing a Function Randomly # You can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows. >>> import numpy as np >>> grader = FormulaGrader ( ... answers = \"f(x)\" , ... variables = [ 'x' ], ... user_functions = { \"f\" : [ np . sin , np . cos ]} ... ) Each time this formula is checked, the function f will be sampled from the list of available functions. You can also specify a random well-behaved function by using the RandomFunction() sampling set. >>> grader = FormulaGrader ( ... answers = \"f''(x) + omega^2*f(x)\" , ... variables = [ 'x' , 'omega' ], ... user_functions = { ... \"f\" : RandomFunction (), ... \"f''\" : RandomFunction () ... } ... ) This allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example. See Sampling for further options associated with RandomFunction . Overriding Default Functions and Constants # You can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with suppress_warnings=True . The following grader raises this warning when constructed: >>> try : ... grader = FormulaGrader ( ... answers = 'x^2' , ... variables = [ 'x' ], ... user_functions = { 'sin' : lambda x : x * x }, ... ) ... except ConfigError as error : ... print ( error ) Warning: 'user_functions' contains entries 'sin' which will override default values. If you intend to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration. The error can be suppressed by setting suppress_warnings=True . >>> grader = FormulaGrader ( ... answers = 'x^2' , ... variables = [ 'x' ], ... user_functions = { 'sin' : lambda x : x * x }, ... suppress_warnings = True ... ) Restricting Student Input # For some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand sin(2*theta) , then you don't want students to be able to just write sin(2*theta) and be graded correct. FormulaGrader offers a number of ways to restrict what sort of answers will be marked correct. Instructor Variables # In some situations, you need an extra variable to help define the problem in some way, particularly when using DependentSampler . Alternatively, you may want to remove a default constant such as e , i , j or pi from the problem. Both of these situations can be addressed by specifying particular variables to be instructor variables, as in the following. >>> grader = FormulaGrader ( ... answers = 's/c' , ... variables = [ 's' , 'c' , 'phi' ], ... sample_from = { ... 's' : DependentSampler ( depends = [ 'phi' ], formula = 'sin(phi)' ), ... 'c' : DependentSampler ( depends = [ 'phi' ], formula = 'cos(phi)' ) ... }, ... instructor_vars = [ 'phi' ] ... ) Here, students can use s and c , but not phi in their answer. The instructor_vars key accepts a list of the variables/constants you wish to make unavailable to students. Forbidden Strings # You can forbid students from entering certain strings using the forbidden_strings key: >>> grader = FormulaGrader ( ... answers = '2*sin(theta)*cos(theta)' , ... variables = [ 'theta' ], ... forbidden_strings = [ '*theta' , 'theta*' , 'theta/' , '+theta' , 'theta+' , '-theta' , 'theta-' ], ... forbidden_message = \"Your answer should only use trigonometric functions acting on theta, not multiples of theta\" ... ) If a student tries to use one of these strings, then they receive the forbidden_message , without giving away what the forbidden string is. We recommend using this sparingly, as students may find it confusing. The default forbidden_message is \"Invalid Input: This particular answer is forbidden\". Forbidden strings and student answers are stripped of whitespace before being compared. Thus, if x + y is forbidden, then answers containing x+y or x + y will be rejected. Blacklists and Whitelists # You can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example, sin is disallowed in correct answers. >>> grader = FormulaGrader ( ... answers = 'sqrt(1 - cos(x)^2)' , ... variables = [ 'x' ], ... sample_from = { 'x' : [ 0 , np . pi ]}, ... blacklist = [ 'sin' ] ... ) If you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are sin and cos . >>> grader = FormulaGrader ( ... answers = 'sin(x)/cos(x)' , ... variables = [ 'x' ], ... whitelist = [ 'sin' , 'cos' ] ... ) If you want to exclude all functions, use whitelist=[None] : >>> grader = FormulaGrader ( ... answers = 'pi/2-x' , ... variables = [ 'x' ], ... whitelist = [ None ] # no functions are allowed ... ) You cannot use a whitelist and a blacklist at the same time. Required Functions # You can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required. >>> grader = FormulaGrader ( ... answers = '2*sin(theta)*cos(theta)' , ... variables = [ 'theta' ], ... required_functions = [ 'sin' , 'cos' ] ... ) Tolerance # Student inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg, 0.1 ) or a percentage (eg, '0.01%' , which is the default tolerance). Tolerances must be nonnegative numbers or percentages. >>> grader = FormulaGrader ( ... answers = '2*sin(theta)*cos(theta)' , ... variables = [ 'theta' ], ... tolerance = 0.00001 ... ) Tolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers. Note that if the answer is exactly 0 (or can be sampled to be exactly 0 , such as when using integer sampling), percentage tolerances don't work (as any percentage of zero is still zero). This means that the student-supplied answer must also evaluate to exactly zero to be graded correctly. Note that answers like cos(pi/2) evaluate to approximately 10^(-16) due to numerical roundoff error. If you want such answers to be graded correctly, make sure to use an absolute tolerance instead of a relative tolerance on such questions. Suffixes # Numbers with a % at the end will be treated as percentages, and converted to the appropriate decimals. If you desire, you can also enable the use of metric suffixes by setting the appropriate setting as follows. >>> grader = FormulaGrader ( ... answers = '2m*a' , # Equivalent to '0.002*a' ... variables = [ 'a' ], ... metric_suffixes = True ... ) The included suffixes are: k : 1e3 M : 1e6 G : 1e9 T : 1e12 m : 1e-3 u : 1e-6 n : 1e-9 p : 1e-12 We strongly recommend not combining these suffixes with the variables names k , M , G , T , m , u , n or p , as 2m and 2*m will then represent two very different things, which can lead to much student confusion. Sibling Variables # When a student submits several mathematical expressions as part of one problem, it is sometimes useful to grade these inputs in comparison to each other. This can be done using sibling variables , which are available when FormulaGrader is used as a subgrader in ordered ListGrader problems. For example: >>> grader = ListGrader ( ... answers = [ ... ( 'x' , '2*x' , '3*x' ), # first input can be any of these 3 answers ... 'sibling_1^2' , # second input must be first input squared ... 'sibling_2^2' # third input must be second input squared ... ], ... ordered = True , ... subgraders = FormulaGrader ( variables = [ 'x' ]) ... ) Note that in this example, the sequence of inputs ['2*x', 4*x^2, 16*x^4] is correct, and so is ['3*x', 9*x^2, 81*x^4] , but ['3*x', 4*x^2, 16*x^4] receives only two-thirds credit (from the first entry matching a given answer, and the last entry being the square of the second entry). >>> student_inputs = [ '2*x' , '4*x^2' , '16*x^4' ] >>> result1 , result2 , result3 = grader ( None , student_inputs )[ 'input_list' ] >>> result1 [ 'ok' ], result2 [ 'ok' ], result3 [ 'ok' ] (True, True, True) >>> student_inputs = [ '3*x' , '9*x^2' , '81*x^4' ] >>> result1 , result2 , result3 = grader ( None , student_inputs )[ 'input_list' ] >>> result1 [ 'ok' ], result2 [ 'ok' ], result3 [ 'ok' ] (True, True, True) >>> student_inputs = [ '3*x' , '4*x^2' , '16*x^4' ] >>> result1 , result2 , result3 = grader ( None , student_inputs )[ 'input_list' ] >>> result1 [ 'ok' ], result2 [ 'ok' ], result3 [ 'ok' ] (True, False, True) Notes: Sibling variables are available to FormulaGrader , NumericalGrader , and MatrixGrader , but only in ordered ListGrader problems. The jth student input is referenced as sibling_j . (Exception: If nesting ListGraders with grouping, sibling_j refers to the jth member of any particular group.) Students are not able to use sibling_j in any of their answers. Comparer Functions # Comparer functions allow you to compare the student input to the author's expectation using aspects other than equality, or to use a given scheme to assign partial credit. See Comparer Functions for details. Other Improvements # We have made a number of other improvements over the edX formula graders, including: Square roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like sqrt(x-1) or (x-1)^0.5 always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases. Our parser uses a parsing cache, and hence runs much more efficiently than the edX graders. If a student inputs an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue. When students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable. Similarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing. If an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the debug flag to True , and a more technical message will usually be displayed. Full sampling details are included when the debug flag is set to True . Enhancements to the AsciiMath renderer (the preview that students see when using <textline /> inputs) are available using our highly recommended AsciiMath renderer definitions . Note that a few of these improvements have been merged into edX by the authors of this library. Options Listing # Here is the full list of options specific to a FormulaGrader . grader = FormulaGrader ( variables = list , # default [] numbered_vars = list , # default [] sample_from = dict , # default {} samples = int , # default 5 user_functions = dict , # default {} user_constants = dict , # default {} failable_evals = int , # default 0 instructor_vars = list , # default [] blacklist = list , # default [] whitelist = list , # default [] forbidden_strings = list , # default [] forbidden_message = str , # default 'Invalid Input: This particular answer is forbidden' required_functions = list , # default [] metric_suffixes = bool , # default False tolerance = ( float | percentage ), # default '0.01%' )","title":"FormulaGrader"},{"location":"grading_math/formula_grader/#formulagrader","text":"FormulaGrader is the grading class used to grade mathematical formulas and closely resembles the behavior of edX's <formularesponse /> tag, but with much more versatility. Note All expressions are treated in a case sensitive manner. This means that variables m and M are distinct. Case-insensitive FormulaGrader s were deprecated in Version 1.1.0 All whitespace is stripped from formulas that are entered. So, 1 + x ^ 2 is equivalent to 1+x^2 .","title":"FormulaGrader"},{"location":"grading_math/formula_grader/#variables-and-sampling","text":"FormulaGrader grades a formula by numerical sampling. That is, random values are assigned to each of the unknown variables and unknown functions, and the numerical value of the student's input expression and author's answer are calculated. The sampling process is repeated, and if the student answer and author answer compare within the desired tolerance enough times, the student input is graded as correct. Variables are configured by including a list of strings of each variable name as follows. >>> from mitxgraders import * >>> grader = FormulaGrader ( ... answers = '1+x^2+y' , ... variables = [ 'x' , 'y' ] ... ) Note that the answers parameter follows all of the usual allowances from ItemGrader . The variables need to have numbers randomly assigned to them. Each is sampled from a sampling set , which is RealInterval() by default (random numbers between 1 and 5). A variety of different sampling sets are available, including random complex numbers. To specify the sampling set to use for a variable, use the sample_from key. >>> grader = FormulaGrader ( ... answers = '1+x^2+y+z/2' , ... variables = [ 'x' , 'y' , 'z' ], ... sample_from = { ... 'x' : ComplexRectangle (), ... 'y' : [ 2 , 6 ], ... 'z' : ( 1 , 3 , 4 , 8 ) ... } ... ) The sample_from key must be a dictionary of 'variable_name': sampling_set pairs. You can specify a sampling set, a real interval, or a discrete set of values to sample from. The above example shows each of these in order.","title":"Variables and Sampling"},{"location":"grading_math/formula_grader/#variable-names","text":"Variable names are case-sensitive. They must start with a letter, and can be proceded by any combination of letters and numbers. There are two ways to write subscripts and superscripts: Old edX style: var_123 (we also allow the use of multiple underscores for backwards compatability with edX, although it is not recommended that this be used) Tensor style: var_{123} , var_{123}^{456} (subscript first), or var^{456} Sub/superscripts can contain any combination of letters and numbers. Tensor style sub/superscripts are allowed to start with a - sign. All types of variable names are allowed to end with an arbitrary number of primes ' (apostrophes, useful to indicate differentiation or different reference frames). Students on tablets may need to disable \"smart quotes\" to enter this character. The AsciiMath renderer used in <textline> entries in edX has a number of special symbols that can help make variable names look like particular mathematical entries. A handful of these are hatx , vecx , tildex , barx , dotx and ddotx . There are also a handful of other reserved names in AsciiMath; we recommend testing your variables to ensure that they render as expected.","title":"Variable Names"},{"location":"grading_math/formula_grader/#numbered-variables","text":"You can also specify special variables that are numbered. For example, if you specify that a is a numbered variable, students can include a_{0} , a_{5} , a_{-2} , etc, using any integer. All entries for a numbered variable will use the sampling set specified by the base name. >>> grader = FormulaGrader ( ... answers = 'a_ {0} + a_ {1} *x + 1/2*a_ {2} *x^2' , ... variables = [ 'x' ], ... numbered_vars = [ 'a' ], ... sample_from = { ... 'x' : [ - 5 , 5 ], ... 'a' : [ - 10 , 10 ] ... } ... ) If you have a variable name that would clash with a numbered variable (say, you defined a_{0} and also a numbered variable a ), then the specific variable has precedence.","title":"Numbered Variables"},{"location":"grading_math/formula_grader/#samples-and-failable-evaluations","text":"To control the number of samples that are checked to ensure correctness, you can modify the samples key. >>> grader = FormulaGrader ( ... answers = '1+x^2' , ... variables = [ 'x' ], ... samples = 10 ... ) The default for samples is 5. You may want to allow for a certain number of comparisons to fail before the student is marked incorrect. To do this, set failable_evals . This should be used very sparingly! >>> grader = FormulaGrader ( ... answers = '1+x^2' , ... variables = [ 'x' ], ... samples = 10 , ... failable_evals = 1 ... )","title":"Samples and Failable Evaluations"},{"location":"grading_math/formula_grader/#constants","text":"By default, four constants are defined: e , pi , and i=j=sqrt(-1) . You can define new constants by passing in a dictionary to user_constants as follows. >>> grader = FormulaGrader ( ... answers = '1/sqrt(1-v^2/c^2)' , ... variables = [ 'v' ], ... user_constants = { ... 'c' : 3e8 ... } ... ) Constants are treated as variables that only ever have one value. If you want to remove a default constant, you can do so by setting it to None : >>> grader = FormulaGrader ( ... answers = 'sqrt(-1)' , ... user_constants = { ... 'i' : None , ... 'j' : None ... } ... )","title":"Constants"},{"location":"grading_math/formula_grader/#infinities","text":"When an expression results in an infinity, students are presented with an error message asking them to check for overflow. If you actually want infinity to be an acceptable answer, then you can specify allow_inf=True . This allows expressions to evaluate to infinity (or negative infinity), and also makes the constant infty available for students to use. >>> # Without allow_inf turned on: >>> grader = FormulaGrader ( ... answers = 'infty' , ... user_constants = { ... 'infty' : float ( 'inf' ) ... } ... ) >>> try : ... grader ( None , 'infty' ) ... except CalcError as error : ... print ( error ) Numerical overflow occurred. Does your expression generate very large numbers? >>> # With allow_inf turned on: >>> grader = FormulaGrader ( ... answers = 'infty' , ... allow_inf = True ... ) >>> grader ( None , 'infty' ) == { 'ok' : True , 'msg' : '' , 'grade_decimal' : 1 } True","title":"Infinities"},{"location":"grading_math/formula_grader/#functions","text":"By default, a large array of mathematical functions are available for use. See the full list here . Note that all functions are capable of handling complex expressions unless otherwise stated. In the following example, z*z is recognized to be different from abs(z)^2 . >>> grader = FormulaGrader ( ... answers = 'abs(z)^2' , ... variables = [ 'z' ], ... sample_from = { ... 'z' : ComplexRectangle () ... } ... ) >>> grader ( None , 'z*z' )[ 'ok' ] False >>> grader ( None , 'z*conj(z)' )[ 'ok' ] True","title":"Functions"},{"location":"grading_math/formula_grader/#user-functions","text":"You can make user-defined functions available for students to use in their answers. To add user-defined functions, pass in a dictionary to the user_functions key as follows. >>> grader = FormulaGrader ( ... answers = 'x*x' , ... variables = [ 'x' ], ... user_functions = { 'f' : lambda x : x * x } ... ) This defines a function f(x) = x^2 that students may use. User-defined function names must start with a letter, and can use numbers and underscores, such as my_func2 . They are also allowed to have apostrophes (primes) at the end of the name, such as to indicate derivatives. Eg, f'' . Be careful about using quotation marks appropriately when using primes in function names, as in the following example. >>> grader = FormulaGrader ( ... answers = \"f''(x)\" , ... variables = [ 'x' ], ... user_functions = { \"f''\" : lambda x : x * x } ... )","title":"User Functions"},{"location":"grading_math/formula_grader/#choosing-a-function-randomly","text":"You can also specify random functions by specifying a sampling set for a function. You can provide a list of functions to randomly choose from as follows. >>> import numpy as np >>> grader = FormulaGrader ( ... answers = \"f(x)\" , ... variables = [ 'x' ], ... user_functions = { \"f\" : [ np . sin , np . cos ]} ... ) Each time this formula is checked, the function f will be sampled from the list of available functions. You can also specify a random well-behaved function by using the RandomFunction() sampling set. >>> grader = FormulaGrader ( ... answers = \"f''(x) + omega^2*f(x)\" , ... variables = [ 'x' , 'omega' ], ... user_functions = { ... \"f\" : RandomFunction (), ... \"f''\" : RandomFunction () ... } ... ) This allows you to grade mathematical expressions that involve unknown functions, such as the differential equation described in this example. See Sampling for further options associated with RandomFunction .","title":"Choosing a Function Randomly"},{"location":"grading_math/formula_grader/#overriding-default-functions-and-constants","text":"You can override default functions and constants if you really want, although this is discouraged and requires suppressing warnings with suppress_warnings=True . The following grader raises this warning when constructed: >>> try : ... grader = FormulaGrader ( ... answers = 'x^2' , ... variables = [ 'x' ], ... user_functions = { 'sin' : lambda x : x * x }, ... ) ... except ConfigError as error : ... print ( error ) Warning: 'user_functions' contains entries 'sin' which will override default values. If you intend to override defaults, you may suppress this warning by adding 'suppress_warnings=True' to the grader configuration. The error can be suppressed by setting suppress_warnings=True . >>> grader = FormulaGrader ( ... answers = 'x^2' , ... variables = [ 'x' ], ... user_functions = { 'sin' : lambda x : x * x }, ... suppress_warnings = True ... )","title":"Overriding Default Functions and Constants"},{"location":"grading_math/formula_grader/#restricting-student-input","text":"For some questions, you will want to restrict the sorts of input that are marked correct. For example, if you want students to expand sin(2*theta) , then you don't want students to be able to just write sin(2*theta) and be graded correct. FormulaGrader offers a number of ways to restrict what sort of answers will be marked correct.","title":"Restricting Student Input"},{"location":"grading_math/formula_grader/#instructor-variables","text":"In some situations, you need an extra variable to help define the problem in some way, particularly when using DependentSampler . Alternatively, you may want to remove a default constant such as e , i , j or pi from the problem. Both of these situations can be addressed by specifying particular variables to be instructor variables, as in the following. >>> grader = FormulaGrader ( ... answers = 's/c' , ... variables = [ 's' , 'c' , 'phi' ], ... sample_from = { ... 's' : DependentSampler ( depends = [ 'phi' ], formula = 'sin(phi)' ), ... 'c' : DependentSampler ( depends = [ 'phi' ], formula = 'cos(phi)' ) ... }, ... instructor_vars = [ 'phi' ] ... ) Here, students can use s and c , but not phi in their answer. The instructor_vars key accepts a list of the variables/constants you wish to make unavailable to students.","title":"Instructor Variables"},{"location":"grading_math/formula_grader/#forbidden-strings","text":"You can forbid students from entering certain strings using the forbidden_strings key: >>> grader = FormulaGrader ( ... answers = '2*sin(theta)*cos(theta)' , ... variables = [ 'theta' ], ... forbidden_strings = [ '*theta' , 'theta*' , 'theta/' , '+theta' , 'theta+' , '-theta' , 'theta-' ], ... forbidden_message = \"Your answer should only use trigonometric functions acting on theta, not multiples of theta\" ... ) If a student tries to use one of these strings, then they receive the forbidden_message , without giving away what the forbidden string is. We recommend using this sparingly, as students may find it confusing. The default forbidden_message is \"Invalid Input: This particular answer is forbidden\". Forbidden strings and student answers are stripped of whitespace before being compared. Thus, if x + y is forbidden, then answers containing x+y or x + y will be rejected.","title":"Forbidden Strings"},{"location":"grading_math/formula_grader/#blacklists-and-whitelists","text":"You can disallow specific functions by adding them to the blacklist of functions as a list of disallowed function names. In the following example, sin is disallowed in correct answers. >>> grader = FormulaGrader ( ... answers = 'sqrt(1 - cos(x)^2)' , ... variables = [ 'x' ], ... sample_from = { 'x' : [ 0 , np . pi ]}, ... blacklist = [ 'sin' ] ... ) If you want to exclude everything except for a specific set of functions, instead use a whitelist. In the following example, the only allowed functions in correct answers are sin and cos . >>> grader = FormulaGrader ( ... answers = 'sin(x)/cos(x)' , ... variables = [ 'x' ], ... whitelist = [ 'sin' , 'cos' ] ... ) If you want to exclude all functions, use whitelist=[None] : >>> grader = FormulaGrader ( ... answers = 'pi/2-x' , ... variables = [ 'x' ], ... whitelist = [ None ] # no functions are allowed ... ) You cannot use a whitelist and a blacklist at the same time.","title":"Blacklists and Whitelists"},{"location":"grading_math/formula_grader/#required-functions","text":"You can specifically require certain functions to appear in the solution. Any solution that does not include all of these functions will generate an error message. To do this, specify a list of strings of function names that are required. >>> grader = FormulaGrader ( ... answers = '2*sin(theta)*cos(theta)' , ... variables = [ 'theta' ], ... required_functions = [ 'sin' , 'cos' ] ... )","title":"Required Functions"},{"location":"grading_math/formula_grader/#tolerance","text":"Student inputs are compared to answers with a numerical tolerance. You can set this as an absolute number (eg, 0.1 ) or a percentage (eg, '0.01%' , which is the default tolerance). Tolerances must be nonnegative numbers or percentages. >>> grader = FormulaGrader ( ... answers = '2*sin(theta)*cos(theta)' , ... variables = [ 'theta' ], ... tolerance = 0.00001 ... ) Tolerances are necessary because of numerical roundoff error that lead to small differences in evaluations of algebraically equivalent expressions. Zero tolerance should be used sparingly, perhaps only with integer sampling and answers. Note that if the answer is exactly 0 (or can be sampled to be exactly 0 , such as when using integer sampling), percentage tolerances don't work (as any percentage of zero is still zero). This means that the student-supplied answer must also evaluate to exactly zero to be graded correctly. Note that answers like cos(pi/2) evaluate to approximately 10^(-16) due to numerical roundoff error. If you want such answers to be graded correctly, make sure to use an absolute tolerance instead of a relative tolerance on such questions.","title":"Tolerance"},{"location":"grading_math/formula_grader/#suffixes","text":"Numbers with a % at the end will be treated as percentages, and converted to the appropriate decimals. If you desire, you can also enable the use of metric suffixes by setting the appropriate setting as follows. >>> grader = FormulaGrader ( ... answers = '2m*a' , # Equivalent to '0.002*a' ... variables = [ 'a' ], ... metric_suffixes = True ... ) The included suffixes are: k : 1e3 M : 1e6 G : 1e9 T : 1e12 m : 1e-3 u : 1e-6 n : 1e-9 p : 1e-12 We strongly recommend not combining these suffixes with the variables names k , M , G , T , m , u , n or p , as 2m and 2*m will then represent two very different things, which can lead to much student confusion.","title":"Suffixes"},{"location":"grading_math/formula_grader/#sibling-variables","text":"When a student submits several mathematical expressions as part of one problem, it is sometimes useful to grade these inputs in comparison to each other. This can be done using sibling variables , which are available when FormulaGrader is used as a subgrader in ordered ListGrader problems. For example: >>> grader = ListGrader ( ... answers = [ ... ( 'x' , '2*x' , '3*x' ), # first input can be any of these 3 answers ... 'sibling_1^2' , # second input must be first input squared ... 'sibling_2^2' # third input must be second input squared ... ], ... ordered = True , ... subgraders = FormulaGrader ( variables = [ 'x' ]) ... ) Note that in this example, the sequence of inputs ['2*x', 4*x^2, 16*x^4] is correct, and so is ['3*x', 9*x^2, 81*x^4] , but ['3*x', 4*x^2, 16*x^4] receives only two-thirds credit (from the first entry matching a given answer, and the last entry being the square of the second entry). >>> student_inputs = [ '2*x' , '4*x^2' , '16*x^4' ] >>> result1 , result2 , result3 = grader ( None , student_inputs )[ 'input_list' ] >>> result1 [ 'ok' ], result2 [ 'ok' ], result3 [ 'ok' ] (True, True, True) >>> student_inputs = [ '3*x' , '9*x^2' , '81*x^4' ] >>> result1 , result2 , result3 = grader ( None , student_inputs )[ 'input_list' ] >>> result1 [ 'ok' ], result2 [ 'ok' ], result3 [ 'ok' ] (True, True, True) >>> student_inputs = [ '3*x' , '4*x^2' , '16*x^4' ] >>> result1 , result2 , result3 = grader ( None , student_inputs )[ 'input_list' ] >>> result1 [ 'ok' ], result2 [ 'ok' ], result3 [ 'ok' ] (True, False, True) Notes: Sibling variables are available to FormulaGrader , NumericalGrader , and MatrixGrader , but only in ordered ListGrader problems. The jth student input is referenced as sibling_j . (Exception: If nesting ListGraders with grouping, sibling_j refers to the jth member of any particular group.) Students are not able to use sibling_j in any of their answers.","title":"Sibling Variables"},{"location":"grading_math/formula_grader/#comparer-functions","text":"Comparer functions allow you to compare the student input to the author's expectation using aspects other than equality, or to use a given scheme to assign partial credit. See Comparer Functions for details.","title":"Comparer Functions"},{"location":"grading_math/formula_grader/#other-improvements","text":"We have made a number of other improvements over the edX formula graders, including: Square roots and other functions have a wider domain: with edX's default FormulaResponse, authors need to be careful that expressions like sqrt(x-1) or (x-1)^0.5 always pass nonnegative inputs to the square root and power functions. Our square root, power, logarithm, and inverse trigonometric functions accept a wider array of inputs (the entire complex plane, minus poles). For this reason, authors can feel safe using the default sample range in most cases. Our parser uses a parsing cache, and hence runs much more efficiently than the edX graders. If a student inputs an expression with mismatched parentheses, this generates an intelligible error message that points to the exact issue. When students use an unknown variable, the resulting error message highlights that the unknown quantity was interpreted as a variable. Similarly, when students use an unknown function, the resulting error message highlights that the unknown quantity was interpreted as a function. If a variable of that name exists, the error message suggests that a multiplication symbol was missing. If an unexpected error occurs, students will see a generic \"invalid input\" message. To see exactly where things went wrong, set the debug flag to True , and a more technical message will usually be displayed. Full sampling details are included when the debug flag is set to True . Enhancements to the AsciiMath renderer (the preview that students see when using <textline /> inputs) are available using our highly recommended AsciiMath renderer definitions . Note that a few of these improvements have been merged into edX by the authors of this library.","title":"Other Improvements"},{"location":"grading_math/formula_grader/#options-listing","text":"Here is the full list of options specific to a FormulaGrader . grader = FormulaGrader ( variables = list , # default [] numbered_vars = list , # default [] sample_from = dict , # default {} samples = int , # default 5 user_functions = dict , # default {} user_constants = dict , # default {} failable_evals = int , # default 0 instructor_vars = list , # default [] blacklist = list , # default [] whitelist = list , # default [] forbidden_strings = list , # default [] forbidden_message = str , # default 'Invalid Input: This particular answer is forbidden' required_functions = list , # default [] metric_suffixes = bool , # default False tolerance = ( float | percentage ), # default '0.01%' )","title":"Options Listing"},{"location":"grading_math/functions_and_constants/","text":"Mathematical Functions and Constants # FormulaGrader and NumericalGrader Default Functions # Note Below, expressions marked with a * may require our AsciiMath renderer definitions to display properly in edX. By default, all of the following functions are made available to students in FormulaGrader problems. sin(x) Sine cos(x) Cosine tan(x) Tangent sec(x) Secant csc(x) Cosecant cot(x) Cotangent sqrt(x) Square Root log10(x) Log (base 10)* log2(x) Log (base 2)* ln(x) Natural logarithm exp(x) Exponential arccos(x) Inverse Cosine arcsin(x) Inverse Sine arctan(x) Inverse Tangent arctan2(x, y) Four-quadrant Inverse Tangent* arcsec(x) Inverse Secant* arccsc(x) Inverse Cosecant* arccot(x) Inverse Cotangent* abs(x) Absolute value (real) or modulus (complex) factorial(x) and fact(x) Factorial* domain: all complex numbers except negative integers. Large outputs may raise OverflowError s. sinh(x) Hyperbolic Sine cosh(x) Hyperbolic Cosine tanh(x) Hyperbolic Tangent sech(x) Hyperbolic Secant csch(x) Hyperbolic Cosecant coth(x) Hyperbolic Cotangent arcsinh(x) Inverse Hyperbolic Sine* arccosh(x) Inverse Hyperbolic Cosine* arctanh(x) Inverse Hyperbolic Tangent* arcsech(x) Inverse Hyperbolic Secant* arccsch(x) Inverse Hyperbolic Cosecant* arccoth(x) Inverse Hyperbolic Cotangent* floor(x) Floor function (applies only to real numbers) ceil(x) Ceiling function (applies only to real numbers) min(x, y, z, ...) Minimum of the arguments (applies only to real numbers, 2 or more arguments) max(x, y, z, ...) Maximum of the arguments (applies only to real numbers, 2 or more arguments) re(x) Real part of a complex expression* im(x) Imaginary part of a complex expression* conj(x) Complex conjugate of a complex expression* kronecker(x, y) Kronecker delta* (Note that we highly recommend integer sampling over a short range (eg, 1 to 4) when Kronecker deltas appear in an answer, and using many samples (eg, 30) so that most permutations appear in the sampling.) MatrixGrader Default Functions # In MatrixGrader problems, all FormulaGrader functions are available by default, as are the following extra functions: abs(x) : absolute value of a scalar or magnitude of a vector adj(x) : Hermitian adjoint, same as ctrans(x) * cross(x, y) : cross product, inputs must be 3-component vectors* ctrans(x) : conjugate transpose, same as adj(x) * det(x) : determinant, input must be square matrix norm(x) : Frobenius norm, works for scalars, vectors, and matrices trans(x) : transpose* trace(x) : trace Default Constants # Available in FormulaGrader , NumericalGrader , and MatrixGrader by default: i : imaginary unit (same as j ) j : imaginary unit (same as i ) e : approximately 2.718281828 pi : approximately 3.141592654 Optional Constant Collections # We provide a few collections of constants that can be imported for convenience and reuse. For example, pauli is a dictionary with keys sigma_x , sigma_y , and sigma_z that are MathArray representations of the 2x2 Pauli matrices. The collections of available mathematical constants are: pauli : MathArray representations of the 2x2 Pauli matrices, sigma_x , sigma_y , and sigma_z cartesian_xyz : MathArray representations of the three-dimensional Cartesian unit vectors, named hatx , haty , hatz cartesian_ijk : MathArray representations of the three-dimensional Cartesian unit vectors, named hati , hatj , hatk Each collection is a dictionary that can be provided as a value of user_constants : >>> from mitxgraders import * >>> grader = MatrixGrader ( ... answers = 'sigma_x + sigma_z' , ... user_constants = pauli ... )","title":"Functions and Constants List"},{"location":"grading_math/functions_and_constants/#mathematical-functions-and-constants","text":"","title":"Mathematical Functions and Constants"},{"location":"grading_math/functions_and_constants/#formulagrader-and-numericalgrader-default-functions","text":"Note Below, expressions marked with a * may require our AsciiMath renderer definitions to display properly in edX. By default, all of the following functions are made available to students in FormulaGrader problems. sin(x) Sine cos(x) Cosine tan(x) Tangent sec(x) Secant csc(x) Cosecant cot(x) Cotangent sqrt(x) Square Root log10(x) Log (base 10)* log2(x) Log (base 2)* ln(x) Natural logarithm exp(x) Exponential arccos(x) Inverse Cosine arcsin(x) Inverse Sine arctan(x) Inverse Tangent arctan2(x, y) Four-quadrant Inverse Tangent* arcsec(x) Inverse Secant* arccsc(x) Inverse Cosecant* arccot(x) Inverse Cotangent* abs(x) Absolute value (real) or modulus (complex) factorial(x) and fact(x) Factorial* domain: all complex numbers except negative integers. Large outputs may raise OverflowError s. sinh(x) Hyperbolic Sine cosh(x) Hyperbolic Cosine tanh(x) Hyperbolic Tangent sech(x) Hyperbolic Secant csch(x) Hyperbolic Cosecant coth(x) Hyperbolic Cotangent arcsinh(x) Inverse Hyperbolic Sine* arccosh(x) Inverse Hyperbolic Cosine* arctanh(x) Inverse Hyperbolic Tangent* arcsech(x) Inverse Hyperbolic Secant* arccsch(x) Inverse Hyperbolic Cosecant* arccoth(x) Inverse Hyperbolic Cotangent* floor(x) Floor function (applies only to real numbers) ceil(x) Ceiling function (applies only to real numbers) min(x, y, z, ...) Minimum of the arguments (applies only to real numbers, 2 or more arguments) max(x, y, z, ...) Maximum of the arguments (applies only to real numbers, 2 or more arguments) re(x) Real part of a complex expression* im(x) Imaginary part of a complex expression* conj(x) Complex conjugate of a complex expression* kronecker(x, y) Kronecker delta* (Note that we highly recommend integer sampling over a short range (eg, 1 to 4) when Kronecker deltas appear in an answer, and using many samples (eg, 30) so that most permutations appear in the sampling.)","title":"FormulaGrader and NumericalGrader Default Functions"},{"location":"grading_math/functions_and_constants/#matrixgrader-default-functions","text":"In MatrixGrader problems, all FormulaGrader functions are available by default, as are the following extra functions: abs(x) : absolute value of a scalar or magnitude of a vector adj(x) : Hermitian adjoint, same as ctrans(x) * cross(x, y) : cross product, inputs must be 3-component vectors* ctrans(x) : conjugate transpose, same as adj(x) * det(x) : determinant, input must be square matrix norm(x) : Frobenius norm, works for scalars, vectors, and matrices trans(x) : transpose* trace(x) : trace","title":"MatrixGrader Default Functions"},{"location":"grading_math/functions_and_constants/#default-constants","text":"Available in FormulaGrader , NumericalGrader , and MatrixGrader by default: i : imaginary unit (same as j ) j : imaginary unit (same as i ) e : approximately 2.718281828 pi : approximately 3.141592654","title":"Default Constants"},{"location":"grading_math/functions_and_constants/#optional-constant-collections","text":"We provide a few collections of constants that can be imported for convenience and reuse. For example, pauli is a dictionary with keys sigma_x , sigma_y , and sigma_z that are MathArray representations of the 2x2 Pauli matrices. The collections of available mathematical constants are: pauli : MathArray representations of the 2x2 Pauli matrices, sigma_x , sigma_y , and sigma_z cartesian_xyz : MathArray representations of the three-dimensional Cartesian unit vectors, named hatx , haty , hatz cartesian_ijk : MathArray representations of the three-dimensional Cartesian unit vectors, named hati , hatj , hatk Each collection is a dictionary that can be provided as a value of user_constants : >>> from mitxgraders import * >>> grader = MatrixGrader ( ... answers = 'sigma_x + sigma_z' , ... user_constants = pauli ... )","title":"Optional Constant Collections"},{"location":"grading_math/integral_grader/","text":"IntegralGrader # IntegralGrader is a specialized grading class used to grade the construction of integrals. Students can input the limits on the integral, the variable of integration, and the integrand (or some subset thereof), and will be graded correct if their construction is numerically equivalent to the instructor's construction. This method of grading allows for arbitrary variable substitutions and redefinitions. The grader numerically evaluates the student- and instructor-specified integrals using scipy.integrate.quad . This quadrature-based integration technique is efficient and flexible. It handles many integrals with poles in the integrand and can integrate over infinite domains. However, some integrals may behave badly. These include, but are not limited to, the following: integrals with highly oscillatory integrands integrals that evaluate analytically to zero In some cases, problems might be avoided by using the integrator_options configuration key to provide extra instructions to scipy.integrate.quad , as documented below. XML Setup # We recommend copying the following XML to set up a problem using IntegralGrader : <style> .xmodule_display.xmodule_CapaModule .problem .capa_inputtype.textline input { min-width: 0 !important; } .xmodule_display.xmodule_CapaModule div.problem section div span.MathJax { display: inline-block !important; } .xmodule_display.xmodule_CapaModule div.problem section div span.MathJax_Preview { display: inline-block !important; } </style> <span> <customresponse cfn= \"grader\" > <table> <col style= \"width:10%\" /> <col style= \"width:90%\" /> <tbody> <tr> <td colspan= \"2\" > <textline size= \"5\" correct_answer= \"1\" /> </td> </tr> <tr> <td> <p> \\( \\displaystyle \\huge{ \\int }\\) </p> </td> <td> <br/> <textline inline= \"1\" size= \"10\" correct_answer= \"e^x\" trailing_text= \" [mathjaxinline] dx [/mathjaxinline]\" /> </td> </tr> <tr> <td colspan= \"2\" > <textline size= \"5\" correct_answer= \"0\" /> </td> </tr> </tbody> </table> </customresponse> </span> This sets up an integral where students can input the limits of integration and the integrand (the variable of integration has been fixed to be x in this case). Further examples of formatting integrals are shown in the example course. Specifying the Input Format # The grader must be told which input is what, based on the order that the inputs appear in the XML. This is done through the input_positions dictionary. If not specified, it is assumed that the following positions are used: input_positions = { 'lower' : 1 , 'upper' : 2 , 'integrand' : 3 , 'integration_variable' : 4 } This requires students to enter all four parameters in the indicated order. If the author overrides the default input_positions value, any subset of the keys ('lower', 'upper', 'integrand', 'integration_variable') may be specified. Key values should be continuous integers starting at 1, or (default) None, indicating that the parameter is not entered by student For example, input_positions = { 'lower' : 1 , 'upper' : 2 , 'integrand' : 3 } indicates that the problem has 3 input boxes which represent the lower limit, upper limit, and integrand in that order. The integration_variable is NOT entered by student and is instead given by the value specified by author in 'answers'. Here is a sample grader for the above XML: >>> from mitxgraders import * >>> grader = IntegralGrader ( ... answers = { ... 'lower' : '0' , ... 'upper' : '1' , ... 'integrand' : 'e^x' , ... 'integration_variable' : 'x' ... }, ... input_positions = { ... 'upper' : 1 , ... 'integrand' : 2 , ... 'lower' : 3 ... } ... ) Note that when students specify their own variable of integration, it must not conflict with a variable already present in the problem. Specifying the Answer # The author's answer should be specified as a dictionary with the following keys: answers = { 'lower' : 'lower_limit' , 'upper' : 'upper_limit' , 'integrand' : 'integrand' , 'integration_variable' : 'variable_of_integration' } Note that each entry is a string value. IntegralGrader can handle integrals over both finite and infinite domains. A special constant 'infty' is recognized to cater for the infinite case (and takes on the special value float('inf') ). Other Options # If you wish to allow a student's integrand to be complex-valued at any point in the domain of the integral, set complex_integrand=True . If set to False (the default), a student's submission will be graded as incorrect if their integrand becomes complex anywhere in the domain. You can modify the integration options used by scipy.integrate.quad by passing a dictionary of keyword-argument values using the option integrator_options . The following options from FormulaGrader are available for use in IntegralGrader : user_constants user_functions whitelist blacklist tolerance samples (default: 1) variables sample_from failable_evals numbered_vars instructor_vars forbidden_strings forbidden_message required_functions metric_suffixes Unless otherwise specified, the defaults are the same as in FormulaGrader . Option Listing # Here is the full list of options specific to an IntegralGrader . grader = IntegralGrader ( input_positions = dict , answers = dict , integrator_options = dict , # default {'full_output': 1} complex_integrand = bool , # default False # The below options are the same as in FormulaGrader variables = list , # default [] sample_from = dict , # default {} samples = int , # default 1 user_functions = dict , # default {} user_constants = dict , # default {} failable_evals = int , # default 0 blacklist = list , # default [] whitelist = list , # default [] tolerance = ( float | percentage ), # default '0.01%' numbered_vars = list , # default [] instructor_vars = list , # default [] forbidden_strings = list , # default [] forbidden_message = str , # default 'Invalid Input: This particular answer is forbidden' required_functions = list , # default [] metric_suffixes = bool , # default False )","title":"IntegralGrader"},{"location":"grading_math/integral_grader/#integralgrader","text":"IntegralGrader is a specialized grading class used to grade the construction of integrals. Students can input the limits on the integral, the variable of integration, and the integrand (or some subset thereof), and will be graded correct if their construction is numerically equivalent to the instructor's construction. This method of grading allows for arbitrary variable substitutions and redefinitions. The grader numerically evaluates the student- and instructor-specified integrals using scipy.integrate.quad . This quadrature-based integration technique is efficient and flexible. It handles many integrals with poles in the integrand and can integrate over infinite domains. However, some integrals may behave badly. These include, but are not limited to, the following: integrals with highly oscillatory integrands integrals that evaluate analytically to zero In some cases, problems might be avoided by using the integrator_options configuration key to provide extra instructions to scipy.integrate.quad , as documented below.","title":"IntegralGrader"},{"location":"grading_math/integral_grader/#xml-setup","text":"We recommend copying the following XML to set up a problem using IntegralGrader : <style> .xmodule_display.xmodule_CapaModule .problem .capa_inputtype.textline input { min-width: 0 !important; } .xmodule_display.xmodule_CapaModule div.problem section div span.MathJax { display: inline-block !important; } .xmodule_display.xmodule_CapaModule div.problem section div span.MathJax_Preview { display: inline-block !important; } </style> <span> <customresponse cfn= \"grader\" > <table> <col style= \"width:10%\" /> <col style= \"width:90%\" /> <tbody> <tr> <td colspan= \"2\" > <textline size= \"5\" correct_answer= \"1\" /> </td> </tr> <tr> <td> <p> \\( \\displaystyle \\huge{ \\int }\\) </p> </td> <td> <br/> <textline inline= \"1\" size= \"10\" correct_answer= \"e^x\" trailing_text= \" [mathjaxinline] dx [/mathjaxinline]\" /> </td> </tr> <tr> <td colspan= \"2\" > <textline size= \"5\" correct_answer= \"0\" /> </td> </tr> </tbody> </table> </customresponse> </span> This sets up an integral where students can input the limits of integration and the integrand (the variable of integration has been fixed to be x in this case). Further examples of formatting integrals are shown in the example course.","title":"XML Setup"},{"location":"grading_math/integral_grader/#specifying-the-input-format","text":"The grader must be told which input is what, based on the order that the inputs appear in the XML. This is done through the input_positions dictionary. If not specified, it is assumed that the following positions are used: input_positions = { 'lower' : 1 , 'upper' : 2 , 'integrand' : 3 , 'integration_variable' : 4 } This requires students to enter all four parameters in the indicated order. If the author overrides the default input_positions value, any subset of the keys ('lower', 'upper', 'integrand', 'integration_variable') may be specified. Key values should be continuous integers starting at 1, or (default) None, indicating that the parameter is not entered by student For example, input_positions = { 'lower' : 1 , 'upper' : 2 , 'integrand' : 3 } indicates that the problem has 3 input boxes which represent the lower limit, upper limit, and integrand in that order. The integration_variable is NOT entered by student and is instead given by the value specified by author in 'answers'. Here is a sample grader for the above XML: >>> from mitxgraders import * >>> grader = IntegralGrader ( ... answers = { ... 'lower' : '0' , ... 'upper' : '1' , ... 'integrand' : 'e^x' , ... 'integration_variable' : 'x' ... }, ... input_positions = { ... 'upper' : 1 , ... 'integrand' : 2 , ... 'lower' : 3 ... } ... ) Note that when students specify their own variable of integration, it must not conflict with a variable already present in the problem.","title":"Specifying the Input Format"},{"location":"grading_math/integral_grader/#specifying-the-answer","text":"The author's answer should be specified as a dictionary with the following keys: answers = { 'lower' : 'lower_limit' , 'upper' : 'upper_limit' , 'integrand' : 'integrand' , 'integration_variable' : 'variable_of_integration' } Note that each entry is a string value. IntegralGrader can handle integrals over both finite and infinite domains. A special constant 'infty' is recognized to cater for the infinite case (and takes on the special value float('inf') ).","title":"Specifying the Answer"},{"location":"grading_math/integral_grader/#other-options","text":"If you wish to allow a student's integrand to be complex-valued at any point in the domain of the integral, set complex_integrand=True . If set to False (the default), a student's submission will be graded as incorrect if their integrand becomes complex anywhere in the domain. You can modify the integration options used by scipy.integrate.quad by passing a dictionary of keyword-argument values using the option integrator_options . The following options from FormulaGrader are available for use in IntegralGrader : user_constants user_functions whitelist blacklist tolerance samples (default: 1) variables sample_from failable_evals numbered_vars instructor_vars forbidden_strings forbidden_message required_functions metric_suffixes Unless otherwise specified, the defaults are the same as in FormulaGrader .","title":"Other Options"},{"location":"grading_math/integral_grader/#option-listing","text":"Here is the full list of options specific to an IntegralGrader . grader = IntegralGrader ( input_positions = dict , answers = dict , integrator_options = dict , # default {'full_output': 1} complex_integrand = bool , # default False # The below options are the same as in FormulaGrader variables = list , # default [] sample_from = dict , # default {} samples = int , # default 1 user_functions = dict , # default {} user_constants = dict , # default {} failable_evals = int , # default 0 blacklist = list , # default [] whitelist = list , # default [] tolerance = ( float | percentage ), # default '0.01%' numbered_vars = list , # default [] instructor_vars = list , # default [] forbidden_strings = list , # default [] forbidden_message = str , # default 'Invalid Input: This particular answer is forbidden' required_functions = list , # default [] metric_suffixes = bool , # default False )","title":"Option Listing"},{"location":"grading_math/interval_grader/","text":"IntervalGrader # IntervalGrader grades pairs of numbers enclosed in appropriate brackets. It is intended for use in grading intervals, but can be used to grade other pairs of numbers/formulas with enclosing characters. The following are examples of possible entries: [1, 2) [0, 1 + pi] Both the enclosing brackets and the numbers are graded, and a variety of options for partial credit are available. IntervalGrader is an ItemGrader , and so can be used in lists as desired. Warning If using MJxPrep.js to format answers nicely, you will probably want to turn off column vectors, or simply not use the preprocessor for interval problems. Otherwise, [1, 2] will display as a vector rather than as an interval. If your expressions use a comma in any way, you should change the delimiter from a comma to something else. Basic Usage # To use an IntervalGrader , you can simply call invoke it like a typical grader: >>> from mitxgraders import * >>> grader = IntervalGrader ( answers = '[0, 1]' ) >>> grader ( None , '[0, 1]' ) == { 'ok' : True , 'grade_decimal' : 1 , 'msg' : '' } True Answers may be specified by supplying the relevant answer as a string, as in the above example, either through the answers key or through the expect keyword of the customresponse tag. You can also break out the answer into four constituent parts in a list as follows: >>> from mitxgraders import * >>> grader = IntervalGrader ( answers = [ '[' , '0' , '1' , ']' ]) >>> grader ( None , '[0, 1]' ) == { 'ok' : True , 'grade_decimal' : 1 , 'msg' : '' } True Each individual answer component conforms to the ItemGrader answers specification, so you can do things like the following: >>> grader = IntervalGrader ( ... answers = [ ... ( '[' , { 'expect' : '(' , 'msg' : 'Your opening bracket is wrong.' , 'grade_decimal' : 0.5 }), ... '0' , ... '1' , ... ( ']' , { 'expect' : ')' , 'msg' : 'Your closing bracket is wrong.' , 'grade_decimal' : 0.5 }), ... ] ... ) >>> grader ( None , '[0, 1)' ) == { 'ok' : 'partial' , 'grade_decimal' : 0.75 , 'msg' : 'Your closing bracket is wrong.' } True Brackets # You can specify the opening and closing brackets that students may use. Specify each separately as a list of acceptable characters. Entries that do not use these brackets will receive an error message. >>> grader = IntervalGrader ( ... answers = '[0,1]' , ... opening_brackets = '([{' , ... closing_brackets = ')]}' ... ) The default for opening_brackets is '[(' , while the default for closing_brackets is '])' . Subgrader # Grading of the two math expressions is performed by a subgrader. The default subgrader is NumericalGrader(tolerance=1e-13, allow_inf=True) , which allows infty as an entry, and otherwise sets a tight absolute tolerance on the answers. If this default doesn't suit your requirements, you may specify your own FormulaGrader or NumericalGrader as the subgrader for the expressions. This is particularly useful if you want variables to be allowed to appear in the expressions. >>> grader = IntervalGrader ( ... answers = '[a,b^2]' , ... subgrader = FormulaGrader ( variables = [ 'a' , 'b' ]) ... ) Delimiter # The default delimiter is a comma. However, due to the way expressions are parsed, if your expressions include commas in any location, the answer will not parse correctly. We suggest changing the delimiter to another character, as follows. >>> grader = IntervalGrader ( ... answers = '[0:1]' , ... delimiter = ':' ... ) Partial Credit (and how credit is assigned in general) # Grading works by first using the subgrader to obtain the decimal grade for each expression the student submitted. For each correct expression, the bracket is then inspected. If the bracket is correct, then the score for that expression is kept (or if grade_decimal is set for the bracket, then the score for the expression is multiplied by that entry). If the bracket is incorrect, zero is awarded for that expression. The two resulting scores are then combined to obtain the overall score. If partial_credit is set to False , then the overall score must be 1 for any credit to be awarded. By default, partial_credit is True . When partial credit is turned on, each half of the interval is worth 50% of the overall credit. To allow for partial credit when incorrect brackets are used, set up alternative answers using the ItemGrader answers specification, as demonstrated in an example above. Note that no credit is awarded for getting the entries backwards. If this should be graded correct, supply alternative answers to the grader using the ItemGrader answers specification. Options Listing # Here is the full list of options specific to an IntervalGrader . grader = IntervalGrader ( opening_brackets = str , # defaykt '[(' closing_brackets = str , # default '])' delimiter = str , # default ',', must be one character partial_credit = bool # default True )","title":"IntervalGrader"},{"location":"grading_math/interval_grader/#intervalgrader","text":"IntervalGrader grades pairs of numbers enclosed in appropriate brackets. It is intended for use in grading intervals, but can be used to grade other pairs of numbers/formulas with enclosing characters. The following are examples of possible entries: [1, 2) [0, 1 + pi] Both the enclosing brackets and the numbers are graded, and a variety of options for partial credit are available. IntervalGrader is an ItemGrader , and so can be used in lists as desired. Warning If using MJxPrep.js to format answers nicely, you will probably want to turn off column vectors, or simply not use the preprocessor for interval problems. Otherwise, [1, 2] will display as a vector rather than as an interval. If your expressions use a comma in any way, you should change the delimiter from a comma to something else.","title":"IntervalGrader"},{"location":"grading_math/interval_grader/#basic-usage","text":"To use an IntervalGrader , you can simply call invoke it like a typical grader: >>> from mitxgraders import * >>> grader = IntervalGrader ( answers = '[0, 1]' ) >>> grader ( None , '[0, 1]' ) == { 'ok' : True , 'grade_decimal' : 1 , 'msg' : '' } True Answers may be specified by supplying the relevant answer as a string, as in the above example, either through the answers key or through the expect keyword of the customresponse tag. You can also break out the answer into four constituent parts in a list as follows: >>> from mitxgraders import * >>> grader = IntervalGrader ( answers = [ '[' , '0' , '1' , ']' ]) >>> grader ( None , '[0, 1]' ) == { 'ok' : True , 'grade_decimal' : 1 , 'msg' : '' } True Each individual answer component conforms to the ItemGrader answers specification, so you can do things like the following: >>> grader = IntervalGrader ( ... answers = [ ... ( '[' , { 'expect' : '(' , 'msg' : 'Your opening bracket is wrong.' , 'grade_decimal' : 0.5 }), ... '0' , ... '1' , ... ( ']' , { 'expect' : ')' , 'msg' : 'Your closing bracket is wrong.' , 'grade_decimal' : 0.5 }), ... ] ... ) >>> grader ( None , '[0, 1)' ) == { 'ok' : 'partial' , 'grade_decimal' : 0.75 , 'msg' : 'Your closing bracket is wrong.' } True","title":"Basic Usage"},{"location":"grading_math/interval_grader/#brackets","text":"You can specify the opening and closing brackets that students may use. Specify each separately as a list of acceptable characters. Entries that do not use these brackets will receive an error message. >>> grader = IntervalGrader ( ... answers = '[0,1]' , ... opening_brackets = '([{' , ... closing_brackets = ')]}' ... ) The default for opening_brackets is '[(' , while the default for closing_brackets is '])' .","title":"Brackets"},{"location":"grading_math/interval_grader/#subgrader","text":"Grading of the two math expressions is performed by a subgrader. The default subgrader is NumericalGrader(tolerance=1e-13, allow_inf=True) , which allows infty as an entry, and otherwise sets a tight absolute tolerance on the answers. If this default doesn't suit your requirements, you may specify your own FormulaGrader or NumericalGrader as the subgrader for the expressions. This is particularly useful if you want variables to be allowed to appear in the expressions. >>> grader = IntervalGrader ( ... answers = '[a,b^2]' , ... subgrader = FormulaGrader ( variables = [ 'a' , 'b' ]) ... )","title":"Subgrader"},{"location":"grading_math/interval_grader/#delimiter","text":"The default delimiter is a comma. However, due to the way expressions are parsed, if your expressions include commas in any location, the answer will not parse correctly. We suggest changing the delimiter to another character, as follows. >>> grader = IntervalGrader ( ... answers = '[0:1]' , ... delimiter = ':' ... )","title":"Delimiter"},{"location":"grading_math/interval_grader/#partial-credit-and-how-credit-is-assigned-in-general","text":"Grading works by first using the subgrader to obtain the decimal grade for each expression the student submitted. For each correct expression, the bracket is then inspected. If the bracket is correct, then the score for that expression is kept (or if grade_decimal is set for the bracket, then the score for the expression is multiplied by that entry). If the bracket is incorrect, zero is awarded for that expression. The two resulting scores are then combined to obtain the overall score. If partial_credit is set to False , then the overall score must be 1 for any credit to be awarded. By default, partial_credit is True . When partial credit is turned on, each half of the interval is worth 50% of the overall credit. To allow for partial credit when incorrect brackets are used, set up alternative answers using the ItemGrader answers specification, as demonstrated in an example above. Note that no credit is awarded for getting the entries backwards. If this should be graded correct, supply alternative answers to the grader using the ItemGrader answers specification.","title":"Partial Credit (and how credit is assigned in general)"},{"location":"grading_math/interval_grader/#options-listing","text":"Here is the full list of options specific to an IntervalGrader . grader = IntervalGrader ( opening_brackets = str , # defaykt '[(' closing_brackets = str , # default '])' delimiter = str , # default ',', must be one character partial_credit = bool # default True )","title":"Options Listing"},{"location":"grading_math/numerical_grader/","text":"NumericalGrader # When grading math expressions without functions or variables, you can use NumericalGrader instead of FormulaGrader . NumericalGrader is a specialized version of FormulaGrader whose behavior resembles the edX <numericalresponse/> tag. Configuration # NumericalGrader has all of the same options as FormulaGrader except: tolerance : has a higher default value of '5%' failable_evals is always set to 0 samples is always set to 1 variables is always set to [] (no variables allowed) sample_from is always set to {} (no variables allowed) user_functions can only define specific functions, with no random functions Note that NumericalGrader will still evaluate formulas. If you are grading simple integers (such as 0, 1, 2, -1, etc), you may want to consider using StringGrader instead of NumericalGrader .","title":"NumericalGrader"},{"location":"grading_math/numerical_grader/#numericalgrader","text":"When grading math expressions without functions or variables, you can use NumericalGrader instead of FormulaGrader . NumericalGrader is a specialized version of FormulaGrader whose behavior resembles the edX <numericalresponse/> tag.","title":"NumericalGrader"},{"location":"grading_math/numerical_grader/#configuration","text":"NumericalGrader has all of the same options as FormulaGrader except: tolerance : has a higher default value of '5%' failable_evals is always set to 0 samples is always set to 1 variables is always set to [] (no variables allowed) sample_from is always set to {} (no variables allowed) user_functions can only define specific functions, with no random functions Note that NumericalGrader will still evaluate formulas. If you are grading simple integers (such as 0, 1, 2, -1, etc), you may want to consider using StringGrader instead of NumericalGrader .","title":"Configuration"},{"location":"grading_math/renderer/","text":"AsciiMath Renderer Definitions # When math input is expected from students, edX offers a math preview that attempts to show their expression in normal mathematical notation. There are two ways to provide this preview: <formulaequationinput/> or <textline math= \"1\" /> The formulaequationinput tag uses server-side parsing and rendering to display the preview to the student. By and large, the preview from formulaequationinput is better than that of textline , as it treats functions correctly, and displays a number of LaTeX symbols natively. The downsides to formulaequationinput are that it doesn't recognize vectors such as vecx or hatx , the factorial and conjugation functions just apply as fact(x) and conj(x) , and because the processing is done server-side, we are unable to enhance the display at all. The textline tag treats the student input as AsciiMath for the purpose of generating a preview, using MathJax to render it. While the preview does a reasonably good job, there are many situations where it falls down, even for standard edX functions (for example, try typing in 1/arctanh(x) in a textline box!). Because this is done client-side through javascript, it's possible to supplement the AsciiMath definitions to handle new situations. We have constructed a series of renderer definitions to supplement the standard AsciiMath definitions in order to provide better previews. This article describes how to use our new AsciiMath renderer definitions with a <textline> tag. How it Works # The renderer definitions are located in a javascript file, MJxPrep.js , which should be uploaded to the static assets folder for your course. This javascript file has two components: symbol definitions and a preprocessor. The symbol definitions are used to teach AsciiMath how to display various functions properly, such as re , im , arctanh etc. To load the symbol definitions in a problem, place the following HTML code somewhere in the problem. <script type= \"text/javascript\" src= \"/static/MJxPrep.js\" ></script> Some functions are too complex for a symbol definition, and need the student's input to be preprocessed into AsciiMath before rendering. These functions include log10 , log2 , fact / factorial , trans , adj / ctrans and cross . It is quite common to have a variable name begin with delta or Delta , such as Deltax . Unfortunately, AsciiMath treats such variables as two separate entries, and can sometimes split them inopportunely, such as for the expression 1/Deltax . The preprocessor detects such variable names and ensures that AsciiMath displays them correctly. To use these features, you need to add preprocessorClassName and preprocessorSrc properties to any <textline/> tags that use the preprocessor, such as in the following example. <customresponse cfn= \"grader\" > <textline correct_answer= \"1/fact(5)\" math= \"1\" preprocessorClassName= \"MJxPrep\" preprocessorSrc= \"/static/MJxPrep.js\" /> </customresponse> If you use the preprocessor in your problem, you get the symbol definitions as well (you don't need to load them separately using a script tag). Options # There are a few configurable options for the preprocessor in MJxPrep.js . By default, conj() displays as a bar over the argument to the function. However, you may wish for complex conjugates to be displayed as a superscript star. If so, you can set conj_as_star: true at the start of the file. By default, vectors [1, 2, 3] display as a column vector when the preprocessor is loaded (without the preprocessor, it will display as a row). If you would instead like them to display as a row vector, you can set the option vectors_as_columns: false at the start of the file. Extending Definitions # If you're building a course that uses math extensively, it's likely that you want to use some sort of symbol that can't be written in the form of an edX variable. In this situation, we have provided two functions to extend the preprocessor. At the bottom of MJxPrep.js , you will find the functions customPreReplacements and customPostReplacements , which are called before and after our preprocessing functions occur, respectively. You can perform whatever manipulations you desire in these functions. As an example of a pre-replacement, consider the following line which implements the double factorial: working = replaceFunctionCalls ( working , 'ffact' , funcToPostfix ( '!!' ) ) This leverages our replaceFunctionCalls and funcToPostfix functions which detect function calls and perform replacements, respectively (a number of other useful functions are included in the javascript file). As an example of a post-replacement, the following line simply replaces a variable name with something that actually looks like a derivative: working = working . replace ( /dphidx/g , '{:(partial phi)/(partial x):}' ); This is a trivial example of using regex to make a replacement; of course, more complicated replacements are also possible. Finally, if you want to introduce new symbols to AsciiMath using unicode, it's simple to do so. Here's an example of how we introduce hbar to the system: // This is hbar, often used in physics AM . newsymbol ({ input : \"hbar\" , tag : \"mo\" , output : \"\\u210F\" , tex : null , ttype : AM . TOKEN . CONST }); Notes # You can take advantage of the symbol definitions and preprocessor even if you're not using the grading library at all. Just load it up in any textline tags you're using. (We find the preprocessor so good that we use if for every math display problem in our courses!) The javascript is constructed to only load its definitions once, no matter how many times the file is loaded. It's safe to use the preprocessor in as many textline boxes as you like. The mathematical functions article provides the complete list of functions that are corrected by the new AsciiMath renderer definitions.","title":"AsciiMath Renderer Definitions"},{"location":"grading_math/renderer/#asciimath-renderer-definitions","text":"When math input is expected from students, edX offers a math preview that attempts to show their expression in normal mathematical notation. There are two ways to provide this preview: <formulaequationinput/> or <textline math= \"1\" /> The formulaequationinput tag uses server-side parsing and rendering to display the preview to the student. By and large, the preview from formulaequationinput is better than that of textline , as it treats functions correctly, and displays a number of LaTeX symbols natively. The downsides to formulaequationinput are that it doesn't recognize vectors such as vecx or hatx , the factorial and conjugation functions just apply as fact(x) and conj(x) , and because the processing is done server-side, we are unable to enhance the display at all. The textline tag treats the student input as AsciiMath for the purpose of generating a preview, using MathJax to render it. While the preview does a reasonably good job, there are many situations where it falls down, even for standard edX functions (for example, try typing in 1/arctanh(x) in a textline box!). Because this is done client-side through javascript, it's possible to supplement the AsciiMath definitions to handle new situations. We have constructed a series of renderer definitions to supplement the standard AsciiMath definitions in order to provide better previews. This article describes how to use our new AsciiMath renderer definitions with a <textline> tag.","title":"AsciiMath Renderer Definitions"},{"location":"grading_math/renderer/#how-it-works","text":"The renderer definitions are located in a javascript file, MJxPrep.js , which should be uploaded to the static assets folder for your course. This javascript file has two components: symbol definitions and a preprocessor. The symbol definitions are used to teach AsciiMath how to display various functions properly, such as re , im , arctanh etc. To load the symbol definitions in a problem, place the following HTML code somewhere in the problem. <script type= \"text/javascript\" src= \"/static/MJxPrep.js\" ></script> Some functions are too complex for a symbol definition, and need the student's input to be preprocessed into AsciiMath before rendering. These functions include log10 , log2 , fact / factorial , trans , adj / ctrans and cross . It is quite common to have a variable name begin with delta or Delta , such as Deltax . Unfortunately, AsciiMath treats such variables as two separate entries, and can sometimes split them inopportunely, such as for the expression 1/Deltax . The preprocessor detects such variable names and ensures that AsciiMath displays them correctly. To use these features, you need to add preprocessorClassName and preprocessorSrc properties to any <textline/> tags that use the preprocessor, such as in the following example. <customresponse cfn= \"grader\" > <textline correct_answer= \"1/fact(5)\" math= \"1\" preprocessorClassName= \"MJxPrep\" preprocessorSrc= \"/static/MJxPrep.js\" /> </customresponse> If you use the preprocessor in your problem, you get the symbol definitions as well (you don't need to load them separately using a script tag).","title":"How it Works"},{"location":"grading_math/renderer/#options","text":"There are a few configurable options for the preprocessor in MJxPrep.js . By default, conj() displays as a bar over the argument to the function. However, you may wish for complex conjugates to be displayed as a superscript star. If so, you can set conj_as_star: true at the start of the file. By default, vectors [1, 2, 3] display as a column vector when the preprocessor is loaded (without the preprocessor, it will display as a row). If you would instead like them to display as a row vector, you can set the option vectors_as_columns: false at the start of the file.","title":"Options"},{"location":"grading_math/renderer/#extending-definitions","text":"If you're building a course that uses math extensively, it's likely that you want to use some sort of symbol that can't be written in the form of an edX variable. In this situation, we have provided two functions to extend the preprocessor. At the bottom of MJxPrep.js , you will find the functions customPreReplacements and customPostReplacements , which are called before and after our preprocessing functions occur, respectively. You can perform whatever manipulations you desire in these functions. As an example of a pre-replacement, consider the following line which implements the double factorial: working = replaceFunctionCalls ( working , 'ffact' , funcToPostfix ( '!!' ) ) This leverages our replaceFunctionCalls and funcToPostfix functions which detect function calls and perform replacements, respectively (a number of other useful functions are included in the javascript file). As an example of a post-replacement, the following line simply replaces a variable name with something that actually looks like a derivative: working = working . replace ( /dphidx/g , '{:(partial phi)/(partial x):}' ); This is a trivial example of using regex to make a replacement; of course, more complicated replacements are also possible. Finally, if you want to introduce new symbols to AsciiMath using unicode, it's simple to do so. Here's an example of how we introduce hbar to the system: // This is hbar, often used in physics AM . newsymbol ({ input : \"hbar\" , tag : \"mo\" , output : \"\\u210F\" , tex : null , ttype : AM . TOKEN . CONST });","title":"Extending Definitions"},{"location":"grading_math/renderer/#notes","text":"You can take advantage of the symbol definitions and preprocessor even if you're not using the grading library at all. Just load it up in any textline tags you're using. (We find the preprocessor so good that we use if for every math display problem in our courses!) The javascript is constructed to only load its definitions once, no matter how many times the file is loaded. It's safe to use the preprocessor in as many textline boxes as you like. The mathematical functions article provides the complete list of functions that are corrected by the new AsciiMath renderer definitions.","title":"Notes"},{"location":"grading_math/sampling/","text":"Sampling # Whenever random variables/functions are involved, they need to be sampled from an appropriate distribution. In this library, distributions are defined in classes that are called sampling sets . We have defined a number of sampling sets for various common situations, but you can also create your own by using plugins. These sampling classes are available for use in FormulaGrader , MatrixGrader , etc. Variable Sampling: Numbers (Scalars) # These sampling sets generate a random number on demand. It may be real or complex. RealInterval # Sample from a real interval defined by a start and a stop value. RealInterval can be initialized using explicit values, or an interval. >>> from mitxgraders import * >>> # Generate random real numbers between 3 and 7 >>> sampler = RealInterval ( start = 3 , stop = 7 ) >>> # This is equivalent to >>> sampler = RealInterval ([ 3 , 7 ]) >>> # The default is [1, 5] >>> RealInterval () == RealInterval ([ 1 , 5 ]) True >>> # A list can also be used to specify an interval >>> sampler = [ 3 , 7 ] IntegerRange # Sample from an integer defined by a start and a stop value (both start and stop are included in the range). IntegerRange can be initialized using explicit values, or an interval. >>> # Generate random integers between 3 and 7 inclusive >>> sampler = IntegerRange ( start = 3 , stop = 7 ) >>> # This is equivalent to >>> sampler = IntegerRange ([ 3 , 7 ]) >>> # The default is [1, 5] >>> IntegerRange () == IntegerRange ([ 1 , 5 ]) True ComplexRectangle # Sample complex numbers from a rectangle in the complex plane, specified by a real range and an imaginary range. >>> # Select random complex numbers in a rectangle from 0 to 1 + i >>> sampler = ComplexRectangle ( re = [ 0 , 1 ], im = [ 0 , 1 ]) >>> # The default is re=[1, 3], im=[1, 3] >>> ComplexRectangle () == ComplexRectangle ( re = [ 1 , 3 ], im = [ 1 , 3 ]) True ComplexSector # Sample complex numbers from an annular sector in the complex plane, specified by a modulus range and an argument range. >>> import numpy as np >>> # Select random complex numbers from inside the unit circle >>> sampler = ComplexSector ( modulus = [ 0 , 1 ], argument = [ - np . pi , np . pi ]) >>> # The default is modulus=[1, 3], argument=[0, pi/2] >>> ComplexSector () == ComplexSector ( modulus = [ 1 , 3 ], argument = [ 0 , np . pi / 2 ]) True Variable Sampling: Vectors, Matrices and Tensors # We have a broad range of sampling sets for vectors, matrices and tensors. The following options are common to many of these sets: shape : Either be a number (to specify a vector of that dimension), or a tuple or list of numbers (to specify a matrix/tensor with those dimensions). norm : Specify a RealInterval for the norm of the object. (Frobenius norm is used.) If you want to sample a vector/matrix/tensor in a way that depends on a scalar, see DependentSampler below. RealVectors and ComplexVectors # Sample real/complex vectors with specified shape (number of components) and norm. >>> # Sample real vectors with 4 components and unit norm >>> sampler = RealVectors ( shape = 4 , norm = [ 1 , 1 ]) >>> # The default is 3 component vectors with norm from 1 to 5 >>> RealVectors () == RealVectors ( shape = 3 , norm = [ 1 , 5 ]) True >>> # Similarly for complex vectors >>> ComplexVectors () == ComplexVectors ( shape = 3 , norm = [ 1 , 5 ]) True RealMatrices and ComplexMatrices # Sample real/complex matrices of a specific shape and norm. An extra option exists to specify that the matrix be upper or lower triangular. The given shape must be a list or tuple of two numbers. >>> # Sample 3 by 2 real matrices with norm between 5 and 10 >>> sampler = RealMatrices ( shape = [ 3 , 2 ], norm = [ 5 , 10 ]) >>> # The default is shape=[2, 2] and norm=[1, 5] >>> RealMatrices () == RealMatrices ({ 'norm' : [ 1 , 5 ], 'shape' : ( 2 , 2 )}) True >>> # Similarly for complex matrices >>> ComplexMatrices () == ComplexMatrices ({ 'norm' : [ 1 , 5 ], 'shape' : ( 2 , 2 )}) True >>> # Sample an upper triangular real 2x2 matrix. >>> sampler = RealMatrices ( triangular = 'upper' ) >>> # Sample a lower triangular complex 2x2 matrix. >>> sampler = ComplexMatrices ( triangular = 'lower' ) RealTensors and ComplexTensors # Sample real/complex tensors of a specific shape and norm. A shape must be provided as a list or tuple of three or more numbers (there is no default). >>> # Sample 3x2x4 real tensors with norm between 5 and 10 >>> sampler = RealTensors ( shape = [ 3 , 2 , 4 ], norm = [ 5 , 10 ]) >>> # Sample 2x2x2x2 complex tensors with unit norm >>> sampler = ComplexTensors ( shape = [ 2 , 2 , 2 , 2 ], norm = [ 1 , 1 ]) IdentityMatrixMultiples # Sample square matrices of a given dimension consisting of the identity matrix multiplied by a scalar. The sampler parameter can be any scalar sampling set listed above. This sampling set is useful when you want a variable that will commute with other matrices, but can also be added to them. >>> # Sample 3x3 matrices consisting of a random number between 1 and 3 multiplying the identity >>> sampler = IdentityMatrixMultiples ( dimension = 3 , sampler = [ 1 , 3 ]) >>> # The default is dimension=2 and sampler=[1, 5] >>> IdentityMatrixMultiples () == IdentityMatrixMultiples ( dimension = 2 , sampler = [ 1 , 5 ]) True SquareMatrices # This is a general sampling set for square matrices. A large number of options for specifying properties of square matrices are included: dimension (int): Specify the number of dimensions of the matrix (default 2) complex (bool): Should the matrix be complex (True) or real (False, default) (ignored if hermitian or antihermitian are selected) traceless (bool): Whether or not the matrix should be traceless (default False) determinant (None | 0 | 1): Specify the determinant of the matrix (default None for no restriction) symmetry : Choose from the following symmetries: None , 'diagonal' , 'symmetric' , 'antisymmetric' , 'hermitian' , 'antihermitian' (default None ) norm (float): Specify a RealInterval to sample the norm of the matrix (default [1, 5] ; ignored if determinant=1 is specified) Note that some combinations of options do not exist (e.g., odd-dimension, unit-determinant antisymmetric matrix). If you select such a combination, an error message will result. Other types of square matrices can be sampled using RealMatrices , ComplexMatrices , IdentityMatrixMultiples , OrthogonalMatrices and UnitaryMatrices . Here are a handful of examples: >>> # By default, we generate real 2x2 matrices with no restrictions: >>> SquareMatrices () == SquareMatrices ( dimension = 2 , complex = False , traceless = False , determinant = None , symmetry = None , norm = [ 1 , 5 ]) True >>> # Diagonal, complex, traceless and unit determinant >>> matrices = SquareMatrices ( symmetry = 'diagonal' , complex = True , traceless = True , ... determinant = 1 ) >>> # Symmetric, real, zero determinant >>> matrices = SquareMatrices ( symmetry = 'symmetric' , determinant = 0 ) >>> # Hermitian (enforces complex) >>> matrices = SquareMatrices ( symmetry = 'hermitian' ) OrthogonalMatrices # Sample from orthogonal matrices of a given dimension. To sample special orthogonal matrices (unit determinant), use the unitdet=True option. >>> # Sample 3x3 orthogonal matrices with unit determinant >>> sampler = OrthogonalMatrices ( dimension = 3 , unitdet = True ) >>> # The default is dimension=2 and unitdet=False >>> OrthogonalMatrices () == OrthogonalMatrices ( dimension = 2 , unitdet = False ) True Note Orthogonal matrix sampling only works on versions of edX running python 3.5, which went live on edx.org around July 2020. You can see which version of python your edX server is running by turning on debug=True in any grader and submitting a response. UnitaryMatrices # Sample from unitary matrices of a given dimension. To sample special unitary matrices (unit determinant), use the unitdet=True option. >>> # Sample 3x3 unitary matrices with unit determinant >>> sampler = UnitaryMatrices ( dimension = 3 , unitdet = True ) >>> # The default is dimension=2 and unitdet=False >>> UnitaryMatrices () == UnitaryMatrices ( dimension = 2 , unitdet = False ) True Note Unitary matrix sampling only works on versions of edX running python 3.5, which went live on edx.org around July 2020. You can see which version of python your edX server is running by turning on debug=True in any grader and submitting a response. Variable Sampling: Generic # DiscreteSet # Sample from any discrete set of values that are specified in a tuple. A single value may also be provided, but this case should usually be specified as a constant instead of as a sampling set. >>> # Select random numbers from (1, 3, 5, 7, 9) >>> sampler = DiscreteSet (( 1 , 3 , 5 , 7 , 9 )) >>> # Always select 3.5 >>> sampler = DiscreteSet ( 3.5 ) >>> # This is equivalent to the above: >>> sampler = 3.5 >>> # A tuple can also be used to specify a discrete set >>> sampler = ( 1 , 3 , 5 , 7 , 9 ) >>> # Select randomly between two matrices >>> sampler = DiscreteSet (( MathArray ([[ 1 , 0 ], [ 0 , 1 ]]), MathArray ([[ 0 , 1 ], [ 1 , 0 ]]))) DependentSampler # Compute a value for a variable based on the values of other constants/variables. The sampler is simply initialized with the desired formula, which can use any base or user-defined functions (except for randomly sampled functions, see below). DependentSampler s can depend on other dependent variables. If you construct a self-referential chain, an error will occur. Note that DependentSampler can depend on vector/matrix quantities as well as scalars. You can even use sibling variables in a DependentSampler (but if you do so, we strongly recommend making such variables instructor variables!). >>> # Set radius based on the random values of x, y and z >>> sampler = DependentSampler ( formula = \"sqrt(x^2+y^2+z^2)\" ) >>> # Construct a matrix that depends on a variable >>> sampler = DependentSampler ( formula = \"[[x,0],[0,-x^2]]\" ) Note Previous versions required a list of variables that the formula depends on to be passed to DependentSampler using the depends key. This is now obsolete, as this variable list is dynamically inferred. Anything passed to the depends key is now ignored. Function Sampling # We have two methods for selecting a random function. SpecificFunctions # Samples functions from a specific list of functions. You can also specify just a single function, but usually this shouldn't be done as a sampling set. >>> # Select either sin or cos randomly >>> functionsampler = SpecificFunctions ([ np . cos , np . sin ]) >>> # Equivalent sampling set specified as a list >>> functionsampler = [ np . cos , np . sin ] >>> # Always select a single lambda function >>> functionsampler = SpecificFunctions ( lambda x : x * x ) RandomFunction # Generate a random well-behaved function. The function is constructed from the sum of sinusoids with random amplitudes, frequencies and phases. It oscillates about a specified center value with up to a specified amplitude. >>> # Generate a random function >>> functionsampler = RandomFunction ( center = 1 , amplitude = 2 ) >>> # The default is center=0, amplitude=10 >>> functionsampler = RandomFunction () You can control how many random sinusoids are added together by specifying num_terms . >>> # Generate a random sinusoid >>> functionsampler = RandomFunction ( num_terms = 1 ) You can also generate a non-unary function by specifying the input dimension, and generate vector output by specifying the output dimension. >>> # Generate a function that takes in two scalar values and outputs a 3D vector >>> functionsampler = RandomFunction ( input_dim = 2 , output_dim = 3 ) Finally, if you want to generate a complex random function, set complex=True . In this situation, the randomly generated function works as previously, but the sinusoid coefficients are complex numbers. >>> functionsampler = RandomFunction ( complex = True ) Note You cannot invoke a random functions within a DependentSampler . This is a limitation of the way that we have implemented random functions.","title":"Sampling Sets"},{"location":"grading_math/sampling/#sampling","text":"Whenever random variables/functions are involved, they need to be sampled from an appropriate distribution. In this library, distributions are defined in classes that are called sampling sets . We have defined a number of sampling sets for various common situations, but you can also create your own by using plugins. These sampling classes are available for use in FormulaGrader , MatrixGrader , etc.","title":"Sampling"},{"location":"grading_math/sampling/#variable-sampling-numbers-scalars","text":"These sampling sets generate a random number on demand. It may be real or complex.","title":"Variable Sampling: Numbers (Scalars)"},{"location":"grading_math/sampling/#realinterval","text":"Sample from a real interval defined by a start and a stop value. RealInterval can be initialized using explicit values, or an interval. >>> from mitxgraders import * >>> # Generate random real numbers between 3 and 7 >>> sampler = RealInterval ( start = 3 , stop = 7 ) >>> # This is equivalent to >>> sampler = RealInterval ([ 3 , 7 ]) >>> # The default is [1, 5] >>> RealInterval () == RealInterval ([ 1 , 5 ]) True >>> # A list can also be used to specify an interval >>> sampler = [ 3 , 7 ]","title":"RealInterval"},{"location":"grading_math/sampling/#integerrange","text":"Sample from an integer defined by a start and a stop value (both start and stop are included in the range). IntegerRange can be initialized using explicit values, or an interval. >>> # Generate random integers between 3 and 7 inclusive >>> sampler = IntegerRange ( start = 3 , stop = 7 ) >>> # This is equivalent to >>> sampler = IntegerRange ([ 3 , 7 ]) >>> # The default is [1, 5] >>> IntegerRange () == IntegerRange ([ 1 , 5 ]) True","title":"IntegerRange"},{"location":"grading_math/sampling/#complexrectangle","text":"Sample complex numbers from a rectangle in the complex plane, specified by a real range and an imaginary range. >>> # Select random complex numbers in a rectangle from 0 to 1 + i >>> sampler = ComplexRectangle ( re = [ 0 , 1 ], im = [ 0 , 1 ]) >>> # The default is re=[1, 3], im=[1, 3] >>> ComplexRectangle () == ComplexRectangle ( re = [ 1 , 3 ], im = [ 1 , 3 ]) True","title":"ComplexRectangle"},{"location":"grading_math/sampling/#complexsector","text":"Sample complex numbers from an annular sector in the complex plane, specified by a modulus range and an argument range. >>> import numpy as np >>> # Select random complex numbers from inside the unit circle >>> sampler = ComplexSector ( modulus = [ 0 , 1 ], argument = [ - np . pi , np . pi ]) >>> # The default is modulus=[1, 3], argument=[0, pi/2] >>> ComplexSector () == ComplexSector ( modulus = [ 1 , 3 ], argument = [ 0 , np . pi / 2 ]) True","title":"ComplexSector"},{"location":"grading_math/sampling/#variable-sampling-vectors-matrices-and-tensors","text":"We have a broad range of sampling sets for vectors, matrices and tensors. The following options are common to many of these sets: shape : Either be a number (to specify a vector of that dimension), or a tuple or list of numbers (to specify a matrix/tensor with those dimensions). norm : Specify a RealInterval for the norm of the object. (Frobenius norm is used.) If you want to sample a vector/matrix/tensor in a way that depends on a scalar, see DependentSampler below.","title":"Variable Sampling: Vectors, Matrices and Tensors"},{"location":"grading_math/sampling/#realvectors-and-complexvectors","text":"Sample real/complex vectors with specified shape (number of components) and norm. >>> # Sample real vectors with 4 components and unit norm >>> sampler = RealVectors ( shape = 4 , norm = [ 1 , 1 ]) >>> # The default is 3 component vectors with norm from 1 to 5 >>> RealVectors () == RealVectors ( shape = 3 , norm = [ 1 , 5 ]) True >>> # Similarly for complex vectors >>> ComplexVectors () == ComplexVectors ( shape = 3 , norm = [ 1 , 5 ]) True","title":"RealVectors and ComplexVectors"},{"location":"grading_math/sampling/#realmatrices-and-complexmatrices","text":"Sample real/complex matrices of a specific shape and norm. An extra option exists to specify that the matrix be upper or lower triangular. The given shape must be a list or tuple of two numbers. >>> # Sample 3 by 2 real matrices with norm between 5 and 10 >>> sampler = RealMatrices ( shape = [ 3 , 2 ], norm = [ 5 , 10 ]) >>> # The default is shape=[2, 2] and norm=[1, 5] >>> RealMatrices () == RealMatrices ({ 'norm' : [ 1 , 5 ], 'shape' : ( 2 , 2 )}) True >>> # Similarly for complex matrices >>> ComplexMatrices () == ComplexMatrices ({ 'norm' : [ 1 , 5 ], 'shape' : ( 2 , 2 )}) True >>> # Sample an upper triangular real 2x2 matrix. >>> sampler = RealMatrices ( triangular = 'upper' ) >>> # Sample a lower triangular complex 2x2 matrix. >>> sampler = ComplexMatrices ( triangular = 'lower' )","title":"RealMatrices and ComplexMatrices"},{"location":"grading_math/sampling/#realtensors-and-complextensors","text":"Sample real/complex tensors of a specific shape and norm. A shape must be provided as a list or tuple of three or more numbers (there is no default). >>> # Sample 3x2x4 real tensors with norm between 5 and 10 >>> sampler = RealTensors ( shape = [ 3 , 2 , 4 ], norm = [ 5 , 10 ]) >>> # Sample 2x2x2x2 complex tensors with unit norm >>> sampler = ComplexTensors ( shape = [ 2 , 2 , 2 , 2 ], norm = [ 1 , 1 ])","title":"RealTensors and ComplexTensors"},{"location":"grading_math/sampling/#identitymatrixmultiples","text":"Sample square matrices of a given dimension consisting of the identity matrix multiplied by a scalar. The sampler parameter can be any scalar sampling set listed above. This sampling set is useful when you want a variable that will commute with other matrices, but can also be added to them. >>> # Sample 3x3 matrices consisting of a random number between 1 and 3 multiplying the identity >>> sampler = IdentityMatrixMultiples ( dimension = 3 , sampler = [ 1 , 3 ]) >>> # The default is dimension=2 and sampler=[1, 5] >>> IdentityMatrixMultiples () == IdentityMatrixMultiples ( dimension = 2 , sampler = [ 1 , 5 ]) True","title":"IdentityMatrixMultiples"},{"location":"grading_math/sampling/#squarematrices","text":"This is a general sampling set for square matrices. A large number of options for specifying properties of square matrices are included: dimension (int): Specify the number of dimensions of the matrix (default 2) complex (bool): Should the matrix be complex (True) or real (False, default) (ignored if hermitian or antihermitian are selected) traceless (bool): Whether or not the matrix should be traceless (default False) determinant (None | 0 | 1): Specify the determinant of the matrix (default None for no restriction) symmetry : Choose from the following symmetries: None , 'diagonal' , 'symmetric' , 'antisymmetric' , 'hermitian' , 'antihermitian' (default None ) norm (float): Specify a RealInterval to sample the norm of the matrix (default [1, 5] ; ignored if determinant=1 is specified) Note that some combinations of options do not exist (e.g., odd-dimension, unit-determinant antisymmetric matrix). If you select such a combination, an error message will result. Other types of square matrices can be sampled using RealMatrices , ComplexMatrices , IdentityMatrixMultiples , OrthogonalMatrices and UnitaryMatrices . Here are a handful of examples: >>> # By default, we generate real 2x2 matrices with no restrictions: >>> SquareMatrices () == SquareMatrices ( dimension = 2 , complex = False , traceless = False , determinant = None , symmetry = None , norm = [ 1 , 5 ]) True >>> # Diagonal, complex, traceless and unit determinant >>> matrices = SquareMatrices ( symmetry = 'diagonal' , complex = True , traceless = True , ... determinant = 1 ) >>> # Symmetric, real, zero determinant >>> matrices = SquareMatrices ( symmetry = 'symmetric' , determinant = 0 ) >>> # Hermitian (enforces complex) >>> matrices = SquareMatrices ( symmetry = 'hermitian' )","title":"SquareMatrices"},{"location":"grading_math/sampling/#orthogonalmatrices","text":"Sample from orthogonal matrices of a given dimension. To sample special orthogonal matrices (unit determinant), use the unitdet=True option. >>> # Sample 3x3 orthogonal matrices with unit determinant >>> sampler = OrthogonalMatrices ( dimension = 3 , unitdet = True ) >>> # The default is dimension=2 and unitdet=False >>> OrthogonalMatrices () == OrthogonalMatrices ( dimension = 2 , unitdet = False ) True Note Orthogonal matrix sampling only works on versions of edX running python 3.5, which went live on edx.org around July 2020. You can see which version of python your edX server is running by turning on debug=True in any grader and submitting a response.","title":"OrthogonalMatrices"},{"location":"grading_math/sampling/#unitarymatrices","text":"Sample from unitary matrices of a given dimension. To sample special unitary matrices (unit determinant), use the unitdet=True option. >>> # Sample 3x3 unitary matrices with unit determinant >>> sampler = UnitaryMatrices ( dimension = 3 , unitdet = True ) >>> # The default is dimension=2 and unitdet=False >>> UnitaryMatrices () == UnitaryMatrices ( dimension = 2 , unitdet = False ) True Note Unitary matrix sampling only works on versions of edX running python 3.5, which went live on edx.org around July 2020. You can see which version of python your edX server is running by turning on debug=True in any grader and submitting a response.","title":"UnitaryMatrices"},{"location":"grading_math/sampling/#variable-sampling-generic","text":"","title":"Variable Sampling: Generic"},{"location":"grading_math/sampling/#discreteset","text":"Sample from any discrete set of values that are specified in a tuple. A single value may also be provided, but this case should usually be specified as a constant instead of as a sampling set. >>> # Select random numbers from (1, 3, 5, 7, 9) >>> sampler = DiscreteSet (( 1 , 3 , 5 , 7 , 9 )) >>> # Always select 3.5 >>> sampler = DiscreteSet ( 3.5 ) >>> # This is equivalent to the above: >>> sampler = 3.5 >>> # A tuple can also be used to specify a discrete set >>> sampler = ( 1 , 3 , 5 , 7 , 9 ) >>> # Select randomly between two matrices >>> sampler = DiscreteSet (( MathArray ([[ 1 , 0 ], [ 0 , 1 ]]), MathArray ([[ 0 , 1 ], [ 1 , 0 ]])))","title":"DiscreteSet"},{"location":"grading_math/sampling/#dependentsampler","text":"Compute a value for a variable based on the values of other constants/variables. The sampler is simply initialized with the desired formula, which can use any base or user-defined functions (except for randomly sampled functions, see below). DependentSampler s can depend on other dependent variables. If you construct a self-referential chain, an error will occur. Note that DependentSampler can depend on vector/matrix quantities as well as scalars. You can even use sibling variables in a DependentSampler (but if you do so, we strongly recommend making such variables instructor variables!). >>> # Set radius based on the random values of x, y and z >>> sampler = DependentSampler ( formula = \"sqrt(x^2+y^2+z^2)\" ) >>> # Construct a matrix that depends on a variable >>> sampler = DependentSampler ( formula = \"[[x,0],[0,-x^2]]\" ) Note Previous versions required a list of variables that the formula depends on to be passed to DependentSampler using the depends key. This is now obsolete, as this variable list is dynamically inferred. Anything passed to the depends key is now ignored.","title":"DependentSampler"},{"location":"grading_math/sampling/#function-sampling","text":"We have two methods for selecting a random function.","title":"Function Sampling"},{"location":"grading_math/sampling/#specificfunctions","text":"Samples functions from a specific list of functions. You can also specify just a single function, but usually this shouldn't be done as a sampling set. >>> # Select either sin or cos randomly >>> functionsampler = SpecificFunctions ([ np . cos , np . sin ]) >>> # Equivalent sampling set specified as a list >>> functionsampler = [ np . cos , np . sin ] >>> # Always select a single lambda function >>> functionsampler = SpecificFunctions ( lambda x : x * x )","title":"SpecificFunctions"},{"location":"grading_math/sampling/#randomfunction","text":"Generate a random well-behaved function. The function is constructed from the sum of sinusoids with random amplitudes, frequencies and phases. It oscillates about a specified center value with up to a specified amplitude. >>> # Generate a random function >>> functionsampler = RandomFunction ( center = 1 , amplitude = 2 ) >>> # The default is center=0, amplitude=10 >>> functionsampler = RandomFunction () You can control how many random sinusoids are added together by specifying num_terms . >>> # Generate a random sinusoid >>> functionsampler = RandomFunction ( num_terms = 1 ) You can also generate a non-unary function by specifying the input dimension, and generate vector output by specifying the output dimension. >>> # Generate a function that takes in two scalar values and outputs a 3D vector >>> functionsampler = RandomFunction ( input_dim = 2 , output_dim = 3 ) Finally, if you want to generate a complex random function, set complex=True . In this situation, the randomly generated function works as previously, but the sinusoid coefficients are complex numbers. >>> functionsampler = RandomFunction ( complex = True ) Note You cannot invoke a random functions within a DependentSampler . This is a limitation of the way that we have implemented random functions.","title":"RandomFunction"},{"location":"grading_math/sum_grader/","text":"SumGrader # SumGrader is a specialized grading class used to grade the construction of summations. Students can input the limits on the sum, the variable of summation, and the summand (or some subset thereof), and will be graded correct if their construction is numerically equivalent to the instructor's construction. This method of grading allows for arbitrary variable redefinitions. The grader numerically evaluates the student- and instructor-specified summations by evaluating the sums. Care must be taken to ensure rapid convergence with infinite summations, of which only finitely many terms can be numerically summed. XML Setup # We recommend copying the following XML to set up a problem using SumGrader : <style> .xmodule_display.xmodule_ProblemBlock .problem .capa_inputtype.textline input { min-width: 0 !important; } .xmodule_display.xmodule_ProblemBlock div.problem section div span.MathJax { display: inline-block !important; } .xmodule_display.xmodule_ProblemBlock div.problem section div span.MathJax_Preview { display: inline-block !important; } </style> <span> <customresponse cfn= \"grader\" > <table> <col style= \"width:10%\" /> <col style= \"width:90%\" /> <tbody> <tr> <td colspan= \"2\" > <textline size= \"5\" correct_answer= \"10\" /> </td> </tr> <tr> <td> <p> \\( \\displaystyle \\huge{ \\sum }\\) </p> </td> <td> <br/> <textline inline= \"1\" size= \"10\" correct_answer= \"n\" math= \"1\" preprocessorClassName= \"MJxPrep\" preprocessorSrc= \"/static/MJxPrep.js\" /> </td> </tr> <tr> <td colspan= \"2\" > <p style= \"display: inline;\" > [mathjaxinline]n = [/mathjaxinline] </p><textline size= \"5\" correct_answer= \"0\" inline= \"1\" /> </td> </tr> </tbody> </table> </customresponse> </span> This sets up a summation where students can input the limits of summation and the summand (the variable of summation has been fixed to be n in this case). Further examples of formatting summations are shown in the example course. Specifying the Input Format # The grader must be told which input is what, based on the order that the inputs appear in the XML. This is done through the input_positions dictionary. If not specified, it is assumed that the following positions are used: input_positions = { 'lower' : 1 , 'upper' : 2 , 'summand' : 3 , 'summation_variable' : 4 } This requires students to enter all four parameters in the indicated order. If the author overrides the default input_positions value, any subset of the keys ('lower', 'upper', 'summand', 'summation_variable') may be specified. Key values should be continuous integers starting at 1, or (default) None, indicating that the parameter is not entered by student For example, input_positions = { 'lower' : 1 , 'upper' : 2 , 'summand' : 3 } indicates that the problem has 3 input boxes which represent the lower limit, upper limit, and summand in that order. The summation_variable is NOT entered by student and is instead given by the value specified by author in 'answers'. Here is a sample grader for the above XML: >>> from mitxgraders import * >>> grader = SumGrader ( ... answers = { ... 'lower' : '0' , ... 'upper' : '10' , ... 'summand' : 'n*(n+1)' , ... 'summation_variable' : 'n' ... }, ... input_positions = { ... 'upper' : 1 , ... 'summand' : 2 , ... 'lower' : 3 ... } ... ) Note that when students specify their own variable of summation, it must not conflict with a variable already present in the problem. Note that this means that i and j are not available as variables of summation (as they are used to indicate the imaginary unit). Specifying the Answer # The author's answer should be specified as a dictionary with the following keys: answers = { 'lower' : 'lower_limit' , 'upper' : 'upper_limit' , 'summand' : 'summand' , 'summation_variable' : 'variable_of_summation' } Note that each entry is a string value. SumGrader can handle numerical, complex, vector and even matrix summands. However, it cannot handle numbered variables where the index of the numbered variable is given by the summation variable. This is due to a limitation in the way that numbered variables are sampled. Unlike integrals, the order of the limits is unimportant. Infinite Sums # SumGrader can handle sums over both finite and infinite ranges. A special constant 'infty' is recognized to cater for the infinite case (and takes on the special value float('inf') ). When an infinite range is specified, the grader substitutes infty for a large but finite number. This value can be set using the inft_val option, which defaults to 1000 ( 1e3 ). If the grader detects the presence of the factorial function in the summand, it instead uses the value specified by the infty_val_fact , which defaults to 80. Note that (2*80)! = 160! ~ 10^284 is just below the limit of values that can be handled numerically by double precision. This ensures that typical expressions involving factorials will not lead to overflow errors, and also leaves sufficient terms to ensure convergence. Because infinite sums can be rewritten in a myriad of ways, it is important to ensure that after sufficiently many terms are computed, the summation has converged to within numerical precision. This often means that extra variables must be specified in a small range. E.g., if x is included in the summand as x^n , we recommend setting x in the range [0,0.5] or so. Note that 0.5^80 ~ 10^-25 , which should be sufficiently small compared to the leading order terms. To aid in grading infinite sums, the default tolerance on a SumGrader has been set to an absolute value of 1e-12 . This may be important when the answer provided by the instructor includes twice or half as many terms as the answer provided by the student, even though both sums are equivalent when taken to infinity. So long as infinite summations converge sufficiently rapidly, SumGrader does a good job at evaluating them. As examples, we have tested that Taylor series expansions for exp , sin and cos converge to numerical precision for small arguments. We advise against using SumGrader for slowly-converging series, such as the typical expansion for tan^-1(1) . Note that if you are using vectors or matrices in your sums, we strongly suggest that you use a small value for both infty_val and infty_val_fact , probably in the 15-20 range. Otherwise, you may see timeout errors from the python grader on edX. Even and Odd Sums # SumGrader can be told to sum only over even or odd integers through the even_odd option. The default value is 0, which indicates to sum over all integers. Setting it to 1 indicates to sum over odd integers, and 2 indicates to sum over even integers. Instructors must specify this option at construction; students are unable to set this option themselves. Here is a sample grader that implements the Taylor expansion for sine using odd integers only: >>> from mitxgraders import * >>> grader = SumGrader ( ... answers = { ... 'lower' : '1' , ... 'upper' : 'infty' , ... 'summand' : '(-1)^((n-1)/2)*x^n/fact(n)' , ... 'summation_variable' : 'n' ... }, ... input_positions = { ... 'upper' : 1 , ... 'summand' : 2 , ... 'lower' : 3 ... }, ... even_odd = 1 ... ) Other Options # The following options from FormulaGrader are available for use in SumGrader : user_constants user_functions whitelist blacklist tolerance samples (default: 2) variables sample_from failable_evals numbered_vars instructor_vars forbidden_strings forbidden_message required_functions metric_suffixes Unless otherwise specified, the defaults are the same as in FormulaGrader . Option Listing # Here is the full list of options specific to an SumGrader . grader = SumGrader ( input_positions = dict , answers = dict , even_odd = int , # default 0 infty_val = int , # default 1000 inftY_val_fact = int , # default 80 # The below options are the same as in FormulaGrader variables = list , # default [] sample_from = dict , # default {} samples = int , # default 1 user_functions = dict , # default {} user_constants = dict , # default {} failable_evals = int , # default 0 blacklist = list , # default [] whitelist = list , # default [] tolerance = ( float | percentage ), # default 1e-12 numbered_vars = list , # default [] instructor_vars = list , # default [] forbidden_strings = list , # default [] forbidden_message = str , # default 'Invalid Input: This particular answer is forbidden' required_functions = list , # default [] metric_suffixes = bool , # default False )","title":"SumGrader"},{"location":"grading_math/sum_grader/#sumgrader","text":"SumGrader is a specialized grading class used to grade the construction of summations. Students can input the limits on the sum, the variable of summation, and the summand (or some subset thereof), and will be graded correct if their construction is numerically equivalent to the instructor's construction. This method of grading allows for arbitrary variable redefinitions. The grader numerically evaluates the student- and instructor-specified summations by evaluating the sums. Care must be taken to ensure rapid convergence with infinite summations, of which only finitely many terms can be numerically summed.","title":"SumGrader"},{"location":"grading_math/sum_grader/#xml-setup","text":"We recommend copying the following XML to set up a problem using SumGrader : <style> .xmodule_display.xmodule_ProblemBlock .problem .capa_inputtype.textline input { min-width: 0 !important; } .xmodule_display.xmodule_ProblemBlock div.problem section div span.MathJax { display: inline-block !important; } .xmodule_display.xmodule_ProblemBlock div.problem section div span.MathJax_Preview { display: inline-block !important; } </style> <span> <customresponse cfn= \"grader\" > <table> <col style= \"width:10%\" /> <col style= \"width:90%\" /> <tbody> <tr> <td colspan= \"2\" > <textline size= \"5\" correct_answer= \"10\" /> </td> </tr> <tr> <td> <p> \\( \\displaystyle \\huge{ \\sum }\\) </p> </td> <td> <br/> <textline inline= \"1\" size= \"10\" correct_answer= \"n\" math= \"1\" preprocessorClassName= \"MJxPrep\" preprocessorSrc= \"/static/MJxPrep.js\" /> </td> </tr> <tr> <td colspan= \"2\" > <p style= \"display: inline;\" > [mathjaxinline]n = [/mathjaxinline] </p><textline size= \"5\" correct_answer= \"0\" inline= \"1\" /> </td> </tr> </tbody> </table> </customresponse> </span> This sets up a summation where students can input the limits of summation and the summand (the variable of summation has been fixed to be n in this case). Further examples of formatting summations are shown in the example course.","title":"XML Setup"},{"location":"grading_math/sum_grader/#specifying-the-input-format","text":"The grader must be told which input is what, based on the order that the inputs appear in the XML. This is done through the input_positions dictionary. If not specified, it is assumed that the following positions are used: input_positions = { 'lower' : 1 , 'upper' : 2 , 'summand' : 3 , 'summation_variable' : 4 } This requires students to enter all four parameters in the indicated order. If the author overrides the default input_positions value, any subset of the keys ('lower', 'upper', 'summand', 'summation_variable') may be specified. Key values should be continuous integers starting at 1, or (default) None, indicating that the parameter is not entered by student For example, input_positions = { 'lower' : 1 , 'upper' : 2 , 'summand' : 3 } indicates that the problem has 3 input boxes which represent the lower limit, upper limit, and summand in that order. The summation_variable is NOT entered by student and is instead given by the value specified by author in 'answers'. Here is a sample grader for the above XML: >>> from mitxgraders import * >>> grader = SumGrader ( ... answers = { ... 'lower' : '0' , ... 'upper' : '10' , ... 'summand' : 'n*(n+1)' , ... 'summation_variable' : 'n' ... }, ... input_positions = { ... 'upper' : 1 , ... 'summand' : 2 , ... 'lower' : 3 ... } ... ) Note that when students specify their own variable of summation, it must not conflict with a variable already present in the problem. Note that this means that i and j are not available as variables of summation (as they are used to indicate the imaginary unit).","title":"Specifying the Input Format"},{"location":"grading_math/sum_grader/#specifying-the-answer","text":"The author's answer should be specified as a dictionary with the following keys: answers = { 'lower' : 'lower_limit' , 'upper' : 'upper_limit' , 'summand' : 'summand' , 'summation_variable' : 'variable_of_summation' } Note that each entry is a string value. SumGrader can handle numerical, complex, vector and even matrix summands. However, it cannot handle numbered variables where the index of the numbered variable is given by the summation variable. This is due to a limitation in the way that numbered variables are sampled. Unlike integrals, the order of the limits is unimportant.","title":"Specifying the Answer"},{"location":"grading_math/sum_grader/#infinite-sums","text":"SumGrader can handle sums over both finite and infinite ranges. A special constant 'infty' is recognized to cater for the infinite case (and takes on the special value float('inf') ). When an infinite range is specified, the grader substitutes infty for a large but finite number. This value can be set using the inft_val option, which defaults to 1000 ( 1e3 ). If the grader detects the presence of the factorial function in the summand, it instead uses the value specified by the infty_val_fact , which defaults to 80. Note that (2*80)! = 160! ~ 10^284 is just below the limit of values that can be handled numerically by double precision. This ensures that typical expressions involving factorials will not lead to overflow errors, and also leaves sufficient terms to ensure convergence. Because infinite sums can be rewritten in a myriad of ways, it is important to ensure that after sufficiently many terms are computed, the summation has converged to within numerical precision. This often means that extra variables must be specified in a small range. E.g., if x is included in the summand as x^n , we recommend setting x in the range [0,0.5] or so. Note that 0.5^80 ~ 10^-25 , which should be sufficiently small compared to the leading order terms. To aid in grading infinite sums, the default tolerance on a SumGrader has been set to an absolute value of 1e-12 . This may be important when the answer provided by the instructor includes twice or half as many terms as the answer provided by the student, even though both sums are equivalent when taken to infinity. So long as infinite summations converge sufficiently rapidly, SumGrader does a good job at evaluating them. As examples, we have tested that Taylor series expansions for exp , sin and cos converge to numerical precision for small arguments. We advise against using SumGrader for slowly-converging series, such as the typical expansion for tan^-1(1) . Note that if you are using vectors or matrices in your sums, we strongly suggest that you use a small value for both infty_val and infty_val_fact , probably in the 15-20 range. Otherwise, you may see timeout errors from the python grader on edX.","title":"Infinite Sums"},{"location":"grading_math/sum_grader/#even-and-odd-sums","text":"SumGrader can be told to sum only over even or odd integers through the even_odd option. The default value is 0, which indicates to sum over all integers. Setting it to 1 indicates to sum over odd integers, and 2 indicates to sum over even integers. Instructors must specify this option at construction; students are unable to set this option themselves. Here is a sample grader that implements the Taylor expansion for sine using odd integers only: >>> from mitxgraders import * >>> grader = SumGrader ( ... answers = { ... 'lower' : '1' , ... 'upper' : 'infty' , ... 'summand' : '(-1)^((n-1)/2)*x^n/fact(n)' , ... 'summation_variable' : 'n' ... }, ... input_positions = { ... 'upper' : 1 , ... 'summand' : 2 , ... 'lower' : 3 ... }, ... even_odd = 1 ... )","title":"Even and Odd Sums"},{"location":"grading_math/sum_grader/#other-options","text":"The following options from FormulaGrader are available for use in SumGrader : user_constants user_functions whitelist blacklist tolerance samples (default: 2) variables sample_from failable_evals numbered_vars instructor_vars forbidden_strings forbidden_message required_functions metric_suffixes Unless otherwise specified, the defaults are the same as in FormulaGrader .","title":"Other Options"},{"location":"grading_math/sum_grader/#option-listing","text":"Here is the full list of options specific to an SumGrader . grader = SumGrader ( input_positions = dict , answers = dict , even_odd = int , # default 0 infty_val = int , # default 1000 inftY_val_fact = int , # default 80 # The below options are the same as in FormulaGrader variables = list , # default [] sample_from = dict , # default {} samples = int , # default 1 user_functions = dict , # default {} user_constants = dict , # default {} failable_evals = int , # default 0 blacklist = list , # default [] whitelist = list , # default [] tolerance = ( float | percentage ), # default 1e-12 numbered_vars = list , # default [] instructor_vars = list , # default [] forbidden_strings = list , # default [] forbidden_message = str , # default 'Invalid Input: This particular answer is forbidden' required_functions = list , # default [] metric_suffixes = bool , # default False )","title":"Option Listing"},{"location":"grading_math/user_functions/","text":"User-Defined Functions: Arguments, Shapes, and Error Messages # It's possible to construct user-defined functions that take in scalar/vector/matrix arguments, and produce a scalar/vector/matrix appropriately. Example # Suppose we have a MatrixGrader problem in which we want to provide students with a function rot(vector, axis, angle) that rotates a vector about a given axis by a given angle. We can provide such a function with the user_functions configuration key. >>> import numpy as np >>> from mitxgraders import * >>> def rot ( vec , axis , angle ): ... \"\"\" ... Rotate vec by angle around axis. Implemented by Euler-Rodrigues formula: ... https://en.wikipedia.org/wiki/Euler-Rodrigues_formula ... ... Arguments: ... vec: a 3-component MathArray to rotate ... axis: a 3-component MathArray to rotate around ... angle: a number ... \"\"\" ... vec = np . array ( vec ) ... unit_axis = np . array ( axis ) / np . linalg . norm ( axis ) ... a = np . cos ( angle / 2 ) ... omega = unit_axis * np . sin ( angle / 2 ) ... crossed = np . cross ( omega , vec ) ... result = vec + 2 * a * crossed + 2 * np . cross ( omega , crossed ) ... return MathArray ( result ) >>> grader_1 = MatrixGrader ( ... answers = 'rot(v, [0, 0, 1], theta)' , ... variables = [ 'v' , 'theta' ], ... sample_from = { ... 'v' : RealVectors ( shape = 3 ), ... }, ... user_functions = { ... 'rot' : rot ... } ... ) The Problem # Our rot(vec, axis, angle) function works, but if students supply the function above with arguments of incorrect type, they receive unhelpful error messages: >>> try : ... grader_1 ( None , 'rot(v, theta, [0, 0, 1])' ) ... except StudentFacingError as error : ... print ( error ) There was an error evaluating rot(...). Its input does not seem to be in its domain. The Solution # To provide students with more useful error messages, we can use specify_domain , a decorator function imported from mitxgraders . Decorator Functions are \"higher-order functions\" that take functions as input and produce functions as output, usually modifying the input function's behavior. In our case, specify_domain will modify the behavior of rot so as to provide more helpful StudentFacingError s. Here we go: >>> @specify_domain ( input_shapes = [[ 3 ], [ 3 ], [ 1 ]], display_name = 'rot' ) ... def rot_with_error_messages ( vec , axis , angle ): ... # rot(vec, axis, angle) defined above ... return rot ( vec , axis , angle ) >>> # Define new grader using rot_with_error_messages >>> grader_2 = MatrixGrader ( ... answers = 'rot(v, [0, 0, 1], theta)' , ... variables = [ 'v' , 'theta' ], ... sample_from = { ... 'v' : RealVectors ( shape = 3 ), ... }, ... user_functions = { ... 'rot' : rot_with_error_messages ... } ... ) Now if a student calls rot with incorrect inputs, they receive a more helpful message: >>> try : ... grader_2 ( None , 'rot(v, theta, [0, 0, 1])' ) ... except StudentFacingError as error : ... print ( str ( error ) . replace ( '<br/>' , ' \\n ' )) There was an error evaluating function rot(...) 1st input is ok: received a vector of length 3 as expected 2nd input has an error: received a scalar, expected a vector of length 3 3rd input has an error: received a vector of length 3, expected a scalar Configuring specify_domain # The decorator specify_domain accepts optional keyword arguments and should be called in either of two equivalent ways: >>> @specify_domain ( keyword_arguments ) # doctest: +SKIP ... def target_function ( x , y , z ): ... pass # do whatever you want >>> # or, equivalently: >>> def target_function ( x , y , z ): ... pass # do whatever you want >>> decorated_function = specify_domain ( keyword_arguments )( target_function ) # doctest: +SKIP The keyword arguments are: input_shapes : A list that indicates the shape of each input to the target function. This list must have the same length as the number of arguments in the target function. Each list element should be one of the following: 1 : indicates input is scalar k (positive integer > 1): indicates input is a k-component vector [k1, k2, ...] , list of positive integers: means input is an array of shape (k1, k2, ...) (k1, k2, ...) , tuple of positive integers: equivalent to [k1, k2, ...] 'square' (string): indicates a square matrix of any dimension display_name (str): Function name to be used in error messages. Defaults to None , meaning that the function's __name__ attribute is used. So, for example, >>> @specify_domain ( input_shapes = [ 1 , [ 3 , 2 ], 4 ], display_name = 'myfunc' ) ... def some_function ( x , A , v ): ... pass specifies that the function some_func must be called with three arguments: 1st argument: scalar, 2nd argument: 3 by 2 matrix, and a 3rd argument: 4-component vector. Arbitrary Same-Shape Arguments # Some functions may allow an arbitrary number of arguments to be passed in. For example, consider a user-defined minimum function: >>> def my_min ( * args ): ... return min ( * args ) To inform specify_domain that a function should accept arbitrarily many arguments of a certain shape, supply a single shape to input_shapes , and also pass in a min_length parameter, to specify the minimum number of arguments required. (If you specify min_length and have more than one shape in input_shapes , a ConfigError will result.) So, our my_min function can be decorated as follows: >>> @specify_domain ( input_shapes = [ 1 ], display_name = 'min' , min_length = 2 ) ... def my_min ( * args ): ... return min ( * args ) >>> my_min ( 1.5 , 2.3 , 4.6 ) 1.5 >>> try : ... my_min ( 1 ) ... except StudentFacingError as error : ... print ( error ) Wrong number of arguments passed to min(...): Expected at least 2 inputs, but received 1. >>> try : ... my_min ( MathArray ([ 1 , 2 ]), MathArray ([ 3 , 4 ])) ... except StudentFacingError as error : ... print ( error ) There was an error evaluating function min(...) 1st input has an error: received a vector of length 2, expected a scalar 2nd input has an error: received a vector of length 2, expected a scalar","title":"User-Defined Functions"},{"location":"grading_math/user_functions/#user-defined-functions-arguments-shapes-and-error-messages","text":"It's possible to construct user-defined functions that take in scalar/vector/matrix arguments, and produce a scalar/vector/matrix appropriately.","title":"User-Defined Functions: Arguments, Shapes, and Error Messages"},{"location":"grading_math/user_functions/#example","text":"Suppose we have a MatrixGrader problem in which we want to provide students with a function rot(vector, axis, angle) that rotates a vector about a given axis by a given angle. We can provide such a function with the user_functions configuration key. >>> import numpy as np >>> from mitxgraders import * >>> def rot ( vec , axis , angle ): ... \"\"\" ... Rotate vec by angle around axis. Implemented by Euler-Rodrigues formula: ... https://en.wikipedia.org/wiki/Euler-Rodrigues_formula ... ... Arguments: ... vec: a 3-component MathArray to rotate ... axis: a 3-component MathArray to rotate around ... angle: a number ... \"\"\" ... vec = np . array ( vec ) ... unit_axis = np . array ( axis ) / np . linalg . norm ( axis ) ... a = np . cos ( angle / 2 ) ... omega = unit_axis * np . sin ( angle / 2 ) ... crossed = np . cross ( omega , vec ) ... result = vec + 2 * a * crossed + 2 * np . cross ( omega , crossed ) ... return MathArray ( result ) >>> grader_1 = MatrixGrader ( ... answers = 'rot(v, [0, 0, 1], theta)' , ... variables = [ 'v' , 'theta' ], ... sample_from = { ... 'v' : RealVectors ( shape = 3 ), ... }, ... user_functions = { ... 'rot' : rot ... } ... )","title":"Example"},{"location":"grading_math/user_functions/#the-problem","text":"Our rot(vec, axis, angle) function works, but if students supply the function above with arguments of incorrect type, they receive unhelpful error messages: >>> try : ... grader_1 ( None , 'rot(v, theta, [0, 0, 1])' ) ... except StudentFacingError as error : ... print ( error ) There was an error evaluating rot(...). Its input does not seem to be in its domain.","title":"The Problem"},{"location":"grading_math/user_functions/#the-solution","text":"To provide students with more useful error messages, we can use specify_domain , a decorator function imported from mitxgraders . Decorator Functions are \"higher-order functions\" that take functions as input and produce functions as output, usually modifying the input function's behavior. In our case, specify_domain will modify the behavior of rot so as to provide more helpful StudentFacingError s. Here we go: >>> @specify_domain ( input_shapes = [[ 3 ], [ 3 ], [ 1 ]], display_name = 'rot' ) ... def rot_with_error_messages ( vec , axis , angle ): ... # rot(vec, axis, angle) defined above ... return rot ( vec , axis , angle ) >>> # Define new grader using rot_with_error_messages >>> grader_2 = MatrixGrader ( ... answers = 'rot(v, [0, 0, 1], theta)' , ... variables = [ 'v' , 'theta' ], ... sample_from = { ... 'v' : RealVectors ( shape = 3 ), ... }, ... user_functions = { ... 'rot' : rot_with_error_messages ... } ... ) Now if a student calls rot with incorrect inputs, they receive a more helpful message: >>> try : ... grader_2 ( None , 'rot(v, theta, [0, 0, 1])' ) ... except StudentFacingError as error : ... print ( str ( error ) . replace ( '<br/>' , ' \\n ' )) There was an error evaluating function rot(...) 1st input is ok: received a vector of length 3 as expected 2nd input has an error: received a scalar, expected a vector of length 3 3rd input has an error: received a vector of length 3, expected a scalar","title":"The Solution"},{"location":"grading_math/user_functions/#configuring-specify_domain","text":"The decorator specify_domain accepts optional keyword arguments and should be called in either of two equivalent ways: >>> @specify_domain ( keyword_arguments ) # doctest: +SKIP ... def target_function ( x , y , z ): ... pass # do whatever you want >>> # or, equivalently: >>> def target_function ( x , y , z ): ... pass # do whatever you want >>> decorated_function = specify_domain ( keyword_arguments )( target_function ) # doctest: +SKIP The keyword arguments are: input_shapes : A list that indicates the shape of each input to the target function. This list must have the same length as the number of arguments in the target function. Each list element should be one of the following: 1 : indicates input is scalar k (positive integer > 1): indicates input is a k-component vector [k1, k2, ...] , list of positive integers: means input is an array of shape (k1, k2, ...) (k1, k2, ...) , tuple of positive integers: equivalent to [k1, k2, ...] 'square' (string): indicates a square matrix of any dimension display_name (str): Function name to be used in error messages. Defaults to None , meaning that the function's __name__ attribute is used. So, for example, >>> @specify_domain ( input_shapes = [ 1 , [ 3 , 2 ], 4 ], display_name = 'myfunc' ) ... def some_function ( x , A , v ): ... pass specifies that the function some_func must be called with three arguments: 1st argument: scalar, 2nd argument: 3 by 2 matrix, and a 3rd argument: 4-component vector.","title":"Configuring specify_domain"},{"location":"grading_math/user_functions/#arbitrary-same-shape-arguments","text":"Some functions may allow an arbitrary number of arguments to be passed in. For example, consider a user-defined minimum function: >>> def my_min ( * args ): ... return min ( * args ) To inform specify_domain that a function should accept arbitrarily many arguments of a certain shape, supply a single shape to input_shapes , and also pass in a min_length parameter, to specify the minimum number of arguments required. (If you specify min_length and have more than one shape in input_shapes , a ConfigError will result.) So, our my_min function can be decorated as follows: >>> @specify_domain ( input_shapes = [ 1 ], display_name = 'min' , min_length = 2 ) ... def my_min ( * args ): ... return min ( * args ) >>> my_min ( 1.5 , 2.3 , 4.6 ) 1.5 >>> try : ... my_min ( 1 ) ... except StudentFacingError as error : ... print ( error ) Wrong number of arguments passed to min(...): Expected at least 2 inputs, but received 1. >>> try : ... my_min ( MathArray ([ 1 , 2 ]), MathArray ([ 3 , 4 ])) ... except StudentFacingError as error : ... print ( error ) There was an error evaluating function min(...) 1st input has an error: received a vector of length 2, expected a scalar 2nd input has an error: received a vector of length 2, expected a scalar","title":"Arbitrary Same-Shape Arguments"},{"location":"grading_math/matrix_grader/matrix_grader/","text":"MatrixGrader # MatrixGrader is an extended version of FormulaGrader used to grade mathematical expressions containing scalars, vectors, and matrices. Authors and students may enter matrix (or vector) expressions by using variables sampled from matrices, or by entering a matrix entry-by-entry. Compared to FormulaGrader , MatrixGrader has enhanced error-handling capabilities specific to issues with arrays, extra functions for manipulating vectors and matrices, and partial credit options for component-by-component comparison. Do not let its name fool you: MatrixGrader is capable of handling vectors, matrices and tensors. We will sometimes refer to all of these possibilities as \"arrays\" ( MatrixGrader just sounds cooler than ArrayGrader though, doesn't it?). A First Example # A typical use of MatrixGrader might look like >>> from mitxgraders import * >>> grader1 = MatrixGrader ( ... answers = '4*A*B^2*v' , ... variables = [ 'A' , 'B' , 'v' ], ... identity_dim = 2 , # makes 'I' available to students as the 2x2 identity matrix ... sample_from = { ... 'A' : RealMatrices (), # samples from 2 by 2 matrices by default ... 'B' : RealMatrices (), ... 'v' : RealVectors ( shape = 2 ), # sample 2-component vectors ... } ... ) The next few lines call the grader as a check function. The inputs '4*A*B^2*v' and '4*A*B*B*v' are correct: >>> result = grader1 ( None , '4*A*B^2*v' ) >>> result == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> result = grader1 ( None , '4*A*B*B*v' ) >>> result == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True while the input '4*B*A*B*v' is incorrect because the matrix-sampled variables are non-commutative: >>> result = grader1 ( None , '4*B*A*B*v' ) >>> result == { 'msg' : '' , 'grade_decimal' : 0 , 'ok' : False } True Matrix Sampling # In the MatrixGrader example above, the variables A and B were sampled from RealMatrices() . The RealMatrices sampling class samples from 2 by 2 matrices by default but can be configured to sample matrices of different shapes. See Sampling for more information about matrix and vector sampling. Matrix Entry # In addition to using variables that vectors and matrices, students can also enter matrices and vectors directly, entry-by-entry. Input with symbols: Input entry-by-entry: Note In order for matrices entered entry-by-entry to display correctly in edX, authors must use the AsciiMath renderer provided by <textline math='true'/> . By default, students can only input vectors and not matrices . This is configured through the max_array_dim configuration key: max_array_dim=1 : This (the default) allows students to enter vectors entry-by-entry but not matrices. entering vector [x, y + 1, z] is OK. entering matrix [[1, x], [y, 2]] raises an error. max_array_dim=2 : This allows student to vectors and matrices. entering vector [x, y + 1, z] is OK. entering matrix [[1, x], [y, 2]] is OK. entering tensor [ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ] raises an error. The decision to disable matrix-entry by default is intended to prevent students from entering single-row or single-column matrices when a vector is expected. Matrix Operations and MathArrays # MatrixGrader uses a custom subclass of numpy.ndarray to internally represent matrices. Understanding how the MathArray class behaves is useful for creating MatrixGrader problems, and MathArray can be used directly by problem-authors to add extra matrices to a problem. How MatrixGrader uses MathArrays # Whether a matrix is input entry-by-entry or represented through variables, MathArray s are used to evaluate student expressions. For example, consider the grader below. >>> grader = MatrixGrader ( ... answers = '2*A*[1, 2, 3] + v' , ... user_constants = { ... 'A' : MathArray ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) ... }, ... variables = [ 'v' ], ... sample_from = { ... 'v' : RealVectors ( shape = 2 ) # samples a random 2-component vector ... } ... ) When a student inputs v + A*2*[1, 2, 3] to the grader above, a calculation similar to >>> v = MathArray ([ 2 , - 1 ]) # Really, random samples would be chosen. >>> A = MathArray ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> v + A * 2 * MathArray ([ 1 , 2 , 3 ]) # below is the result of evaluating student input, which would next be compared to author's answer MathArray([30, 63]) is performed (but repeated multiple times with different values for the random variables). Dimension and Shape # MathArray s have dimension and shape. For example: Student Input Converted to Name dimension shape [1, 2, 3] MathArray([1, 2, 3]) \"vector\" 1 (3, ) [[1, 2, 3], [4, 5, 6]] MathArray([[1, 2, 3], [4, 5, 6]]) \"matrix\" 2 (2, 3) [[1, 2, 3]] MathArray([[1, 2, 3]]) \"single-row matrix\" 2 (1, 3) [[1], [2], [3]] MathArray([[1], [2], [3]]) \"single-column matrix\" 2 (3, 1) [[[1, 2]], [[3, 4]]] MathArray([[[1, 2]], [[3, 4]]]) \"tensor\" 3 (1, 1, 2) Tensor math arrays (dimension 3+) currently have very little support. Warning Note that a vector, a single-column matrix, and a single-row matrix are distinct entities. We suggest avoiding single-row and single-column matrices. See A note about vectors Allowed operations # MathArray s support the usual binary operations for vectors and matrices, with appropriate shape restrictions. Compared to numpy.ndarray , MathArray has much more stringent shape restrictions. Addition and Subtraction : Performed elementwise. Expression raises error unless result type MathArray +/- MathArray both inputs have exactly the same shape MathArray MathArray +/- number number=0 MathArray number +/- MathArray number=0 MathArray Multiplication : Note that vector * vector is a dot product Expression left-input shape right-input shape raises error unless result type vector * vector (k1, ) (k2, ) k1=k2 number (dot product of two vectors) MathArray * number any - - MathArray (elementwise multiplication) number * MathArray - any - MathArray (elementwise multiplication) matrix * vector (m, n) (k) n=k vector with m components vector * matrix (k, ) (m, n) m=k vector with n components matrix * matrix (m1, n1) (m2, n2) n1=m2 matrix of shape (m1, n2) Note : Matrix multiplication may give students \"too much power\" for the type of problem you're asking. For example, if you want students to enter the product of two matrices or dot product of two vectors, you don't want them just entering the two quantities with a * between them. You can disable multiplication in MatrixGrader problems by setting forbidden_strings=['*'] . Division : Division either raises an error, or is performed elementwise: Expression raises error unless result type any / MathArray always raises error - MathArray / number - MathArray (elementwise division) Powers : If A is a MathArray, then A^k will always raise an error unless A is a square matrix, and k is an integer. In this case, A^k is equivalent to: k repeated multiplications of A if k > 0 , (inverse of A)^|k| if k < 0 , and the identity matrix if k=0 . Note : Negative exponents can give students \"too much power\". For example, if you want students to enter the inverse of [[1, 2], [3, 4]] , you probably want them to enter [[-2, 1], [1.5, -0.5]] rather than [[1, 2], [3, 4]]^-1 . To this end, you can disable negative powers in MatrixGrader problems by setting negative_powers=False . A Note About Vectors # Vectors are distinct from single-row matrices and single-column matrices, and can be left- or right-multiplied by a matrix: >>> vec = MathArray ([ 1 , 2 , 3 ]) >>> row = MathArray ([[ 1 , 2 , 3 ]]) >>> col = MathArray ([[ 1 ], [ 2 ], [ 3 ]]) >>> try : ... vec + row # raises error ... except StudentFacingError as error : ... print ( error ) Cannot add/subtract a vector of length 3 with a matrix of shape (rows: 1, cols: 3). >>> A = MathArray ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> A * vec # matrix * vector MathArray([14, 32]) >>> other_vec = MathArray ([ 1 , 2 ]) >>> other_vec * A # vector * matrix MathArray([ 9, 12, 15]) We suggest avoiding single-column and single-row matrices. Shape Errors # When operations cannot be performed because of shape-mismatch, MathArray raises readable StudentFacingError s. These error messages are intended to be presented directly to students. For example: >>> A = MathArray ([[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]]) # matrix, shape (3, 2) >>> B = MathArray ([[ 1 , 2 ], [ 3 , 4 ]]) # matrix, shape (2, 2) >>> v = MathArray ([ 1 , 2 ]) # vector, shape (2, ) Some sample error messages: Student input: Valid? Student receives error message: 'A+B' No Cannot add/subtract a matrix of shape (rows: 3, cols: 2) with a matrix of shape (rows: 2, cols: 2). 'v*A' No Cannot multiply a vector of length 2 with a matrix of shape (rows: 3, cols: 2). 'B*v' Yes 'A^2' No Cannot raise a non-square matrix to powers. 'B^2' Yes Handling Errors # While grading a student's input, matrix-related errors can occur in three places: while parsing the student's input, while evaluating the student's input, and while comparing the student's input to the author's stored answer. Parse Errors: # For example, if a student enters '[[1, 2],[3] ]' , a matrix missing an entry in second row: >>> grader = MatrixGrader ( ... answers = '[[1, 2], [3, 4]]' , ... max_array_dim = 2 , # allow students to enter matrices entry-by-entry ... ) >>> student_input = '[[1, 2], [3]]' >>> try : ... grader ( None , student_input ) # grade the input like edX would ... except StudentFacingError as error : ... print ( error ) # students see this error message Unable to parse vector/matrix. If you're trying to enter a matrix, this is most likely caused by an unequal number of elements in each row. Such parse errors are always displayed to students. Shape-Mismatch Errors During Evaluation # If a student submits an answer that will raise shape-mismatch errors then an error is raised with a helpful message. This avoids consuming one of the student's attempts. For example: >>> grader = MatrixGrader ( ... answers = '[11, 22, 33]' , ... ) >>> student_input = '[10, 20, 30] + [1, 2]' # Error! Adding vectors with different shapes >>> try : ... grader ( None , student_input ) # grade the input like edX would ... except StudentFacingError as error : ... print ( error ) # students see this error message Cannot add/subtract a vector of length 3 with a vector of length 2. If you would rather mark the student incorrect when shape errors occur (and also consume an attempt), set shape_errors=False . Shape-Mismatch Errors During Comparison # If the author's answer is a 3-component vector, and the student submits a different 3-component vector, then they will be marked incorrect. However, if the student submits a 2-component vector or a number, they will receive an error message: >>> grader = MatrixGrader ( ... answers = '[1, 2, 3]' , ... ) >>> student_input = '[1, 2, -3]' # wrong answer >>> result = grader ( None , student_input ) # grade the input like edX would >>> result == { 'msg' : '' , 'grade_decimal' : 0 , 'ok' : False } True >>> student_input = '[1, 2, 3, 4]' # too many components >>> try : ... grader ( None , student_input ) # grade the input like edX would ... except StudentFacingError as error : ... print ( error ) # students see this error message Expected answer to be a vector, but input is a vector of incorrect shape >>> student_input = '0' # scalar; should be a vector >>> try : ... grader ( None , student_input ) # grade the input like edX would ... except StudentFacingError as error : ... print ( error ) # students see this error message Expected answer to be a vector, but input is a scalar The default handling of shape errors that arise when comparing student input to author's answer is: raise an error (do not mark student incorrect), and reveal the desired type (above, a vector) but not the desired shape (above, 3-components) This behavior can be configured through the answer_shape_mismatch key. We can choose whether an error is presented or an attempt is consumed through the is_raised key, while we choose whether to reveal the desired input shape or type with the msg_detail key. For example, to mark students wrong instead of raising an error, and reveal the shape and the type we can use: >>> grader = MatrixGrader ( ... answers = '[1, 2, 3]' , ... answer_shape_mismatch = { ... 'is_raised' : False , ... 'msg_detail' : 'shape' # must be one of: None, 'type', 'shape' ... } ... ) >>> student_input = '0' # wrong shape >>> result = grader ( None , student_input ) # grades the input like edX would >>> result == { ... 'grade_decimal' : 0 , ... 'msg' : 'Expected answer to be a vector of length 3, but input is a scalar' , ... 'ok' : False ... } True Hiding All Error Messages # MatrixGrader s can be used to introduce non-commuting variables. In such a situation, students may not know that the variables they are using are matrices \"under the hood\", and so we want to suppress all matrix errors and messages. We can do this by setting suppress_matrix_messages=True , which overrides answer_shape_mismatch={'is_raised'} and shape_errors . In the following example, A and B are secretly matrices that don't commute, but students will never see a matrix error message from typing something like 1+A . >>> grader = MatrixGrader ( ... answers = 'A*B' , ... variables = [ 'A' , 'B' ], ... sample_from = { ... 'A' : RealMatrices (), ... 'B' : RealMatrices () ... }, ... max_array_dim = 0 , ... suppress_matrix_messages = True ... ) >>> grader ( None , 'A*B' )[ 'ok' ] True >>> grader ( None , 'B*A' )[ 'ok' ] False >>> grader ( None , 'A+1' )[ 'ok' ] False Note that this will also suppress error messages from trying to do things like sin([1, 2]) or [1, 2]^2 . If your answer needs to take functions of the non-commuting variables, then this option is insufficient. Matrix Functions # MatrixGrader provides all the default functions of FormulaGrader ( sin , cos , etc.) plus some extras such as trans(A) (transpose) and det(A) (determinant). See Mathematical Functions for full list. Since MatrixGrader has all of FormulaGrader 's configuration options, additional functions can be supplied through the user_functions configuration key. If you supply additional matrix functions, you may wish you use the specify_domain decorator function to provide meaningful error messages to students. See User Functions for details. Identity Matrix # To make an nxn identity matrix available to students, specify the configuration key identity_dim=n . That is, the grader MatrixGrader(identity_dim=4, ...) will automatically have a constant I whose value is the 4 by 4 identity matrix. If you want a different name (besides I ) for the identity, or if you encounter situations where identity matrices of different sizes are required, you can use the identity function. For example: >>> grader = MatrixGrader ( ... answers = '[1, 2, 3]' , ... user_constants = { ... 'I_2' : identity ( 2 ), # the 2 by 2 identity ... 'I_3' : identity ( 3 ) # the 3 by 3 identity ... } ... ) Partial Credit # A special comparer called MatrixEntryComparer has been built to cater for partial credit in MatrixGrader problems. In order to facilitate the use of MatrixEntryComparer , if either of the following two configuration options are present, MatrixGrader will use MatrixEntryComparer as the default comparer instead of equality_comparer . entry_partial_credit : proportional or a number entry_partial_msg : The message to display See the documentation for MatrixEntryComparer for details on how these options work. Configuration Options # MatrixGrader has almost all of FormulaGrader 's configuration options, plus some extras. The extras are: identity_dim : If specified as a positive integer n , then an n by n identity matrix is added to the available constants with name 'I' . Defaults to None . max_array_dim (nonnegative int): Controls the maximum dimension of arrays that students can enter entry-by-entry. Default is 1 : vectors can be entered entry-by-entry, but not matrices. negative_powers (bool): whether negative powers are enabled for square matrices (which calculate powers of matrix inverse). Defaults to True . shape_errors (bool): See Handling Errors: Shape-mismatch errors during evaluation . Defaults to True . suppress_matrix_messages (bool): See Hiding All Error Messages . Defaults to False . answer_shape_mismatch (dict): A dictionary whose keys are listed below. Some or all keys may be set. Unset keys take default values. See Handling Errors: Shape-mismatch errors during comparison for details. 'is_raised' (bool): defaults to True 'msg_detail' (None | 'type' | 'shape'): defaults to 'type' entry_partial_credit : If set to proportional or a number, uses this setting with MatrixEntryComparer as the default comparer. entry_partial_msg : If set to a text value, uses this setting with MatrixEntryComparer as the default comparer. The FormulaGrader configuration keys that MatrixGrader does not have are: allow_inf : We are unable to handle infinities appearing in vectors/matrices.","title":"MatrixGrader"},{"location":"grading_math/matrix_grader/matrix_grader/#matrixgrader","text":"MatrixGrader is an extended version of FormulaGrader used to grade mathematical expressions containing scalars, vectors, and matrices. Authors and students may enter matrix (or vector) expressions by using variables sampled from matrices, or by entering a matrix entry-by-entry. Compared to FormulaGrader , MatrixGrader has enhanced error-handling capabilities specific to issues with arrays, extra functions for manipulating vectors and matrices, and partial credit options for component-by-component comparison. Do not let its name fool you: MatrixGrader is capable of handling vectors, matrices and tensors. We will sometimes refer to all of these possibilities as \"arrays\" ( MatrixGrader just sounds cooler than ArrayGrader though, doesn't it?).","title":"MatrixGrader"},{"location":"grading_math/matrix_grader/matrix_grader/#a-first-example","text":"A typical use of MatrixGrader might look like >>> from mitxgraders import * >>> grader1 = MatrixGrader ( ... answers = '4*A*B^2*v' , ... variables = [ 'A' , 'B' , 'v' ], ... identity_dim = 2 , # makes 'I' available to students as the 2x2 identity matrix ... sample_from = { ... 'A' : RealMatrices (), # samples from 2 by 2 matrices by default ... 'B' : RealMatrices (), ... 'v' : RealVectors ( shape = 2 ), # sample 2-component vectors ... } ... ) The next few lines call the grader as a check function. The inputs '4*A*B^2*v' and '4*A*B*B*v' are correct: >>> result = grader1 ( None , '4*A*B^2*v' ) >>> result == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True >>> result = grader1 ( None , '4*A*B*B*v' ) >>> result == { 'grade_decimal' : 1 , 'msg' : '' , 'ok' : True } True while the input '4*B*A*B*v' is incorrect because the matrix-sampled variables are non-commutative: >>> result = grader1 ( None , '4*B*A*B*v' ) >>> result == { 'msg' : '' , 'grade_decimal' : 0 , 'ok' : False } True","title":"A First Example"},{"location":"grading_math/matrix_grader/matrix_grader/#matrix-sampling","text":"In the MatrixGrader example above, the variables A and B were sampled from RealMatrices() . The RealMatrices sampling class samples from 2 by 2 matrices by default but can be configured to sample matrices of different shapes. See Sampling for more information about matrix and vector sampling.","title":"Matrix Sampling"},{"location":"grading_math/matrix_grader/matrix_grader/#matrix-entry","text":"In addition to using variables that vectors and matrices, students can also enter matrices and vectors directly, entry-by-entry. Input with symbols: Input entry-by-entry: Note In order for matrices entered entry-by-entry to display correctly in edX, authors must use the AsciiMath renderer provided by <textline math='true'/> . By default, students can only input vectors and not matrices . This is configured through the max_array_dim configuration key: max_array_dim=1 : This (the default) allows students to enter vectors entry-by-entry but not matrices. entering vector [x, y + 1, z] is OK. entering matrix [[1, x], [y, 2]] raises an error. max_array_dim=2 : This allows student to vectors and matrices. entering vector [x, y + 1, z] is OK. entering matrix [[1, x], [y, 2]] is OK. entering tensor [ [[1, 2], [3, 4]], [[5, 6], [7, 8]] ] raises an error. The decision to disable matrix-entry by default is intended to prevent students from entering single-row or single-column matrices when a vector is expected.","title":"Matrix Entry"},{"location":"grading_math/matrix_grader/matrix_grader/#matrix-operations-and-matharrays","text":"MatrixGrader uses a custom subclass of numpy.ndarray to internally represent matrices. Understanding how the MathArray class behaves is useful for creating MatrixGrader problems, and MathArray can be used directly by problem-authors to add extra matrices to a problem.","title":"Matrix Operations and MathArrays"},{"location":"grading_math/matrix_grader/matrix_grader/#how-matrixgrader-uses-matharrays","text":"Whether a matrix is input entry-by-entry or represented through variables, MathArray s are used to evaluate student expressions. For example, consider the grader below. >>> grader = MatrixGrader ( ... answers = '2*A*[1, 2, 3] + v' , ... user_constants = { ... 'A' : MathArray ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) ... }, ... variables = [ 'v' ], ... sample_from = { ... 'v' : RealVectors ( shape = 2 ) # samples a random 2-component vector ... } ... ) When a student inputs v + A*2*[1, 2, 3] to the grader above, a calculation similar to >>> v = MathArray ([ 2 , - 1 ]) # Really, random samples would be chosen. >>> A = MathArray ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> v + A * 2 * MathArray ([ 1 , 2 , 3 ]) # below is the result of evaluating student input, which would next be compared to author's answer MathArray([30, 63]) is performed (but repeated multiple times with different values for the random variables).","title":"How MatrixGrader uses MathArrays"},{"location":"grading_math/matrix_grader/matrix_grader/#dimension-and-shape","text":"MathArray s have dimension and shape. For example: Student Input Converted to Name dimension shape [1, 2, 3] MathArray([1, 2, 3]) \"vector\" 1 (3, ) [[1, 2, 3], [4, 5, 6]] MathArray([[1, 2, 3], [4, 5, 6]]) \"matrix\" 2 (2, 3) [[1, 2, 3]] MathArray([[1, 2, 3]]) \"single-row matrix\" 2 (1, 3) [[1], [2], [3]] MathArray([[1], [2], [3]]) \"single-column matrix\" 2 (3, 1) [[[1, 2]], [[3, 4]]] MathArray([[[1, 2]], [[3, 4]]]) \"tensor\" 3 (1, 1, 2) Tensor math arrays (dimension 3+) currently have very little support. Warning Note that a vector, a single-column matrix, and a single-row matrix are distinct entities. We suggest avoiding single-row and single-column matrices. See A note about vectors","title":"Dimension and Shape"},{"location":"grading_math/matrix_grader/matrix_grader/#allowed-operations","text":"MathArray s support the usual binary operations for vectors and matrices, with appropriate shape restrictions. Compared to numpy.ndarray , MathArray has much more stringent shape restrictions. Addition and Subtraction : Performed elementwise. Expression raises error unless result type MathArray +/- MathArray both inputs have exactly the same shape MathArray MathArray +/- number number=0 MathArray number +/- MathArray number=0 MathArray Multiplication : Note that vector * vector is a dot product Expression left-input shape right-input shape raises error unless result type vector * vector (k1, ) (k2, ) k1=k2 number (dot product of two vectors) MathArray * number any - - MathArray (elementwise multiplication) number * MathArray - any - MathArray (elementwise multiplication) matrix * vector (m, n) (k) n=k vector with m components vector * matrix (k, ) (m, n) m=k vector with n components matrix * matrix (m1, n1) (m2, n2) n1=m2 matrix of shape (m1, n2) Note : Matrix multiplication may give students \"too much power\" for the type of problem you're asking. For example, if you want students to enter the product of two matrices or dot product of two vectors, you don't want them just entering the two quantities with a * between them. You can disable multiplication in MatrixGrader problems by setting forbidden_strings=['*'] . Division : Division either raises an error, or is performed elementwise: Expression raises error unless result type any / MathArray always raises error - MathArray / number - MathArray (elementwise division) Powers : If A is a MathArray, then A^k will always raise an error unless A is a square matrix, and k is an integer. In this case, A^k is equivalent to: k repeated multiplications of A if k > 0 , (inverse of A)^|k| if k < 0 , and the identity matrix if k=0 . Note : Negative exponents can give students \"too much power\". For example, if you want students to enter the inverse of [[1, 2], [3, 4]] , you probably want them to enter [[-2, 1], [1.5, -0.5]] rather than [[1, 2], [3, 4]]^-1 . To this end, you can disable negative powers in MatrixGrader problems by setting negative_powers=False .","title":"Allowed operations"},{"location":"grading_math/matrix_grader/matrix_grader/#a-note-about-vectors","text":"Vectors are distinct from single-row matrices and single-column matrices, and can be left- or right-multiplied by a matrix: >>> vec = MathArray ([ 1 , 2 , 3 ]) >>> row = MathArray ([[ 1 , 2 , 3 ]]) >>> col = MathArray ([[ 1 ], [ 2 ], [ 3 ]]) >>> try : ... vec + row # raises error ... except StudentFacingError as error : ... print ( error ) Cannot add/subtract a vector of length 3 with a matrix of shape (rows: 1, cols: 3). >>> A = MathArray ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) >>> A * vec # matrix * vector MathArray([14, 32]) >>> other_vec = MathArray ([ 1 , 2 ]) >>> other_vec * A # vector * matrix MathArray([ 9, 12, 15]) We suggest avoiding single-column and single-row matrices.","title":"A Note About Vectors"},{"location":"grading_math/matrix_grader/matrix_grader/#shape-errors","text":"When operations cannot be performed because of shape-mismatch, MathArray raises readable StudentFacingError s. These error messages are intended to be presented directly to students. For example: >>> A = MathArray ([[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]]) # matrix, shape (3, 2) >>> B = MathArray ([[ 1 , 2 ], [ 3 , 4 ]]) # matrix, shape (2, 2) >>> v = MathArray ([ 1 , 2 ]) # vector, shape (2, ) Some sample error messages: Student input: Valid? Student receives error message: 'A+B' No Cannot add/subtract a matrix of shape (rows: 3, cols: 2) with a matrix of shape (rows: 2, cols: 2). 'v*A' No Cannot multiply a vector of length 2 with a matrix of shape (rows: 3, cols: 2). 'B*v' Yes 'A^2' No Cannot raise a non-square matrix to powers. 'B^2' Yes","title":"Shape Errors"},{"location":"grading_math/matrix_grader/matrix_grader/#handling-errors","text":"While grading a student's input, matrix-related errors can occur in three places: while parsing the student's input, while evaluating the student's input, and while comparing the student's input to the author's stored answer.","title":"Handling Errors"},{"location":"grading_math/matrix_grader/matrix_grader/#parse-errors","text":"For example, if a student enters '[[1, 2],[3] ]' , a matrix missing an entry in second row: >>> grader = MatrixGrader ( ... answers = '[[1, 2], [3, 4]]' , ... max_array_dim = 2 , # allow students to enter matrices entry-by-entry ... ) >>> student_input = '[[1, 2], [3]]' >>> try : ... grader ( None , student_input ) # grade the input like edX would ... except StudentFacingError as error : ... print ( error ) # students see this error message Unable to parse vector/matrix. If you're trying to enter a matrix, this is most likely caused by an unequal number of elements in each row. Such parse errors are always displayed to students.","title":"Parse Errors:"},{"location":"grading_math/matrix_grader/matrix_grader/#shape-mismatch-errors-during-evaluation","text":"If a student submits an answer that will raise shape-mismatch errors then an error is raised with a helpful message. This avoids consuming one of the student's attempts. For example: >>> grader = MatrixGrader ( ... answers = '[11, 22, 33]' , ... ) >>> student_input = '[10, 20, 30] + [1, 2]' # Error! Adding vectors with different shapes >>> try : ... grader ( None , student_input ) # grade the input like edX would ... except StudentFacingError as error : ... print ( error ) # students see this error message Cannot add/subtract a vector of length 3 with a vector of length 2. If you would rather mark the student incorrect when shape errors occur (and also consume an attempt), set shape_errors=False .","title":"Shape-Mismatch Errors During Evaluation"},{"location":"grading_math/matrix_grader/matrix_grader/#shape-mismatch-errors-during-comparison","text":"If the author's answer is a 3-component vector, and the student submits a different 3-component vector, then they will be marked incorrect. However, if the student submits a 2-component vector or a number, they will receive an error message: >>> grader = MatrixGrader ( ... answers = '[1, 2, 3]' , ... ) >>> student_input = '[1, 2, -3]' # wrong answer >>> result = grader ( None , student_input ) # grade the input like edX would >>> result == { 'msg' : '' , 'grade_decimal' : 0 , 'ok' : False } True >>> student_input = '[1, 2, 3, 4]' # too many components >>> try : ... grader ( None , student_input ) # grade the input like edX would ... except StudentFacingError as error : ... print ( error ) # students see this error message Expected answer to be a vector, but input is a vector of incorrect shape >>> student_input = '0' # scalar; should be a vector >>> try : ... grader ( None , student_input ) # grade the input like edX would ... except StudentFacingError as error : ... print ( error ) # students see this error message Expected answer to be a vector, but input is a scalar The default handling of shape errors that arise when comparing student input to author's answer is: raise an error (do not mark student incorrect), and reveal the desired type (above, a vector) but not the desired shape (above, 3-components) This behavior can be configured through the answer_shape_mismatch key. We can choose whether an error is presented or an attempt is consumed through the is_raised key, while we choose whether to reveal the desired input shape or type with the msg_detail key. For example, to mark students wrong instead of raising an error, and reveal the shape and the type we can use: >>> grader = MatrixGrader ( ... answers = '[1, 2, 3]' , ... answer_shape_mismatch = { ... 'is_raised' : False , ... 'msg_detail' : 'shape' # must be one of: None, 'type', 'shape' ... } ... ) >>> student_input = '0' # wrong shape >>> result = grader ( None , student_input ) # grades the input like edX would >>> result == { ... 'grade_decimal' : 0 , ... 'msg' : 'Expected answer to be a vector of length 3, but input is a scalar' , ... 'ok' : False ... } True","title":"Shape-Mismatch Errors During Comparison"},{"location":"grading_math/matrix_grader/matrix_grader/#hiding-all-error-messages","text":"MatrixGrader s can be used to introduce non-commuting variables. In such a situation, students may not know that the variables they are using are matrices \"under the hood\", and so we want to suppress all matrix errors and messages. We can do this by setting suppress_matrix_messages=True , which overrides answer_shape_mismatch={'is_raised'} and shape_errors . In the following example, A and B are secretly matrices that don't commute, but students will never see a matrix error message from typing something like 1+A . >>> grader = MatrixGrader ( ... answers = 'A*B' , ... variables = [ 'A' , 'B' ], ... sample_from = { ... 'A' : RealMatrices (), ... 'B' : RealMatrices () ... }, ... max_array_dim = 0 , ... suppress_matrix_messages = True ... ) >>> grader ( None , 'A*B' )[ 'ok' ] True >>> grader ( None , 'B*A' )[ 'ok' ] False >>> grader ( None , 'A+1' )[ 'ok' ] False Note that this will also suppress error messages from trying to do things like sin([1, 2]) or [1, 2]^2 . If your answer needs to take functions of the non-commuting variables, then this option is insufficient.","title":"Hiding All Error Messages"},{"location":"grading_math/matrix_grader/matrix_grader/#matrix-functions","text":"MatrixGrader provides all the default functions of FormulaGrader ( sin , cos , etc.) plus some extras such as trans(A) (transpose) and det(A) (determinant). See Mathematical Functions for full list. Since MatrixGrader has all of FormulaGrader 's configuration options, additional functions can be supplied through the user_functions configuration key. If you supply additional matrix functions, you may wish you use the specify_domain decorator function to provide meaningful error messages to students. See User Functions for details.","title":"Matrix Functions"},{"location":"grading_math/matrix_grader/matrix_grader/#identity-matrix","text":"To make an nxn identity matrix available to students, specify the configuration key identity_dim=n . That is, the grader MatrixGrader(identity_dim=4, ...) will automatically have a constant I whose value is the 4 by 4 identity matrix. If you want a different name (besides I ) for the identity, or if you encounter situations where identity matrices of different sizes are required, you can use the identity function. For example: >>> grader = MatrixGrader ( ... answers = '[1, 2, 3]' , ... user_constants = { ... 'I_2' : identity ( 2 ), # the 2 by 2 identity ... 'I_3' : identity ( 3 ) # the 3 by 3 identity ... } ... )","title":"Identity Matrix"},{"location":"grading_math/matrix_grader/matrix_grader/#partial-credit","text":"A special comparer called MatrixEntryComparer has been built to cater for partial credit in MatrixGrader problems. In order to facilitate the use of MatrixEntryComparer , if either of the following two configuration options are present, MatrixGrader will use MatrixEntryComparer as the default comparer instead of equality_comparer . entry_partial_credit : proportional or a number entry_partial_msg : The message to display See the documentation for MatrixEntryComparer for details on how these options work.","title":"Partial Credit"},{"location":"grading_math/matrix_grader/matrix_grader/#configuration-options","text":"MatrixGrader has almost all of FormulaGrader 's configuration options, plus some extras. The extras are: identity_dim : If specified as a positive integer n , then an n by n identity matrix is added to the available constants with name 'I' . Defaults to None . max_array_dim (nonnegative int): Controls the maximum dimension of arrays that students can enter entry-by-entry. Default is 1 : vectors can be entered entry-by-entry, but not matrices. negative_powers (bool): whether negative powers are enabled for square matrices (which calculate powers of matrix inverse). Defaults to True . shape_errors (bool): See Handling Errors: Shape-mismatch errors during evaluation . Defaults to True . suppress_matrix_messages (bool): See Hiding All Error Messages . Defaults to False . answer_shape_mismatch (dict): A dictionary whose keys are listed below. Some or all keys may be set. Unset keys take default values. See Handling Errors: Shape-mismatch errors during comparison for details. 'is_raised' (bool): defaults to True 'msg_detail' (None | 'type' | 'shape'): defaults to 'type' entry_partial_credit : If set to proportional or a number, uses this setting with MatrixEntryComparer as the default comparer. entry_partial_msg : If set to a text value, uses this setting with MatrixEntryComparer as the default comparer. The FormulaGrader configuration keys that MatrixGrader does not have are: allow_inf : We are unable to handle infinities appearing in vectors/matrices.","title":"Configuration Options"}]}